/* empty css                                */
import { d as createAstro, c as createComponent, m as maybeRenderHead, e as addAttribute, a as renderTemplate, g as getAugmentedNamespace, s as spreadAttributes, u as unescapeHTML, r as renderComponent, F as Fragment, f as renderScript } from '../chunks/astro/server_BUEHO2fz.mjs';
import { $ as $$Layout } from '../chunks/Layout_DsW7tR7Y.mjs';
import { g as getPosts, a as $$Card, $ as $$ArticleDisplay } from '../chunks/funcs_CeIReeHe.mjs';
import { $ as $$Section } from '../chunks/FormattedDate_D4iLkoSx.mjs';
import require$$1$3 from 'os';
import nativeFs from 'fs';
import require$$0$4 from 'url';
import path$1 from 'path';
export { renderers } from '../renderers.mjs';

const $$Astro$5 = createAstro("https://willcarkner.com");
const $$Project = createComponent(($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$5, $$props, $$slots);
  Astro2.self = $$Project;
  const { title, tags, image, url, class: className } = Astro2.props;
  return renderTemplate`${maybeRenderHead()}<a${addAttribute(url, "href")} target="_blank" class="no-underline w-full"> <div${addAttribute([
    "flex flex-row items-center duration-300 space-x-4 hover:scale-110"
  ], "class:list")}> <img${addAttribute(image, "src")}${addAttribute(["h-24 w-auto border border-gray-600 rounded-lg", className], "class:list")}${addAttribute(title + "image", "alt")}> <div class="flex flex-col space-y-2 text-left"> <p class="sm:text-2xl text-xl font-mono font-semibold"> ${title} </p> <div class="flex flex-wrap xs:flex-nowrap xs:flex-row xs:space-y-0 items-center justify-start space-x-2"> ${tags.map((tag) => renderTemplate`<span${addAttribute([
    "bg-slate-600 w-fit bg-opacity-50 text-xs shadow-lg rounded-md px-2 py-1 text-white",
    tags.indexOf(tag) === tags.length - 1 ? "mt-2 xs:mt-0 -translate-x-2 xs:translate-x-0" : ""
  ], "class:list")}> ${tag} </span>`)} </div> </div> </div> </a>`;
}, "/Users/williamcarkner/coding/will-carkner-com/src/components/Project.astro", void 0);

const SPRITESHEET_NAMESPACE = `astroicon`;

const baseURL = "https://api.astroicon.dev/v1/";
const requests = /* @__PURE__ */ new Map();
const fetchCache = /* @__PURE__ */ new Map();
async function get(pack, name) {
  const url = new URL(`./${pack}/${name}`, baseURL).toString();
  if (requests.has(url)) {
    return await requests.get(url);
  }
  if (fetchCache.has(url)) {
    return fetchCache.get(url);
  }
  let request = async () => {
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(await res.text());
    }
    const contentType = res.headers.get("Content-Type");
    if (!contentType.includes("svg")) {
      throw new Error(`[astro-icon] Unable to load "${name}" because it did not resolve to an SVG!

Recieved the following "Content-Type":
${contentType}`);
    }
    const svg = await res.text();
    fetchCache.set(url, svg);
    requests.delete(url);
    return svg;
  };
  let promise = request();
  requests.set(url, promise);
  return await promise;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var svgoNode = {};

var svgo = {};

var config = {};

var plugins$1 = {};

var plugins = {};

var xast = {};

var lib$8 = {};

var lib$7 = {};

var stringify$1 = {};

var lib$6 = {};

var lib$5 = {};

var hasRequiredLib$8;

function requireLib$8 () {
	if (hasRequiredLib$8) return lib$5;
	hasRequiredLib$8 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
		/** Types of elements found in htmlparser2's DOM */
		var ElementType;
		(function (ElementType) {
		    /** Type for the root element of a document */
		    ElementType["Root"] = "root";
		    /** Type for Text */
		    ElementType["Text"] = "text";
		    /** Type for <? ... ?> */
		    ElementType["Directive"] = "directive";
		    /** Type for <!-- ... --> */
		    ElementType["Comment"] = "comment";
		    /** Type for <script> tags */
		    ElementType["Script"] = "script";
		    /** Type for <style> tags */
		    ElementType["Style"] = "style";
		    /** Type for Any tag */
		    ElementType["Tag"] = "tag";
		    /** Type for <![CDATA[ ... ]]> */
		    ElementType["CDATA"] = "cdata";
		    /** Type for <!doctype ...> */
		    ElementType["Doctype"] = "doctype";
		})(ElementType = exports.ElementType || (exports.ElementType = {}));
		/**
		 * Tests whether an element is a tag or not.
		 *
		 * @param elem Element to test
		 */
		function isTag(elem) {
		    return (elem.type === ElementType.Tag ||
		        elem.type === ElementType.Script ||
		        elem.type === ElementType.Style);
		}
		exports.isTag = isTag;
		// Exports for backwards compatibility
		/** Type for the root element of a document */
		exports.Root = ElementType.Root;
		/** Type for Text */
		exports.Text = ElementType.Text;
		/** Type for <? ... ?> */
		exports.Directive = ElementType.Directive;
		/** Type for <!-- ... --> */
		exports.Comment = ElementType.Comment;
		/** Type for <script> tags */
		exports.Script = ElementType.Script;
		/** Type for <style> tags */
		exports.Style = ElementType.Style;
		/** Type for Any tag */
		exports.Tag = ElementType.Tag;
		/** Type for <![CDATA[ ... ]]> */
		exports.CDATA = ElementType.CDATA;
		/** Type for <!doctype ...> */
		exports.Doctype = ElementType.Doctype; 
	} (lib$5));
	return lib$5;
}

var node$1 = {};

var hasRequiredNode$1;

function requireNode$1 () {
	if (hasRequiredNode$1) return node$1;
	hasRequiredNode$1 = 1;
	var __extends = (node$1 && node$1.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (node$1 && node$1.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(node$1, "__esModule", { value: true });
	node$1.cloneNode = node$1.hasChildren = node$1.isDocument = node$1.isDirective = node$1.isComment = node$1.isText = node$1.isCDATA = node$1.isTag = node$1.Element = node$1.Document = node$1.NodeWithChildren = node$1.ProcessingInstruction = node$1.Comment = node$1.Text = node$1.DataNode = node$1.Node = void 0;
	var domelementtype_1 = /*@__PURE__*/ requireLib$8();
	var nodeTypes = new Map([
	    [domelementtype_1.ElementType.Tag, 1],
	    [domelementtype_1.ElementType.Script, 1],
	    [domelementtype_1.ElementType.Style, 1],
	    [domelementtype_1.ElementType.Directive, 1],
	    [domelementtype_1.ElementType.Text, 3],
	    [domelementtype_1.ElementType.CDATA, 4],
	    [domelementtype_1.ElementType.Comment, 8],
	    [domelementtype_1.ElementType.Root, 9],
	]);
	/**
	 * This object will be used as the prototype for Nodes when creating a
	 * DOM-Level-1-compliant structure.
	 */
	var Node = /** @class */ (function () {
	    /**
	     *
	     * @param type The type of the node.
	     */
	    function Node(type) {
	        this.type = type;
	        /** Parent of the node */
	        this.parent = null;
	        /** Previous sibling */
	        this.prev = null;
	        /** Next sibling */
	        this.next = null;
	        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
	        this.startIndex = null;
	        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
	        this.endIndex = null;
	    }
	    Object.defineProperty(Node.prototype, "nodeType", {
	        // Read-only aliases
	        /**
	         * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
	         * node {@link type}.
	         */
	        get: function () {
	            var _a;
	            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "parentNode", {
	        // Read-write aliases for properties
	        /**
	         * Same as {@link parent}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.parent;
	        },
	        set: function (parent) {
	            this.parent = parent;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "previousSibling", {
	        /**
	         * Same as {@link prev}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.prev;
	        },
	        set: function (prev) {
	            this.prev = prev;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Node.prototype, "nextSibling", {
	        /**
	         * Same as {@link next}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.next;
	        },
	        set: function (next) {
	            this.next = next;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Clone this node, and optionally its children.
	     *
	     * @param recursive Clone child nodes as well.
	     * @returns A clone of the node.
	     */
	    Node.prototype.cloneNode = function (recursive) {
	        if (recursive === void 0) { recursive = false; }
	        return cloneNode(this, recursive);
	    };
	    return Node;
	}());
	node$1.Node = Node;
	/**
	 * A node that contains some data.
	 */
	var DataNode = /** @class */ (function (_super) {
	    __extends(DataNode, _super);
	    /**
	     * @param type The type of the node
	     * @param data The content of the data node
	     */
	    function DataNode(type, data) {
	        var _this = _super.call(this, type) || this;
	        _this.data = data;
	        return _this;
	    }
	    Object.defineProperty(DataNode.prototype, "nodeValue", {
	        /**
	         * Same as {@link data}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.data;
	        },
	        set: function (data) {
	            this.data = data;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return DataNode;
	}(Node));
	node$1.DataNode = DataNode;
	/**
	 * Text within the document.
	 */
	var Text = /** @class */ (function (_super) {
	    __extends(Text, _super);
	    function Text(data) {
	        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
	    }
	    return Text;
	}(DataNode));
	node$1.Text = Text;
	/**
	 * Comments within the document.
	 */
	var Comment = /** @class */ (function (_super) {
	    __extends(Comment, _super);
	    function Comment(data) {
	        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
	    }
	    return Comment;
	}(DataNode));
	node$1.Comment = Comment;
	/**
	 * Processing instructions, including doc types.
	 */
	var ProcessingInstruction = /** @class */ (function (_super) {
	    __extends(ProcessingInstruction, _super);
	    function ProcessingInstruction(name, data) {
	        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
	        _this.name = name;
	        return _this;
	    }
	    return ProcessingInstruction;
	}(DataNode));
	node$1.ProcessingInstruction = ProcessingInstruction;
	/**
	 * A `Node` that can have children.
	 */
	var NodeWithChildren = /** @class */ (function (_super) {
	    __extends(NodeWithChildren, _super);
	    /**
	     * @param type Type of the node.
	     * @param children Children of the node. Only certain node types can have children.
	     */
	    function NodeWithChildren(type, children) {
	        var _this = _super.call(this, type) || this;
	        _this.children = children;
	        return _this;
	    }
	    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
	        // Aliases
	        /** First child of the node. */
	        get: function () {
	            var _a;
	            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
	        /** Last child of the node. */
	        get: function () {
	            return this.children.length > 0
	                ? this.children[this.children.length - 1]
	                : null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
	        /**
	         * Same as {@link children}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.children;
	        },
	        set: function (children) {
	            this.children = children;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return NodeWithChildren;
	}(Node));
	node$1.NodeWithChildren = NodeWithChildren;
	/**
	 * The root node of the document.
	 */
	var Document = /** @class */ (function (_super) {
	    __extends(Document, _super);
	    function Document(children) {
	        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
	    }
	    return Document;
	}(NodeWithChildren));
	node$1.Document = Document;
	/**
	 * An element within the DOM.
	 */
	var Element = /** @class */ (function (_super) {
	    __extends(Element, _super);
	    /**
	     * @param name Name of the tag, eg. `div`, `span`.
	     * @param attribs Object mapping attribute names to attribute values.
	     * @param children Children of the node.
	     */
	    function Element(name, attribs, children, type) {
	        if (children === void 0) { children = []; }
	        if (type === void 0) { type = name === "script"
	            ? domelementtype_1.ElementType.Script
	            : name === "style"
	                ? domelementtype_1.ElementType.Style
	                : domelementtype_1.ElementType.Tag; }
	        var _this = _super.call(this, type, children) || this;
	        _this.name = name;
	        _this.attribs = attribs;
	        return _this;
	    }
	    Object.defineProperty(Element.prototype, "tagName", {
	        // DOM Level 1 aliases
	        /**
	         * Same as {@link name}.
	         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
	         */
	        get: function () {
	            return this.name;
	        },
	        set: function (name) {
	            this.name = name;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Element.prototype, "attributes", {
	        get: function () {
	            var _this = this;
	            return Object.keys(this.attribs).map(function (name) {
	                var _a, _b;
	                return ({
	                    name: name,
	                    value: _this.attribs[name],
	                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
	                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
	                });
	            });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return Element;
	}(NodeWithChildren));
	node$1.Element = Element;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node is a `Element`, `false` otherwise.
	 */
	function isTag(node) {
	    return (0, domelementtype_1.isTag)(node);
	}
	node$1.isTag = isTag;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
	 */
	function isCDATA(node) {
	    return node.type === domelementtype_1.ElementType.CDATA;
	}
	node$1.isCDATA = isCDATA;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `Text`, `false` otherwise.
	 */
	function isText(node) {
	    return node.type === domelementtype_1.ElementType.Text;
	}
	node$1.isText = isText;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `Comment`, `false` otherwise.
	 */
	function isComment(node) {
	    return node.type === domelementtype_1.ElementType.Comment;
	}
	node$1.isComment = isComment;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
	 */
	function isDirective(node) {
	    return node.type === domelementtype_1.ElementType.Directive;
	}
	node$1.isDirective = isDirective;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
	 */
	function isDocument(node) {
	    return node.type === domelementtype_1.ElementType.Root;
	}
	node$1.isDocument = isDocument;
	/**
	 * @param node Node to check.
	 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
	 */
	function hasChildren(node) {
	    return Object.prototype.hasOwnProperty.call(node, "children");
	}
	node$1.hasChildren = hasChildren;
	/**
	 * Clone a node, and optionally its children.
	 *
	 * @param recursive Clone child nodes as well.
	 * @returns A clone of the node.
	 */
	function cloneNode(node, recursive) {
	    if (recursive === void 0) { recursive = false; }
	    var result;
	    if (isText(node)) {
	        result = new Text(node.data);
	    }
	    else if (isComment(node)) {
	        result = new Comment(node.data);
	    }
	    else if (isTag(node)) {
	        var children = recursive ? cloneChildren(node.children) : [];
	        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
	        children.forEach(function (child) { return (child.parent = clone_1); });
	        if (node.namespace != null) {
	            clone_1.namespace = node.namespace;
	        }
	        if (node["x-attribsNamespace"]) {
	            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
	        }
	        if (node["x-attribsPrefix"]) {
	            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
	        }
	        result = clone_1;
	    }
	    else if (isCDATA(node)) {
	        var children = recursive ? cloneChildren(node.children) : [];
	        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
	        children.forEach(function (child) { return (child.parent = clone_2); });
	        result = clone_2;
	    }
	    else if (isDocument(node)) {
	        var children = recursive ? cloneChildren(node.children) : [];
	        var clone_3 = new Document(children);
	        children.forEach(function (child) { return (child.parent = clone_3); });
	        if (node["x-mode"]) {
	            clone_3["x-mode"] = node["x-mode"];
	        }
	        result = clone_3;
	    }
	    else if (isDirective(node)) {
	        var instruction = new ProcessingInstruction(node.name, node.data);
	        if (node["x-name"] != null) {
	            instruction["x-name"] = node["x-name"];
	            instruction["x-publicId"] = node["x-publicId"];
	            instruction["x-systemId"] = node["x-systemId"];
	        }
	        result = instruction;
	    }
	    else {
	        throw new Error("Not implemented yet: ".concat(node.type));
	    }
	    result.startIndex = node.startIndex;
	    result.endIndex = node.endIndex;
	    if (node.sourceCodeLocation != null) {
	        result.sourceCodeLocation = node.sourceCodeLocation;
	    }
	    return result;
	}
	node$1.cloneNode = cloneNode;
	function cloneChildren(childs) {
	    var children = childs.map(function (child) { return cloneNode(child, true); });
	    for (var i = 1; i < children.length; i++) {
	        children[i].prev = children[i - 1];
	        children[i - 1].next = children[i];
	    }
	    return children;
	}
	return node$1;
}

var hasRequiredLib$7;

function requireLib$7 () {
	if (hasRequiredLib$7) return lib$6;
	hasRequiredLib$7 = 1;
	(function (exports) {
		var __createBinding = (lib$6 && lib$6.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (lib$6 && lib$6.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.DomHandler = void 0;
		var domelementtype_1 = /*@__PURE__*/ requireLib$8();
		var node_1 = /*@__PURE__*/ requireNode$1();
		__exportStar(/*@__PURE__*/ requireNode$1(), exports);
		var reWhitespace = /\s+/g;
		// Default options
		var defaultOpts = {
		    normalizeWhitespace: false,
		    withStartIndices: false,
		    withEndIndices: false,
		    xmlMode: false,
		};
		var DomHandler = /** @class */ (function () {
		    /**
		     * @param callback Called once parsing has completed.
		     * @param options Settings for the handler.
		     * @param elementCB Callback whenever a tag is closed.
		     */
		    function DomHandler(callback, options, elementCB) {
		        /** The elements of the DOM */
		        this.dom = [];
		        /** The root element for the DOM */
		        this.root = new node_1.Document(this.dom);
		        /** Indicated whether parsing has been completed. */
		        this.done = false;
		        /** Stack of open tags. */
		        this.tagStack = [this.root];
		        /** A data node that is still being written to. */
		        this.lastNode = null;
		        /** Reference to the parser instance. Used for location information. */
		        this.parser = null;
		        // Make it possible to skip arguments, for backwards-compatibility
		        if (typeof options === "function") {
		            elementCB = options;
		            options = defaultOpts;
		        }
		        if (typeof callback === "object") {
		            options = callback;
		            callback = undefined;
		        }
		        this.callback = callback !== null && callback !== void 0 ? callback : null;
		        this.options = options !== null && options !== void 0 ? options : defaultOpts;
		        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
		    }
		    DomHandler.prototype.onparserinit = function (parser) {
		        this.parser = parser;
		    };
		    // Resets the handler back to starting state
		    DomHandler.prototype.onreset = function () {
		        this.dom = [];
		        this.root = new node_1.Document(this.dom);
		        this.done = false;
		        this.tagStack = [this.root];
		        this.lastNode = null;
		        this.parser = null;
		    };
		    // Signals the handler that parsing is done
		    DomHandler.prototype.onend = function () {
		        if (this.done)
		            return;
		        this.done = true;
		        this.parser = null;
		        this.handleCallback(null);
		    };
		    DomHandler.prototype.onerror = function (error) {
		        this.handleCallback(error);
		    };
		    DomHandler.prototype.onclosetag = function () {
		        this.lastNode = null;
		        var elem = this.tagStack.pop();
		        if (this.options.withEndIndices) {
		            elem.endIndex = this.parser.endIndex;
		        }
		        if (this.elementCB)
		            this.elementCB(elem);
		    };
		    DomHandler.prototype.onopentag = function (name, attribs) {
		        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
		        var element = new node_1.Element(name, attribs, undefined, type);
		        this.addNode(element);
		        this.tagStack.push(element);
		    };
		    DomHandler.prototype.ontext = function (data) {
		        var normalizeWhitespace = this.options.normalizeWhitespace;
		        var lastNode = this.lastNode;
		        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
		            if (normalizeWhitespace) {
		                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
		            }
		            else {
		                lastNode.data += data;
		            }
		            if (this.options.withEndIndices) {
		                lastNode.endIndex = this.parser.endIndex;
		            }
		        }
		        else {
		            if (normalizeWhitespace) {
		                data = data.replace(reWhitespace, " ");
		            }
		            var node = new node_1.Text(data);
		            this.addNode(node);
		            this.lastNode = node;
		        }
		    };
		    DomHandler.prototype.oncomment = function (data) {
		        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
		            this.lastNode.data += data;
		            return;
		        }
		        var node = new node_1.Comment(data);
		        this.addNode(node);
		        this.lastNode = node;
		    };
		    DomHandler.prototype.oncommentend = function () {
		        this.lastNode = null;
		    };
		    DomHandler.prototype.oncdatastart = function () {
		        var text = new node_1.Text("");
		        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
		        this.addNode(node);
		        text.parent = node;
		        this.lastNode = text;
		    };
		    DomHandler.prototype.oncdataend = function () {
		        this.lastNode = null;
		    };
		    DomHandler.prototype.onprocessinginstruction = function (name, data) {
		        var node = new node_1.ProcessingInstruction(name, data);
		        this.addNode(node);
		    };
		    DomHandler.prototype.handleCallback = function (error) {
		        if (typeof this.callback === "function") {
		            this.callback(error, this.dom);
		        }
		        else if (error) {
		            throw error;
		        }
		    };
		    DomHandler.prototype.addNode = function (node) {
		        var parent = this.tagStack[this.tagStack.length - 1];
		        var previousSibling = parent.children[parent.children.length - 1];
		        if (this.options.withStartIndices) {
		            node.startIndex = this.parser.startIndex;
		        }
		        if (this.options.withEndIndices) {
		            node.endIndex = this.parser.endIndex;
		        }
		        parent.children.push(node);
		        if (previousSibling) {
		            node.prev = previousSibling;
		            previousSibling.next = node;
		        }
		        node.parent = parent;
		        this.lastNode = null;
		    };
		    return DomHandler;
		}());
		exports.DomHandler = DomHandler;
		exports.default = DomHandler; 
	} (lib$6));
	return lib$6;
}

var lib$4 = {};

var lib$3 = {};

var decode = {};

const Aacute$1 = "Ã";
const aacute$1 = "Ã¡";
const Abreve = "Ä‚";
const abreve = "Äƒ";
const ac = "âˆ¾";
const acd = "âˆ¿";
const acE = "âˆ¾Ì³";
const Acirc$1 = "Ã‚";
const acirc$1 = "Ã¢";
const acute$1 = "Â´";
const Acy = "Ğ";
const acy = "Ğ°";
const AElig$1 = "Ã†";
const aelig$1 = "Ã¦";
const af = "â¡";
const Afr = "ğ”„";
const afr = "ğ”";
const Agrave$1 = "Ã€";
const agrave$1 = "Ã ";
const alefsym = "â„µ";
const aleph = "â„µ";
const Alpha = "Î‘";
const alpha = "Î±";
const Amacr = "Ä€";
const amacr = "Ä";
const amalg = "â¨¿";
const amp$2 = "&";
const AMP$1 = "&";
const andand = "â©•";
const And = "â©“";
const and = "âˆ§";
const andd = "â©œ";
const andslope = "â©˜";
const andv = "â©š";
const ang = "âˆ ";
const ange = "â¦¤";
const angle = "âˆ ";
const angmsdaa = "â¦¨";
const angmsdab = "â¦©";
const angmsdac = "â¦ª";
const angmsdad = "â¦«";
const angmsdae = "â¦¬";
const angmsdaf = "â¦­";
const angmsdag = "â¦®";
const angmsdah = "â¦¯";
const angmsd = "âˆ¡";
const angrt = "âˆŸ";
const angrtvb = "âŠ¾";
const angrtvbd = "â¦";
const angsph = "âˆ¢";
const angst = "Ã…";
const angzarr = "â¼";
const Aogon = "Ä„";
const aogon = "Ä…";
const Aopf = "ğ”¸";
const aopf = "ğ•’";
const apacir = "â©¯";
const ap = "â‰ˆ";
const apE = "â©°";
const ape = "â‰Š";
const apid = "â‰‹";
const apos$1 = "'";
const ApplyFunction = "â¡";
const approx = "â‰ˆ";
const approxeq = "â‰Š";
const Aring$1 = "Ã…";
const aring$1 = "Ã¥";
const Ascr = "ğ’œ";
const ascr = "ğ’¶";
const Assign = "â‰”";
const ast = "*";
const asymp = "â‰ˆ";
const asympeq = "â‰";
const Atilde$1 = "Ãƒ";
const atilde$1 = "Ã£";
const Auml$1 = "Ã„";
const auml$1 = "Ã¤";
const awconint = "âˆ³";
const awint = "â¨‘";
const backcong = "â‰Œ";
const backepsilon = "Ï¶";
const backprime = "â€µ";
const backsim = "âˆ½";
const backsimeq = "â‹";
const Backslash = "âˆ–";
const Barv = "â«§";
const barvee = "âŠ½";
const barwed = "âŒ…";
const Barwed = "âŒ†";
const barwedge = "âŒ…";
const bbrk = "âµ";
const bbrktbrk = "â¶";
const bcong = "â‰Œ";
const Bcy = "Ğ‘";
const bcy = "Ğ±";
const bdquo = "â€";
const becaus = "âˆµ";
const because = "âˆµ";
const Because = "âˆµ";
const bemptyv = "â¦°";
const bepsi = "Ï¶";
const bernou = "â„¬";
const Bernoullis = "â„¬";
const Beta = "Î’";
const beta = "Î²";
const beth = "â„¶";
const between = "â‰¬";
const Bfr = "ğ”…";
const bfr = "ğ”Ÿ";
const bigcap = "â‹‚";
const bigcirc = "â—¯";
const bigcup = "â‹ƒ";
const bigodot = "â¨€";
const bigoplus = "â¨";
const bigotimes = "â¨‚";
const bigsqcup = "â¨†";
const bigstar = "â˜…";
const bigtriangledown = "â–½";
const bigtriangleup = "â–³";
const biguplus = "â¨„";
const bigvee = "â‹";
const bigwedge = "â‹€";
const bkarow = "â¤";
const blacklozenge = "â§«";
const blacksquare = "â–ª";
const blacktriangle = "â–´";
const blacktriangledown = "â–¾";
const blacktriangleleft = "â—‚";
const blacktriangleright = "â–¸";
const blank = "â£";
const blk12 = "â–’";
const blk14 = "â–‘";
const blk34 = "â–“";
const block = "â–ˆ";
const bne = "=âƒ¥";
const bnequiv = "â‰¡âƒ¥";
const bNot = "â«­";
const bnot = "âŒ";
const Bopf = "ğ”¹";
const bopf = "ğ•“";
const bot = "âŠ¥";
const bottom$1 = "âŠ¥";
const bowtie = "â‹ˆ";
const boxbox = "â§‰";
const boxdl = "â”";
const boxdL = "â••";
const boxDl = "â•–";
const boxDL = "â•—";
const boxdr = "â”Œ";
const boxdR = "â•’";
const boxDr = "â•“";
const boxDR = "â•”";
const boxh = "â”€";
const boxH = "â•";
const boxhd = "â”¬";
const boxHd = "â•¤";
const boxhD = "â•¥";
const boxHD = "â•¦";
const boxhu = "â”´";
const boxHu = "â•§";
const boxhU = "â•¨";
const boxHU = "â•©";
const boxminus = "âŠŸ";
const boxplus = "âŠ";
const boxtimes = "âŠ ";
const boxul = "â”˜";
const boxuL = "â•›";
const boxUl = "â•œ";
const boxUL = "â•";
const boxur = "â””";
const boxuR = "â•˜";
const boxUr = "â•™";
const boxUR = "â•š";
const boxv = "â”‚";
const boxV = "â•‘";
const boxvh = "â”¼";
const boxvH = "â•ª";
const boxVh = "â•«";
const boxVH = "â•¬";
const boxvl = "â”¤";
const boxvL = "â•¡";
const boxVl = "â•¢";
const boxVL = "â•£";
const boxvr = "â”œ";
const boxvR = "â•";
const boxVr = "â•Ÿ";
const boxVR = "â• ";
const bprime = "â€µ";
const breve = "Ë˜";
const Breve = "Ë˜";
const brvbar$1 = "Â¦";
const bscr = "ğ’·";
const Bscr = "â„¬";
const bsemi = "â";
const bsim = "âˆ½";
const bsime = "â‹";
const bsolb = "â§…";
const bsol = "\\";
const bsolhsub = "âŸˆ";
const bull = "â€¢";
const bullet = "â€¢";
const bump = "â‰";
const bumpE = "âª®";
const bumpe = "â‰";
const Bumpeq = "â‰";
const bumpeq = "â‰";
const Cacute = "Ä†";
const cacute = "Ä‡";
const capand = "â©„";
const capbrcup = "â©‰";
const capcap = "â©‹";
const cap = "âˆ©";
const Cap = "â‹’";
const capcup = "â©‡";
const capdot = "â©€";
const CapitalDifferentialD = "â……";
const caps = "âˆ©ï¸€";
const caret = "â";
const caron = "Ë‡";
const Cayleys = "â„­";
const ccaps = "â©";
const Ccaron = "ÄŒ";
const ccaron = "Ä";
const Ccedil$1 = "Ã‡";
const ccedil$1 = "Ã§";
const Ccirc = "Äˆ";
const ccirc = "Ä‰";
const Cconint = "âˆ°";
const ccups = "â©Œ";
const ccupssm = "â©";
const Cdot = "ÄŠ";
const cdot = "Ä‹";
const cedil$1 = "Â¸";
const Cedilla = "Â¸";
const cemptyv = "â¦²";
const cent$1 = "Â¢";
const centerdot = "Â·";
const CenterDot = "Â·";
const cfr = "ğ” ";
const Cfr = "â„­";
const CHcy = "Ğ§";
const chcy = "Ñ‡";
const check = "âœ“";
const checkmark = "âœ“";
const Chi = "Î§";
const chi = "Ï‡";
const circ = "Ë†";
const circeq = "â‰—";
const circlearrowleft = "â†º";
const circlearrowright = "â†»";
const circledast = "âŠ›";
const circledcirc = "âŠš";
const circleddash = "âŠ";
const CircleDot = "âŠ™";
const circledR = "Â®";
const circledS = "â“ˆ";
const CircleMinus = "âŠ–";
const CirclePlus = "âŠ•";
const CircleTimes = "âŠ—";
const cir = "â—‹";
const cirE = "â§ƒ";
const cire = "â‰—";
const cirfnint = "â¨";
const cirmid = "â«¯";
const cirscir = "â§‚";
const ClockwiseContourIntegral = "âˆ²";
const CloseCurlyDoubleQuote = "â€";
const CloseCurlyQuote = "â€™";
const clubs = "â™£";
const clubsuit = "â™£";
const colon = ":";
const Colon = "âˆ·";
const Colone = "â©´";
const colone = "â‰”";
const coloneq = "â‰”";
const comma = ",";
const commat = "@";
const comp = "âˆ";
const compfn = "âˆ˜";
const complement = "âˆ";
const complexes = "â„‚";
const cong = "â‰…";
const congdot = "â©­";
const Congruent = "â‰¡";
const conint = "âˆ®";
const Conint = "âˆ¯";
const ContourIntegral = "âˆ®";
const copf = "ğ•”";
const Copf = "â„‚";
const coprod = "âˆ";
const Coproduct = "âˆ";
const copy$1 = "Â©";
const COPY$1 = "Â©";
const copysr = "â„—";
const CounterClockwiseContourIntegral = "âˆ³";
const crarr = "â†µ";
const cross = "âœ—";
const Cross = "â¨¯";
const Cscr = "ğ’";
const cscr = "ğ’¸";
const csub = "â«";
const csube = "â«‘";
const csup = "â«";
const csupe = "â«’";
const ctdot = "â‹¯";
const cudarrl = "â¤¸";
const cudarrr = "â¤µ";
const cuepr = "â‹";
const cuesc = "â‹Ÿ";
const cularr = "â†¶";
const cularrp = "â¤½";
const cupbrcap = "â©ˆ";
const cupcap = "â©†";
const CupCap = "â‰";
const cup = "âˆª";
const Cup = "â‹“";
const cupcup = "â©Š";
const cupdot = "âŠ";
const cupor = "â©…";
const cups = "âˆªï¸€";
const curarr = "â†·";
const curarrm = "â¤¼";
const curlyeqprec = "â‹";
const curlyeqsucc = "â‹Ÿ";
const curlyvee = "â‹";
const curlywedge = "â‹";
const curren$1 = "Â¤";
const curvearrowleft = "â†¶";
const curvearrowright = "â†·";
const cuvee = "â‹";
const cuwed = "â‹";
const cwconint = "âˆ²";
const cwint = "âˆ±";
const cylcty = "âŒ­";
const dagger = "â€ ";
const Dagger = "â€¡";
const daleth = "â„¸";
const darr = "â†“";
const Darr = "â†¡";
const dArr = "â‡“";
const dash = "â€";
const Dashv = "â«¤";
const dashv = "âŠ£";
const dbkarow = "â¤";
const dblac = "Ë";
const Dcaron = "Ä";
const dcaron = "Ä";
const Dcy = "Ğ”";
const dcy = "Ğ´";
const ddagger = "â€¡";
const ddarr = "â‡Š";
const DD = "â……";
const dd = "â…†";
const DDotrahd = "â¤‘";
const ddotseq = "â©·";
const deg$1 = "Â°";
const Del = "âˆ‡";
const Delta = "Î”";
const delta = "Î´";
const demptyv = "â¦±";
const dfisht = "â¥¿";
const Dfr = "ğ”‡";
const dfr = "ğ”¡";
const dHar = "â¥¥";
const dharl = "â‡ƒ";
const dharr = "â‡‚";
const DiacriticalAcute = "Â´";
const DiacriticalDot = "Ë™";
const DiacriticalDoubleAcute = "Ë";
const DiacriticalGrave = "`";
const DiacriticalTilde = "Ëœ";
const diam = "â‹„";
const diamond = "â‹„";
const Diamond = "â‹„";
const diamondsuit = "â™¦";
const diams = "â™¦";
const die = "Â¨";
const DifferentialD = "â…†";
const digamma = "Ï";
const disin = "â‹²";
const div = "Ã·";
const divide$1 = "Ã·";
const divideontimes = "â‹‡";
const divonx = "â‹‡";
const DJcy = "Ğ‚";
const djcy = "Ñ’";
const dlcorn = "âŒ";
const dlcrop = "âŒ";
const dollar = "$";
const Dopf = "ğ”»";
const dopf = "ğ••";
const Dot = "Â¨";
const dot = "Ë™";
const DotDot = "âƒœ";
const doteq = "â‰";
const doteqdot = "â‰‘";
const DotEqual = "â‰";
const dotminus = "âˆ¸";
const dotplus = "âˆ”";
const dotsquare = "âŠ¡";
const doublebarwedge = "âŒ†";
const DoubleContourIntegral = "âˆ¯";
const DoubleDot = "Â¨";
const DoubleDownArrow = "â‡“";
const DoubleLeftArrow = "â‡";
const DoubleLeftRightArrow = "â‡”";
const DoubleLeftTee = "â«¤";
const DoubleLongLeftArrow = "âŸ¸";
const DoubleLongLeftRightArrow = "âŸº";
const DoubleLongRightArrow = "âŸ¹";
const DoubleRightArrow = "â‡’";
const DoubleRightTee = "âŠ¨";
const DoubleUpArrow = "â‡‘";
const DoubleUpDownArrow = "â‡•";
const DoubleVerticalBar = "âˆ¥";
const DownArrowBar = "â¤“";
const downarrow = "â†“";
const DownArrow = "â†“";
const Downarrow = "â‡“";
const DownArrowUpArrow = "â‡µ";
const DownBreve = "Ì‘";
const downdownarrows = "â‡Š";
const downharpoonleft = "â‡ƒ";
const downharpoonright = "â‡‚";
const DownLeftRightVector = "â¥";
const DownLeftTeeVector = "â¥";
const DownLeftVectorBar = "â¥–";
const DownLeftVector = "â†½";
const DownRightTeeVector = "â¥Ÿ";
const DownRightVectorBar = "â¥—";
const DownRightVector = "â‡";
const DownTeeArrow = "â†§";
const DownTee = "âŠ¤";
const drbkarow = "â¤";
const drcorn = "âŒŸ";
const drcrop = "âŒŒ";
const Dscr = "ğ’Ÿ";
const dscr = "ğ’¹";
const DScy = "Ğ…";
const dscy = "Ñ•";
const dsol = "â§¶";
const Dstrok = "Ä";
const dstrok = "Ä‘";
const dtdot = "â‹±";
const dtri = "â–¿";
const dtrif = "â–¾";
const duarr = "â‡µ";
const duhar = "â¥¯";
const dwangle = "â¦¦";
const DZcy = "Ğ";
const dzcy = "ÑŸ";
const dzigrarr = "âŸ¿";
const Eacute$1 = "Ã‰";
const eacute$1 = "Ã©";
const easter = "â©®";
const Ecaron = "Äš";
const ecaron = "Ä›";
const Ecirc$1 = "ÃŠ";
const ecirc$1 = "Ãª";
const ecir = "â‰–";
const ecolon = "â‰•";
const Ecy = "Ğ­";
const ecy = "Ñ";
const eDDot = "â©·";
const Edot = "Ä–";
const edot = "Ä—";
const eDot = "â‰‘";
const ee = "â…‡";
const efDot = "â‰’";
const Efr = "ğ”ˆ";
const efr = "ğ”¢";
const eg = "âªš";
const Egrave$1 = "Ãˆ";
const egrave$1 = "Ã¨";
const egs = "âª–";
const egsdot = "âª˜";
const el = "âª™";
const Element = "âˆˆ";
const elinters = "â§";
const ell = "â„“";
const els = "âª•";
const elsdot = "âª—";
const Emacr = "Ä’";
const emacr = "Ä“";
const empty = "âˆ…";
const emptyset = "âˆ…";
const EmptySmallSquare = "â—»";
const emptyv = "âˆ…";
const EmptyVerySmallSquare = "â–«";
const emsp13 = "â€„";
const emsp14 = "â€…";
const emsp = "â€ƒ";
const ENG = "ÅŠ";
const eng = "Å‹";
const ensp = "â€‚";
const Eogon = "Ä˜";
const eogon = "Ä™";
const Eopf = "ğ”¼";
const eopf = "ğ•–";
const epar = "â‹•";
const eparsl = "â§£";
const eplus = "â©±";
const epsi = "Îµ";
const Epsilon = "Î•";
const epsilon = "Îµ";
const epsiv = "Ïµ";
const eqcirc = "â‰–";
const eqcolon = "â‰•";
const eqsim = "â‰‚";
const eqslantgtr = "âª–";
const eqslantless = "âª•";
const Equal = "â©µ";
const equals = "=";
const EqualTilde = "â‰‚";
const equest = "â‰Ÿ";
const Equilibrium = "â‡Œ";
const equiv = "â‰¡";
const equivDD = "â©¸";
const eqvparsl = "â§¥";
const erarr = "â¥±";
const erDot = "â‰“";
const escr = "â„¯";
const Escr = "â„°";
const esdot = "â‰";
const Esim = "â©³";
const esim = "â‰‚";
const Eta = "Î—";
const eta = "Î·";
const ETH$1 = "Ã";
const eth$1 = "Ã°";
const Euml$1 = "Ã‹";
const euml$1 = "Ã«";
const euro = "â‚¬";
const excl = "!";
const exist = "âˆƒ";
const Exists = "âˆƒ";
const expectation = "â„°";
const exponentiale = "â…‡";
const ExponentialE = "â…‡";
const fallingdotseq = "â‰’";
const Fcy = "Ğ¤";
const fcy = "Ñ„";
const female = "â™€";
const ffilig = "ï¬ƒ";
const fflig = "ï¬€";
const ffllig = "ï¬„";
const Ffr = "ğ”‰";
const ffr = "ğ”£";
const filig = "ï¬";
const FilledSmallSquare = "â—¼";
const FilledVerySmallSquare = "â–ª";
const fjlig = "fj";
const flat = "â™­";
const fllig = "ï¬‚";
const fltns = "â–±";
const fnof = "Æ’";
const Fopf = "ğ”½";
const fopf = "ğ•—";
const forall = "âˆ€";
const ForAll = "âˆ€";
const fork = "â‹”";
const forkv = "â«™";
const Fouriertrf = "â„±";
const fpartint = "â¨";
const frac12$1 = "Â½";
const frac13 = "â…“";
const frac14$1 = "Â¼";
const frac15 = "â…•";
const frac16 = "â…™";
const frac18 = "â…›";
const frac23 = "â…”";
const frac25 = "â…–";
const frac34$1 = "Â¾";
const frac35 = "â…—";
const frac38 = "â…œ";
const frac45 = "â…˜";
const frac56 = "â…š";
const frac58 = "â…";
const frac78 = "â…";
const frasl = "â„";
const frown = "âŒ¢";
const fscr = "ğ’»";
const Fscr = "â„±";
const gacute = "Çµ";
const Gamma = "Î“";
const gamma = "Î³";
const Gammad = "Ïœ";
const gammad = "Ï";
const gap$1 = "âª†";
const Gbreve = "Ä";
const gbreve = "ÄŸ";
const Gcedil = "Ä¢";
const Gcirc = "Äœ";
const gcirc = "Ä";
const Gcy = "Ğ“";
const gcy = "Ğ³";
const Gdot = "Ä ";
const gdot = "Ä¡";
const ge = "â‰¥";
const gE = "â‰§";
const gEl = "âªŒ";
const gel = "â‹›";
const geq = "â‰¥";
const geqq = "â‰§";
const geqslant = "â©¾";
const gescc = "âª©";
const ges = "â©¾";
const gesdot = "âª€";
const gesdoto = "âª‚";
const gesdotol = "âª„";
const gesl = "â‹›ï¸€";
const gesles = "âª”";
const Gfr = "ğ”Š";
const gfr = "ğ”¤";
const gg = "â‰«";
const Gg = "â‹™";
const ggg = "â‹™";
const gimel = "â„·";
const GJcy = "Ğƒ";
const gjcy = "Ñ“";
const gla = "âª¥";
const gl = "â‰·";
const glE = "âª’";
const glj = "âª¤";
const gnap = "âªŠ";
const gnapprox = "âªŠ";
const gne = "âªˆ";
const gnE = "â‰©";
const gneq = "âªˆ";
const gneqq = "â‰©";
const gnsim = "â‹§";
const Gopf = "ğ”¾";
const gopf = "ğ•˜";
const grave = "`";
const GreaterEqual = "â‰¥";
const GreaterEqualLess = "â‹›";
const GreaterFullEqual = "â‰§";
const GreaterGreater = "âª¢";
const GreaterLess = "â‰·";
const GreaterSlantEqual = "â©¾";
const GreaterTilde = "â‰³";
const Gscr = "ğ’¢";
const gscr = "â„Š";
const gsim = "â‰³";
const gsime = "âª";
const gsiml = "âª";
const gtcc = "âª§";
const gtcir = "â©º";
const gt$2 = ">";
const GT$1 = ">";
const Gt = "â‰«";
const gtdot = "â‹—";
const gtlPar = "â¦•";
const gtquest = "â©¼";
const gtrapprox = "âª†";
const gtrarr = "â¥¸";
const gtrdot = "â‹—";
const gtreqless = "â‹›";
const gtreqqless = "âªŒ";
const gtrless = "â‰·";
const gtrsim = "â‰³";
const gvertneqq = "â‰©ï¸€";
const gvnE = "â‰©ï¸€";
const Hacek = "Ë‡";
const hairsp = "â€Š";
const half = "Â½";
const hamilt = "â„‹";
const HARDcy = "Ğª";
const hardcy = "ÑŠ";
const harrcir = "â¥ˆ";
const harr = "â†”";
const hArr = "â‡”";
const harrw = "â†­";
const Hat = "^";
const hbar = "â„";
const Hcirc = "Ä¤";
const hcirc = "Ä¥";
const hearts = "â™¥";
const heartsuit = "â™¥";
const hellip = "â€¦";
const hercon = "âŠ¹";
const hfr = "ğ”¥";
const Hfr = "â„Œ";
const HilbertSpace = "â„‹";
const hksearow = "â¤¥";
const hkswarow = "â¤¦";
const hoarr = "â‡¿";
const homtht = "âˆ»";
const hookleftarrow = "â†©";
const hookrightarrow = "â†ª";
const hopf = "ğ•™";
const Hopf = "â„";
const horbar = "â€•";
const HorizontalLine = "â”€";
const hscr = "ğ’½";
const Hscr = "â„‹";
const hslash = "â„";
const Hstrok = "Ä¦";
const hstrok = "Ä§";
const HumpDownHump = "â‰";
const HumpEqual = "â‰";
const hybull = "âƒ";
const hyphen = "â€";
const Iacute$1 = "Ã";
const iacute$1 = "Ã­";
const ic = "â£";
const Icirc$1 = "Ã";
const icirc$1 = "Ã®";
const Icy = "Ğ˜";
const icy = "Ğ¸";
const Idot = "Ä°";
const IEcy = "Ğ•";
const iecy = "Ğµ";
const iexcl$1 = "Â¡";
const iff = "â‡”";
const ifr = "ğ”¦";
const Ifr = "â„‘";
const Igrave$1 = "ÃŒ";
const igrave$1 = "Ã¬";
const ii = "â…ˆ";
const iiiint = "â¨Œ";
const iiint = "âˆ­";
const iinfin = "â§œ";
const iiota = "â„©";
const IJlig = "Ä²";
const ijlig = "Ä³";
const Imacr = "Äª";
const imacr = "Ä«";
const image$1 = "â„‘";
const ImaginaryI = "â…ˆ";
const imagline = "â„";
const imagpart = "â„‘";
const imath = "Ä±";
const Im = "â„‘";
const imof = "âŠ·";
const imped = "Æµ";
const Implies = "â‡’";
const incare = "â„…";
const infin = "âˆ";
const infintie = "â§";
const inodot = "Ä±";
const intcal = "âŠº";
const int = "âˆ«";
const Int = "âˆ¬";
const integers = "â„¤";
const Integral = "âˆ«";
const intercal = "âŠº";
const Intersection = "â‹‚";
const intlarhk = "â¨—";
const intprod = "â¨¼";
const InvisibleComma = "â£";
const InvisibleTimes = "â¢";
const IOcy = "Ğ";
const iocy = "Ñ‘";
const Iogon = "Ä®";
const iogon = "Ä¯";
const Iopf = "ğ•€";
const iopf = "ğ•š";
const Iota = "Î™";
const iota = "Î¹";
const iprod = "â¨¼";
const iquest$1 = "Â¿";
const iscr = "ğ’¾";
const Iscr = "â„";
const isin = "âˆˆ";
const isindot = "â‹µ";
const isinE = "â‹¹";
const isins = "â‹´";
const isinsv = "â‹³";
const isinv = "âˆˆ";
const it = "â¢";
const Itilde = "Ä¨";
const itilde = "Ä©";
const Iukcy = "Ğ†";
const iukcy = "Ñ–";
const Iuml$1 = "Ã";
const iuml$1 = "Ã¯";
const Jcirc = "Ä´";
const jcirc = "Äµ";
const Jcy = "Ğ™";
const jcy = "Ğ¹";
const Jfr = "ğ”";
const jfr = "ğ”§";
const jmath = "È·";
const Jopf = "ğ•";
const jopf = "ğ•›";
const Jscr = "ğ’¥";
const jscr = "ğ’¿";
const Jsercy = "Ğˆ";
const jsercy = "Ñ˜";
const Jukcy = "Ğ„";
const jukcy = "Ñ”";
const Kappa = "Îš";
const kappa = "Îº";
const kappav = "Ï°";
const Kcedil = "Ä¶";
const kcedil = "Ä·";
const Kcy = "Ğš";
const kcy = "Ğº";
const Kfr = "ğ”";
const kfr = "ğ”¨";
const kgreen = "Ä¸";
const KHcy = "Ğ¥";
const khcy = "Ñ…";
const KJcy = "ĞŒ";
const kjcy = "Ñœ";
const Kopf = "ğ•‚";
const kopf = "ğ•œ";
const Kscr = "ğ’¦";
const kscr = "ğ“€";
const lAarr = "â‡š";
const Lacute = "Ä¹";
const lacute = "Äº";
const laemptyv = "â¦´";
const lagran = "â„’";
const Lambda = "Î›";
const lambda = "Î»";
const lang$1 = "âŸ¨";
const Lang = "âŸª";
const langd = "â¦‘";
const langle = "âŸ¨";
const lap = "âª…";
const Laplacetrf = "â„’";
const laquo$1 = "Â«";
const larrb = "â‡¤";
const larrbfs = "â¤Ÿ";
const larr = "â†";
const Larr = "â†";
const lArr = "â‡";
const larrfs = "â¤";
const larrhk = "â†©";
const larrlp = "â†«";
const larrpl = "â¤¹";
const larrsim = "â¥³";
const larrtl = "â†¢";
const latail = "â¤™";
const lAtail = "â¤›";
const lat = "âª«";
const late = "âª­";
const lates = "âª­ï¸€";
const lbarr = "â¤Œ";
const lBarr = "â¤";
const lbbrk = "â²";
const lbrace = "{";
const lbrack = "[";
const lbrke = "â¦‹";
const lbrksld = "â¦";
const lbrkslu = "â¦";
const Lcaron = "Ä½";
const lcaron = "Ä¾";
const Lcedil = "Ä»";
const lcedil = "Ä¼";
const lceil = "âŒˆ";
const lcub = "{";
const Lcy = "Ğ›";
const lcy = "Ğ»";
const ldca = "â¤¶";
const ldquo = "â€œ";
const ldquor = "â€";
const ldrdhar = "â¥§";
const ldrushar = "â¥‹";
const ldsh = "â†²";
const le = "â‰¤";
const lE = "â‰¦";
const LeftAngleBracket = "âŸ¨";
const LeftArrowBar = "â‡¤";
const leftarrow = "â†";
const LeftArrow = "â†";
const Leftarrow = "â‡";
const LeftArrowRightArrow = "â‡†";
const leftarrowtail = "â†¢";
const LeftCeiling = "âŒˆ";
const LeftDoubleBracket = "âŸ¦";
const LeftDownTeeVector = "â¥¡";
const LeftDownVectorBar = "â¥™";
const LeftDownVector = "â‡ƒ";
const LeftFloor = "âŒŠ";
const leftharpoondown = "â†½";
const leftharpoonup = "â†¼";
const leftleftarrows = "â‡‡";
const leftrightarrow = "â†”";
const LeftRightArrow = "â†”";
const Leftrightarrow = "â‡”";
const leftrightarrows = "â‡†";
const leftrightharpoons = "â‡‹";
const leftrightsquigarrow = "â†­";
const LeftRightVector = "â¥";
const LeftTeeArrow = "â†¤";
const LeftTee = "âŠ£";
const LeftTeeVector = "â¥š";
const leftthreetimes = "â‹‹";
const LeftTriangleBar = "â§";
const LeftTriangle = "âŠ²";
const LeftTriangleEqual = "âŠ´";
const LeftUpDownVector = "â¥‘";
const LeftUpTeeVector = "â¥ ";
const LeftUpVectorBar = "â¥˜";
const LeftUpVector = "â†¿";
const LeftVectorBar = "â¥’";
const LeftVector = "â†¼";
const lEg = "âª‹";
const leg = "â‹š";
const leq = "â‰¤";
const leqq = "â‰¦";
const leqslant = "â©½";
const lescc = "âª¨";
const les = "â©½";
const lesdot = "â©¿";
const lesdoto = "âª";
const lesdotor = "âªƒ";
const lesg = "â‹šï¸€";
const lesges = "âª“";
const lessapprox = "âª…";
const lessdot = "â‹–";
const lesseqgtr = "â‹š";
const lesseqqgtr = "âª‹";
const LessEqualGreater = "â‹š";
const LessFullEqual = "â‰¦";
const LessGreater = "â‰¶";
const lessgtr = "â‰¶";
const LessLess = "âª¡";
const lesssim = "â‰²";
const LessSlantEqual = "â©½";
const LessTilde = "â‰²";
const lfisht = "â¥¼";
const lfloor = "âŒŠ";
const Lfr = "ğ”";
const lfr = "ğ”©";
const lg = "â‰¶";
const lgE = "âª‘";
const lHar = "â¥¢";
const lhard = "â†½";
const lharu = "â†¼";
const lharul = "â¥ª";
const lhblk = "â–„";
const LJcy = "Ğ‰";
const ljcy = "Ñ™";
const llarr = "â‡‡";
const ll = "â‰ª";
const Ll = "â‹˜";
const llcorner = "âŒ";
const Lleftarrow = "â‡š";
const llhard = "â¥«";
const lltri = "â—º";
const Lmidot = "Ä¿";
const lmidot = "Å€";
const lmoustache = "â°";
const lmoust = "â°";
const lnap = "âª‰";
const lnapprox = "âª‰";
const lne = "âª‡";
const lnE = "â‰¨";
const lneq = "âª‡";
const lneqq = "â‰¨";
const lnsim = "â‹¦";
const loang = "âŸ¬";
const loarr = "â‡½";
const lobrk = "âŸ¦";
const longleftarrow = "âŸµ";
const LongLeftArrow = "âŸµ";
const Longleftarrow = "âŸ¸";
const longleftrightarrow = "âŸ·";
const LongLeftRightArrow = "âŸ·";
const Longleftrightarrow = "âŸº";
const longmapsto = "âŸ¼";
const longrightarrow = "âŸ¶";
const LongRightArrow = "âŸ¶";
const Longrightarrow = "âŸ¹";
const looparrowleft = "â†«";
const looparrowright = "â†¬";
const lopar = "â¦…";
const Lopf = "ğ•ƒ";
const lopf = "ğ•";
const loplus = "â¨­";
const lotimes = "â¨´";
const lowast = "âˆ—";
const lowbar = "_";
const LowerLeftArrow = "â†™";
const LowerRightArrow = "â†˜";
const loz = "â—Š";
const lozenge = "â—Š";
const lozf = "â§«";
const lpar = "(";
const lparlt = "â¦“";
const lrarr = "â‡†";
const lrcorner = "âŒŸ";
const lrhar = "â‡‹";
const lrhard = "â¥­";
const lrm = "â€";
const lrtri = "âŠ¿";
const lsaquo = "â€¹";
const lscr = "ğ“";
const Lscr = "â„’";
const lsh = "â†°";
const Lsh = "â†°";
const lsim = "â‰²";
const lsime = "âª";
const lsimg = "âª";
const lsqb = "[";
const lsquo = "â€˜";
const lsquor = "â€š";
const Lstrok = "Å";
const lstrok = "Å‚";
const ltcc = "âª¦";
const ltcir = "â©¹";
const lt$2 = "<";
const LT$1 = "<";
const Lt = "â‰ª";
const ltdot = "â‹–";
const lthree = "â‹‹";
const ltimes = "â‹‰";
const ltlarr = "â¥¶";
const ltquest = "â©»";
const ltri = "â—ƒ";
const ltrie = "âŠ´";
const ltrif = "â—‚";
const ltrPar = "â¦–";
const lurdshar = "â¥Š";
const luruhar = "â¥¦";
const lvertneqq = "â‰¨ï¸€";
const lvnE = "â‰¨ï¸€";
const macr$1 = "Â¯";
const male = "â™‚";
const malt = "âœ ";
const maltese = "âœ ";
const map = "â†¦";
const mapsto = "â†¦";
const mapstodown = "â†§";
const mapstoleft = "â†¤";
const mapstoup = "â†¥";
const marker = "â–®";
const mcomma = "â¨©";
const Mcy = "Ğœ";
const mcy = "Ğ¼";
const mdash = "â€”";
const mDDot = "âˆº";
const measuredangle = "âˆ¡";
const MediumSpace = "âŸ";
const Mellintrf = "â„³";
const Mfr = "ğ”";
const mfr = "ğ”ª";
const mho = "â„§";
const micro$1 = "Âµ";
const midast = "*";
const midcir = "â«°";
const mid = "âˆ£";
const middot$1 = "Â·";
const minusb = "âŠŸ";
const minus = "âˆ’";
const minusd = "âˆ¸";
const minusdu = "â¨ª";
const MinusPlus = "âˆ“";
const mlcp = "â«›";
const mldr = "â€¦";
const mnplus = "âˆ“";
const models = "âŠ§";
const Mopf = "ğ•„";
const mopf = "ğ•";
const mp = "âˆ“";
const mscr = "ğ“‚";
const Mscr = "â„³";
const mstpos = "âˆ¾";
const Mu = "Îœ";
const mu = "Î¼";
const multimap = "âŠ¸";
const mumap = "âŠ¸";
const nabla = "âˆ‡";
const Nacute = "Åƒ";
const nacute = "Å„";
const nang = "âˆ âƒ’";
const nap = "â‰‰";
const napE = "â©°Ì¸";
const napid = "â‰‹Ì¸";
const napos = "Å‰";
const napprox = "â‰‰";
const natural = "â™®";
const naturals = "â„•";
const natur = "â™®";
const nbsp$1 = "Â ";
const nbump = "â‰Ì¸";
const nbumpe = "â‰Ì¸";
const ncap = "â©ƒ";
const Ncaron = "Å‡";
const ncaron = "Åˆ";
const Ncedil = "Å…";
const ncedil = "Å†";
const ncong = "â‰‡";
const ncongdot = "â©­Ì¸";
const ncup = "â©‚";
const Ncy = "Ğ";
const ncy = "Ğ½";
const ndash = "â€“";
const nearhk = "â¤¤";
const nearr = "â†—";
const neArr = "â‡—";
const nearrow = "â†—";
const ne = "â‰ ";
const nedot = "â‰Ì¸";
const NegativeMediumSpace = "â€‹";
const NegativeThickSpace = "â€‹";
const NegativeThinSpace = "â€‹";
const NegativeVeryThinSpace = "â€‹";
const nequiv = "â‰¢";
const nesear = "â¤¨";
const nesim = "â‰‚Ì¸";
const NestedGreaterGreater = "â‰«";
const NestedLessLess = "â‰ª";
const NewLine = "\n";
const nexist = "âˆ„";
const nexists = "âˆ„";
const Nfr = "ğ”‘";
const nfr = "ğ”«";
const ngE = "â‰§Ì¸";
const nge = "â‰±";
const ngeq = "â‰±";
const ngeqq = "â‰§Ì¸";
const ngeqslant = "â©¾Ì¸";
const nges = "â©¾Ì¸";
const nGg = "â‹™Ì¸";
const ngsim = "â‰µ";
const nGt = "â‰«âƒ’";
const ngt = "â‰¯";
const ngtr = "â‰¯";
const nGtv = "â‰«Ì¸";
const nharr = "â†®";
const nhArr = "â‡";
const nhpar = "â«²";
const ni = "âˆ‹";
const nis = "â‹¼";
const nisd = "â‹º";
const niv = "âˆ‹";
const NJcy = "ĞŠ";
const njcy = "Ñš";
const nlarr = "â†š";
const nlArr = "â‡";
const nldr = "â€¥";
const nlE = "â‰¦Ì¸";
const nle = "â‰°";
const nleftarrow = "â†š";
const nLeftarrow = "â‡";
const nleftrightarrow = "â†®";
const nLeftrightarrow = "â‡";
const nleq = "â‰°";
const nleqq = "â‰¦Ì¸";
const nleqslant = "â©½Ì¸";
const nles = "â©½Ì¸";
const nless = "â‰®";
const nLl = "â‹˜Ì¸";
const nlsim = "â‰´";
const nLt = "â‰ªâƒ’";
const nlt = "â‰®";
const nltri = "â‹ª";
const nltrie = "â‹¬";
const nLtv = "â‰ªÌ¸";
const nmid = "âˆ¤";
const NoBreak = "â ";
const NonBreakingSpace = "Â ";
const nopf = "ğ•Ÿ";
const Nopf = "â„•";
const Not = "â«¬";
const not$2 = "Â¬";
const NotCongruent = "â‰¢";
const NotCupCap = "â‰­";
const NotDoubleVerticalBar = "âˆ¦";
const NotElement = "âˆ‰";
const NotEqual = "â‰ ";
const NotEqualTilde = "â‰‚Ì¸";
const NotExists = "âˆ„";
const NotGreater = "â‰¯";
const NotGreaterEqual = "â‰±";
const NotGreaterFullEqual = "â‰§Ì¸";
const NotGreaterGreater = "â‰«Ì¸";
const NotGreaterLess = "â‰¹";
const NotGreaterSlantEqual = "â©¾Ì¸";
const NotGreaterTilde = "â‰µ";
const NotHumpDownHump = "â‰Ì¸";
const NotHumpEqual = "â‰Ì¸";
const notin = "âˆ‰";
const notindot = "â‹µÌ¸";
const notinE = "â‹¹Ì¸";
const notinva = "âˆ‰";
const notinvb = "â‹·";
const notinvc = "â‹¶";
const NotLeftTriangleBar = "â§Ì¸";
const NotLeftTriangle = "â‹ª";
const NotLeftTriangleEqual = "â‹¬";
const NotLess = "â‰®";
const NotLessEqual = "â‰°";
const NotLessGreater = "â‰¸";
const NotLessLess = "â‰ªÌ¸";
const NotLessSlantEqual = "â©½Ì¸";
const NotLessTilde = "â‰´";
const NotNestedGreaterGreater = "âª¢Ì¸";
const NotNestedLessLess = "âª¡Ì¸";
const notni = "âˆŒ";
const notniva = "âˆŒ";
const notnivb = "â‹¾";
const notnivc = "â‹½";
const NotPrecedes = "âŠ€";
const NotPrecedesEqual = "âª¯Ì¸";
const NotPrecedesSlantEqual = "â‹ ";
const NotReverseElement = "âˆŒ";
const NotRightTriangleBar = "â§Ì¸";
const NotRightTriangle = "â‹«";
const NotRightTriangleEqual = "â‹­";
const NotSquareSubset = "âŠÌ¸";
const NotSquareSubsetEqual = "â‹¢";
const NotSquareSuperset = "âŠÌ¸";
const NotSquareSupersetEqual = "â‹£";
const NotSubset = "âŠ‚âƒ’";
const NotSubsetEqual = "âŠˆ";
const NotSucceeds = "âŠ";
const NotSucceedsEqual = "âª°Ì¸";
const NotSucceedsSlantEqual = "â‹¡";
const NotSucceedsTilde = "â‰¿Ì¸";
const NotSuperset = "âŠƒâƒ’";
const NotSupersetEqual = "âŠ‰";
const NotTilde = "â‰";
const NotTildeEqual = "â‰„";
const NotTildeFullEqual = "â‰‡";
const NotTildeTilde = "â‰‰";
const NotVerticalBar = "âˆ¤";
const nparallel = "âˆ¦";
const npar = "âˆ¦";
const nparsl = "â«½âƒ¥";
const npart = "âˆ‚Ì¸";
const npolint = "â¨”";
const npr = "âŠ€";
const nprcue = "â‹ ";
const nprec = "âŠ€";
const npreceq = "âª¯Ì¸";
const npre = "âª¯Ì¸";
const nrarrc = "â¤³Ì¸";
const nrarr = "â†›";
const nrArr = "â‡";
const nrarrw = "â†Ì¸";
const nrightarrow = "â†›";
const nRightarrow = "â‡";
const nrtri = "â‹«";
const nrtrie = "â‹­";
const nsc = "âŠ";
const nsccue = "â‹¡";
const nsce = "âª°Ì¸";
const Nscr = "ğ’©";
const nscr = "ğ“ƒ";
const nshortmid = "âˆ¤";
const nshortparallel = "âˆ¦";
const nsim = "â‰";
const nsime = "â‰„";
const nsimeq = "â‰„";
const nsmid = "âˆ¤";
const nspar = "âˆ¦";
const nsqsube = "â‹¢";
const nsqsupe = "â‹£";
const nsub = "âŠ„";
const nsubE = "â«…Ì¸";
const nsube = "âŠˆ";
const nsubset = "âŠ‚âƒ’";
const nsubseteq = "âŠˆ";
const nsubseteqq = "â«…Ì¸";
const nsucc = "âŠ";
const nsucceq = "âª°Ì¸";
const nsup = "âŠ…";
const nsupE = "â«†Ì¸";
const nsupe = "âŠ‰";
const nsupset = "âŠƒâƒ’";
const nsupseteq = "âŠ‰";
const nsupseteqq = "â«†Ì¸";
const ntgl = "â‰¹";
const Ntilde$1 = "Ã‘";
const ntilde$1 = "Ã±";
const ntlg = "â‰¸";
const ntriangleleft = "â‹ª";
const ntrianglelefteq = "â‹¬";
const ntriangleright = "â‹«";
const ntrianglerighteq = "â‹­";
const Nu = "Î";
const nu = "Î½";
const num = "#";
const numero = "â„–";
const numsp = "â€‡";
const nvap = "â‰âƒ’";
const nvdash = "âŠ¬";
const nvDash = "âŠ­";
const nVdash = "âŠ®";
const nVDash = "âŠ¯";
const nvge = "â‰¥âƒ’";
const nvgt = ">âƒ’";
const nvHarr = "â¤„";
const nvinfin = "â§";
const nvlArr = "â¤‚";
const nvle = "â‰¤âƒ’";
const nvlt = "<âƒ’";
const nvltrie = "âŠ´âƒ’";
const nvrArr = "â¤ƒ";
const nvrtrie = "âŠµâƒ’";
const nvsim = "âˆ¼âƒ’";
const nwarhk = "â¤£";
const nwarr = "â†–";
const nwArr = "â‡–";
const nwarrow = "â†–";
const nwnear = "â¤§";
const Oacute$1 = "Ã“";
const oacute$1 = "Ã³";
const oast = "âŠ›";
const Ocirc$1 = "Ã”";
const ocirc$1 = "Ã´";
const ocir = "âŠš";
const Ocy = "Ğ";
const ocy = "Ğ¾";
const odash = "âŠ";
const Odblac = "Å";
const odblac = "Å‘";
const odiv = "â¨¸";
const odot = "âŠ™";
const odsold = "â¦¼";
const OElig = "Å’";
const oelig = "Å“";
const ofcir = "â¦¿";
const Ofr = "ğ”’";
const ofr = "ğ”¬";
const ogon = "Ë›";
const Ograve$1 = "Ã’";
const ograve$1 = "Ã²";
const ogt = "â§";
const ohbar = "â¦µ";
const ohm = "Î©";
const oint = "âˆ®";
const olarr = "â†º";
const olcir = "â¦¾";
const olcross = "â¦»";
const oline = "â€¾";
const olt = "â§€";
const Omacr = "ÅŒ";
const omacr = "Å";
const Omega = "Î©";
const omega = "Ï‰";
const Omicron = "ÎŸ";
const omicron = "Î¿";
const omid = "â¦¶";
const ominus = "âŠ–";
const Oopf = "ğ•†";
const oopf = "ğ• ";
const opar = "â¦·";
const OpenCurlyDoubleQuote = "â€œ";
const OpenCurlyQuote = "â€˜";
const operp = "â¦¹";
const oplus = "âŠ•";
const orarr = "â†»";
const Or = "â©”";
const or = "âˆ¨";
const ord = "â©";
const order$1 = "â„´";
const orderof = "â„´";
const ordf$1 = "Âª";
const ordm$1 = "Âº";
const origof = "âŠ¶";
const oror = "â©–";
const orslope = "â©—";
const orv = "â©›";
const oS = "â“ˆ";
const Oscr = "ğ’ª";
const oscr = "â„´";
const Oslash$1 = "Ã˜";
const oslash$1 = "Ã¸";
const osol = "âŠ˜";
const Otilde$1 = "Ã•";
const otilde$1 = "Ãµ";
const otimesas = "â¨¶";
const Otimes = "â¨·";
const otimes = "âŠ—";
const Ouml$1 = "Ã–";
const ouml$1 = "Ã¶";
const ovbar = "âŒ½";
const OverBar = "â€¾";
const OverBrace = "â";
const OverBracket = "â´";
const OverParenthesis = "âœ";
const para$1 = "Â¶";
const parallel = "âˆ¥";
const par = "âˆ¥";
const parsim = "â«³";
const parsl = "â«½";
const part = "âˆ‚";
const PartialD = "âˆ‚";
const Pcy = "ĞŸ";
const pcy = "Ğ¿";
const percnt = "%";
const period = ".";
const permil = "â€°";
const perp = "âŠ¥";
const pertenk = "â€±";
const Pfr = "ğ”“";
const pfr = "ğ”­";
const Phi = "Î¦";
const phi = "Ï†";
const phiv = "Ï•";
const phmmat = "â„³";
const phone = "â˜";
const Pi = "Î ";
const pi = "Ï€";
const pitchfork = "â‹”";
const piv = "Ï–";
const planck = "â„";
const planckh = "â„";
const plankv = "â„";
const plusacir = "â¨£";
const plusb = "âŠ";
const pluscir = "â¨¢";
const plus = "+";
const plusdo = "âˆ”";
const plusdu = "â¨¥";
const pluse = "â©²";
const PlusMinus = "Â±";
const plusmn$1 = "Â±";
const plussim = "â¨¦";
const plustwo = "â¨§";
const pm = "Â±";
const Poincareplane = "â„Œ";
const pointint = "â¨•";
const popf = "ğ•¡";
const Popf = "â„™";
const pound$1 = "Â£";
const prap = "âª·";
const Pr = "âª»";
const pr = "â‰º";
const prcue = "â‰¼";
const precapprox = "âª·";
const prec = "â‰º";
const preccurlyeq = "â‰¼";
const Precedes = "â‰º";
const PrecedesEqual = "âª¯";
const PrecedesSlantEqual = "â‰¼";
const PrecedesTilde = "â‰¾";
const preceq = "âª¯";
const precnapprox = "âª¹";
const precneqq = "âªµ";
const precnsim = "â‹¨";
const pre = "âª¯";
const prE = "âª³";
const precsim = "â‰¾";
const prime = "â€²";
const Prime = "â€³";
const primes = "â„™";
const prnap = "âª¹";
const prnE = "âªµ";
const prnsim = "â‹¨";
const prod = "âˆ";
const Product = "âˆ";
const profalar = "âŒ®";
const profline = "âŒ’";
const profsurf = "âŒ“";
const prop = "âˆ";
const Proportional = "âˆ";
const Proportion = "âˆ·";
const propto = "âˆ";
const prsim = "â‰¾";
const prurel = "âŠ°";
const Pscr = "ğ’«";
const pscr = "ğ“…";
const Psi = "Î¨";
const psi = "Ïˆ";
const puncsp = "â€ˆ";
const Qfr = "ğ””";
const qfr = "ğ”®";
const qint = "â¨Œ";
const qopf = "ğ•¢";
const Qopf = "â„š";
const qprime = "â—";
const Qscr = "ğ’¬";
const qscr = "ğ“†";
const quaternions = "â„";
const quatint = "â¨–";
const quest = "?";
const questeq = "â‰Ÿ";
const quot$2 = "\"";
const QUOT$1 = "\"";
const rAarr = "â‡›";
const race = "âˆ½Ì±";
const Racute = "Å”";
const racute = "Å•";
const radic = "âˆš";
const raemptyv = "â¦³";
const rang = "âŸ©";
const Rang = "âŸ«";
const rangd = "â¦’";
const range = "â¦¥";
const rangle = "âŸ©";
const raquo$1 = "Â»";
const rarrap = "â¥µ";
const rarrb = "â‡¥";
const rarrbfs = "â¤ ";
const rarrc = "â¤³";
const rarr = "â†’";
const Rarr = "â† ";
const rArr = "â‡’";
const rarrfs = "â¤";
const rarrhk = "â†ª";
const rarrlp = "â†¬";
const rarrpl = "â¥…";
const rarrsim = "â¥´";
const Rarrtl = "â¤–";
const rarrtl = "â†£";
const rarrw = "â†";
const ratail = "â¤š";
const rAtail = "â¤œ";
const ratio = "âˆ¶";
const rationals = "â„š";
const rbarr = "â¤";
const rBarr = "â¤";
const RBarr = "â¤";
const rbbrk = "â³";
const rbrace = "}";
const rbrack = "]";
const rbrke = "â¦Œ";
const rbrksld = "â¦";
const rbrkslu = "â¦";
const Rcaron = "Å˜";
const rcaron = "Å™";
const Rcedil = "Å–";
const rcedil = "Å—";
const rceil = "âŒ‰";
const rcub = "}";
const Rcy = "Ğ ";
const rcy = "Ñ€";
const rdca = "â¤·";
const rdldhar = "â¥©";
const rdquo = "â€";
const rdquor = "â€";
const rdsh = "â†³";
const real = "â„œ";
const realine = "â„›";
const realpart = "â„œ";
const reals = "â„";
const Re = "â„œ";
const rect = "â–­";
const reg$1 = "Â®";
const REG$1 = "Â®";
const ReverseElement = "âˆ‹";
const ReverseEquilibrium = "â‡‹";
const ReverseUpEquilibrium = "â¥¯";
const rfisht = "â¥½";
const rfloor = "âŒ‹";
const rfr = "ğ”¯";
const Rfr = "â„œ";
const rHar = "â¥¤";
const rhard = "â‡";
const rharu = "â‡€";
const rharul = "â¥¬";
const Rho = "Î¡";
const rho = "Ï";
const rhov = "Ï±";
const RightAngleBracket = "âŸ©";
const RightArrowBar = "â‡¥";
const rightarrow = "â†’";
const RightArrow = "â†’";
const Rightarrow = "â‡’";
const RightArrowLeftArrow = "â‡„";
const rightarrowtail = "â†£";
const RightCeiling = "âŒ‰";
const RightDoubleBracket = "âŸ§";
const RightDownTeeVector = "â¥";
const RightDownVectorBar = "â¥•";
const RightDownVector = "â‡‚";
const RightFloor = "âŒ‹";
const rightharpoondown = "â‡";
const rightharpoonup = "â‡€";
const rightleftarrows = "â‡„";
const rightleftharpoons = "â‡Œ";
const rightrightarrows = "â‡‰";
const rightsquigarrow = "â†";
const RightTeeArrow = "â†¦";
const RightTee = "âŠ¢";
const RightTeeVector = "â¥›";
const rightthreetimes = "â‹Œ";
const RightTriangleBar = "â§";
const RightTriangle = "âŠ³";
const RightTriangleEqual = "âŠµ";
const RightUpDownVector = "â¥";
const RightUpTeeVector = "â¥œ";
const RightUpVectorBar = "â¥”";
const RightUpVector = "â†¾";
const RightVectorBar = "â¥“";
const RightVector = "â‡€";
const ring = "Ëš";
const risingdotseq = "â‰“";
const rlarr = "â‡„";
const rlhar = "â‡Œ";
const rlm = "â€";
const rmoustache = "â±";
const rmoust = "â±";
const rnmid = "â«®";
const roang = "âŸ­";
const roarr = "â‡¾";
const robrk = "âŸ§";
const ropar = "â¦†";
const ropf = "ğ•£";
const Ropf = "â„";
const roplus = "â¨®";
const rotimes = "â¨µ";
const RoundImplies = "â¥°";
const rpar = ")";
const rpargt = "â¦”";
const rppolint = "â¨’";
const rrarr = "â‡‰";
const Rrightarrow = "â‡›";
const rsaquo = "â€º";
const rscr = "ğ“‡";
const Rscr = "â„›";
const rsh = "â†±";
const Rsh = "â†±";
const rsqb = "]";
const rsquo = "â€™";
const rsquor = "â€™";
const rthree = "â‹Œ";
const rtimes = "â‹Š";
const rtri = "â–¹";
const rtrie = "âŠµ";
const rtrif = "â–¸";
const rtriltri = "â§";
const RuleDelayed = "â§´";
const ruluhar = "â¥¨";
const rx = "â„";
const Sacute = "Åš";
const sacute = "Å›";
const sbquo = "â€š";
const scap = "âª¸";
const Scaron = "Å ";
const scaron = "Å¡";
const Sc = "âª¼";
const sc = "â‰»";
const sccue = "â‰½";
const sce = "âª°";
const scE = "âª´";
const Scedil = "Å";
const scedil = "ÅŸ";
const Scirc = "Åœ";
const scirc = "Å";
const scnap = "âªº";
const scnE = "âª¶";
const scnsim = "â‹©";
const scpolint = "â¨“";
const scsim = "â‰¿";
const Scy = "Ğ¡";
const scy = "Ñ";
const sdotb = "âŠ¡";
const sdot = "â‹…";
const sdote = "â©¦";
const searhk = "â¤¥";
const searr = "â†˜";
const seArr = "â‡˜";
const searrow = "â†˜";
const sect$1 = "Â§";
const semi = ";";
const seswar = "â¤©";
const setminus = "âˆ–";
const setmn = "âˆ–";
const sext = "âœ¶";
const Sfr = "ğ”–";
const sfr = "ğ”°";
const sfrown = "âŒ¢";
const sharp = "â™¯";
const SHCHcy = "Ğ©";
const shchcy = "Ñ‰";
const SHcy = "Ğ¨";
const shcy = "Ñˆ";
const ShortDownArrow = "â†“";
const ShortLeftArrow = "â†";
const shortmid = "âˆ£";
const shortparallel = "âˆ¥";
const ShortRightArrow = "â†’";
const ShortUpArrow = "â†‘";
const shy$1 = "Â­";
const Sigma = "Î£";
const sigma = "Ïƒ";
const sigmaf = "Ï‚";
const sigmav = "Ï‚";
const sim = "âˆ¼";
const simdot = "â©ª";
const sime = "â‰ƒ";
const simeq = "â‰ƒ";
const simg = "âª";
const simgE = "âª ";
const siml = "âª";
const simlE = "âªŸ";
const simne = "â‰†";
const simplus = "â¨¤";
const simrarr = "â¥²";
const slarr = "â†";
const SmallCircle = "âˆ˜";
const smallsetminus = "âˆ–";
const smashp = "â¨³";
const smeparsl = "â§¤";
const smid = "âˆ£";
const smile = "âŒ£";
const smt = "âªª";
const smte = "âª¬";
const smtes = "âª¬ï¸€";
const SOFTcy = "Ğ¬";
const softcy = "ÑŒ";
const solbar = "âŒ¿";
const solb = "â§„";
const sol = "/";
const Sopf = "ğ•Š";
const sopf = "ğ•¤";
const spades = "â™ ";
const spadesuit = "â™ ";
const spar = "âˆ¥";
const sqcap = "âŠ“";
const sqcaps = "âŠ“ï¸€";
const sqcup = "âŠ”";
const sqcups = "âŠ”ï¸€";
const Sqrt = "âˆš";
const sqsub = "âŠ";
const sqsube = "âŠ‘";
const sqsubset = "âŠ";
const sqsubseteq = "âŠ‘";
const sqsup = "âŠ";
const sqsupe = "âŠ’";
const sqsupset = "âŠ";
const sqsupseteq = "âŠ’";
const square = "â–¡";
const Square = "â–¡";
const SquareIntersection = "âŠ“";
const SquareSubset = "âŠ";
const SquareSubsetEqual = "âŠ‘";
const SquareSuperset = "âŠ";
const SquareSupersetEqual = "âŠ’";
const SquareUnion = "âŠ”";
const squarf = "â–ª";
const squ = "â–¡";
const squf = "â–ª";
const srarr = "â†’";
const Sscr = "ğ’®";
const sscr = "ğ“ˆ";
const ssetmn = "âˆ–";
const ssmile = "âŒ£";
const sstarf = "â‹†";
const Star = "â‹†";
const star = "â˜†";
const starf = "â˜…";
const straightepsilon = "Ïµ";
const straightphi = "Ï•";
const strns = "Â¯";
const sub = "âŠ‚";
const Sub = "â‹";
const subdot = "âª½";
const subE = "â«…";
const sube = "âŠ†";
const subedot = "â«ƒ";
const submult = "â«";
const subnE = "â«‹";
const subne = "âŠŠ";
const subplus = "âª¿";
const subrarr = "â¥¹";
const subset = "âŠ‚";
const Subset = "â‹";
const subseteq = "âŠ†";
const subseteqq = "â«…";
const SubsetEqual = "âŠ†";
const subsetneq = "âŠŠ";
const subsetneqq = "â«‹";
const subsim = "â«‡";
const subsub = "â«•";
const subsup = "â«“";
const succapprox = "âª¸";
const succ = "â‰»";
const succcurlyeq = "â‰½";
const Succeeds = "â‰»";
const SucceedsEqual = "âª°";
const SucceedsSlantEqual = "â‰½";
const SucceedsTilde = "â‰¿";
const succeq = "âª°";
const succnapprox = "âªº";
const succneqq = "âª¶";
const succnsim = "â‹©";
const succsim = "â‰¿";
const SuchThat = "âˆ‹";
const sum = "âˆ‘";
const Sum = "âˆ‘";
const sung = "â™ª";
const sup1$1 = "Â¹";
const sup2$1 = "Â²";
const sup3$1 = "Â³";
const sup = "âŠƒ";
const Sup = "â‹‘";
const supdot = "âª¾";
const supdsub = "â«˜";
const supE = "â«†";
const supe = "âŠ‡";
const supedot = "â«„";
const Superset = "âŠƒ";
const SupersetEqual = "âŠ‡";
const suphsol = "âŸ‰";
const suphsub = "â«—";
const suplarr = "â¥»";
const supmult = "â«‚";
const supnE = "â«Œ";
const supne = "âŠ‹";
const supplus = "â«€";
const supset = "âŠƒ";
const Supset = "â‹‘";
const supseteq = "âŠ‡";
const supseteqq = "â«†";
const supsetneq = "âŠ‹";
const supsetneqq = "â«Œ";
const supsim = "â«ˆ";
const supsub = "â«”";
const supsup = "â«–";
const swarhk = "â¤¦";
const swarr = "â†™";
const swArr = "â‡™";
const swarrow = "â†™";
const swnwar = "â¤ª";
const szlig$1 = "ÃŸ";
const Tab = "\t";
const target$1 = "âŒ–";
const Tau = "Î¤";
const tau = "Ï„";
const tbrk = "â´";
const Tcaron = "Å¤";
const tcaron = "Å¥";
const Tcedil = "Å¢";
const tcedil = "Å£";
const Tcy = "Ğ¢";
const tcy = "Ñ‚";
const tdot = "âƒ›";
const telrec = "âŒ•";
const Tfr = "ğ”—";
const tfr = "ğ”±";
const there4 = "âˆ´";
const therefore = "âˆ´";
const Therefore = "âˆ´";
const Theta = "Î˜";
const theta = "Î¸";
const thetasym = "Ï‘";
const thetav = "Ï‘";
const thickapprox = "â‰ˆ";
const thicksim = "âˆ¼";
const ThickSpace = "âŸâ€Š";
const ThinSpace = "â€‰";
const thinsp = "â€‰";
const thkap = "â‰ˆ";
const thksim = "âˆ¼";
const THORN$1 = "Ã";
const thorn$1 = "Ã¾";
const tilde = "Ëœ";
const Tilde = "âˆ¼";
const TildeEqual = "â‰ƒ";
const TildeFullEqual = "â‰…";
const TildeTilde = "â‰ˆ";
const timesbar = "â¨±";
const timesb = "âŠ ";
const times$1 = "Ã—";
const timesd = "â¨°";
const tint = "âˆ­";
const toea = "â¤¨";
const topbot = "âŒ¶";
const topcir = "â«±";
const top$1 = "âŠ¤";
const Topf = "ğ•‹";
const topf = "ğ•¥";
const topfork = "â«š";
const tosa = "â¤©";
const tprime = "â€´";
const trade = "â„¢";
const TRADE = "â„¢";
const triangle = "â–µ";
const triangledown = "â–¿";
const triangleleft = "â—ƒ";
const trianglelefteq = "âŠ´";
const triangleq = "â‰œ";
const triangleright = "â–¹";
const trianglerighteq = "âŠµ";
const tridot = "â—¬";
const trie = "â‰œ";
const triminus = "â¨º";
const TripleDot = "âƒ›";
const triplus = "â¨¹";
const trisb = "â§";
const tritime = "â¨»";
const trpezium = "â¢";
const Tscr = "ğ’¯";
const tscr = "ğ“‰";
const TScy = "Ğ¦";
const tscy = "Ñ†";
const TSHcy = "Ğ‹";
const tshcy = "Ñ›";
const Tstrok = "Å¦";
const tstrok = "Å§";
const twixt = "â‰¬";
const twoheadleftarrow = "â†";
const twoheadrightarrow = "â† ";
const Uacute$1 = "Ãš";
const uacute$1 = "Ãº";
const uarr = "â†‘";
const Uarr = "â†Ÿ";
const uArr = "â‡‘";
const Uarrocir = "â¥‰";
const Ubrcy = "Ğ";
const ubrcy = "Ñ";
const Ubreve = "Å¬";
const ubreve = "Å­";
const Ucirc$1 = "Ã›";
const ucirc$1 = "Ã»";
const Ucy = "Ğ£";
const ucy = "Ñƒ";
const udarr = "â‡…";
const Udblac = "Å°";
const udblac = "Å±";
const udhar = "â¥®";
const ufisht = "â¥¾";
const Ufr = "ğ”˜";
const ufr = "ğ”²";
const Ugrave$1 = "Ã™";
const ugrave$1 = "Ã¹";
const uHar = "â¥£";
const uharl = "â†¿";
const uharr = "â†¾";
const uhblk = "â–€";
const ulcorn = "âŒœ";
const ulcorner = "âŒœ";
const ulcrop = "âŒ";
const ultri = "â—¸";
const Umacr = "Åª";
const umacr = "Å«";
const uml$1 = "Â¨";
const UnderBar = "_";
const UnderBrace = "âŸ";
const UnderBracket = "âµ";
const UnderParenthesis = "â";
const Union = "â‹ƒ";
const UnionPlus = "âŠ";
const Uogon = "Å²";
const uogon = "Å³";
const Uopf = "ğ•Œ";
const uopf = "ğ•¦";
const UpArrowBar = "â¤’";
const uparrow = "â†‘";
const UpArrow = "â†‘";
const Uparrow = "â‡‘";
const UpArrowDownArrow = "â‡…";
const updownarrow = "â†•";
const UpDownArrow = "â†•";
const Updownarrow = "â‡•";
const UpEquilibrium = "â¥®";
const upharpoonleft = "â†¿";
const upharpoonright = "â†¾";
const uplus = "âŠ";
const UpperLeftArrow = "â†–";
const UpperRightArrow = "â†—";
const upsi = "Ï…";
const Upsi = "Ï’";
const upsih = "Ï’";
const Upsilon = "Î¥";
const upsilon = "Ï…";
const UpTeeArrow = "â†¥";
const UpTee = "âŠ¥";
const upuparrows = "â‡ˆ";
const urcorn = "âŒ";
const urcorner = "âŒ";
const urcrop = "âŒ";
const Uring = "Å®";
const uring = "Å¯";
const urtri = "â—¹";
const Uscr = "ğ’°";
const uscr = "ğ“Š";
const utdot = "â‹°";
const Utilde = "Å¨";
const utilde = "Å©";
const utri = "â–µ";
const utrif = "â–´";
const uuarr = "â‡ˆ";
const Uuml$1 = "Ãœ";
const uuml$1 = "Ã¼";
const uwangle = "â¦§";
const vangrt = "â¦œ";
const varepsilon = "Ïµ";
const varkappa = "Ï°";
const varnothing = "âˆ…";
const varphi = "Ï•";
const varpi = "Ï–";
const varpropto = "âˆ";
const varr = "â†•";
const vArr = "â‡•";
const varrho = "Ï±";
const varsigma = "Ï‚";
const varsubsetneq = "âŠŠï¸€";
const varsubsetneqq = "â«‹ï¸€";
const varsupsetneq = "âŠ‹ï¸€";
const varsupsetneqq = "â«Œï¸€";
const vartheta = "Ï‘";
const vartriangleleft = "âŠ²";
const vartriangleright = "âŠ³";
const vBar = "â«¨";
const Vbar = "â««";
const vBarv = "â«©";
const Vcy = "Ğ’";
const vcy = "Ğ²";
const vdash = "âŠ¢";
const vDash = "âŠ¨";
const Vdash = "âŠ©";
const VDash = "âŠ«";
const Vdashl = "â«¦";
const veebar = "âŠ»";
const vee = "âˆ¨";
const Vee = "â‹";
const veeeq = "â‰š";
const vellip = "â‹®";
const verbar = "|";
const Verbar = "â€–";
const vert = "|";
const Vert = "â€–";
const VerticalBar = "âˆ£";
const VerticalLine = "|";
const VerticalSeparator = "â˜";
const VerticalTilde = "â‰€";
const VeryThinSpace = "â€Š";
const Vfr = "ğ”™";
const vfr = "ğ”³";
const vltri = "âŠ²";
const vnsub = "âŠ‚âƒ’";
const vnsup = "âŠƒâƒ’";
const Vopf = "ğ•";
const vopf = "ğ•§";
const vprop = "âˆ";
const vrtri = "âŠ³";
const Vscr = "ğ’±";
const vscr = "ğ“‹";
const vsubnE = "â«‹ï¸€";
const vsubne = "âŠŠï¸€";
const vsupnE = "â«Œï¸€";
const vsupne = "âŠ‹ï¸€";
const Vvdash = "âŠª";
const vzigzag = "â¦š";
const Wcirc = "Å´";
const wcirc = "Åµ";
const wedbar = "â©Ÿ";
const wedge = "âˆ§";
const Wedge = "â‹€";
const wedgeq = "â‰™";
const weierp = "â„˜";
const Wfr = "ğ”š";
const wfr = "ğ”´";
const Wopf = "ğ•";
const wopf = "ğ•¨";
const wp = "â„˜";
const wr = "â‰€";
const wreath = "â‰€";
const Wscr = "ğ’²";
const wscr = "ğ“Œ";
const xcap = "â‹‚";
const xcirc = "â—¯";
const xcup = "â‹ƒ";
const xdtri = "â–½";
const Xfr = "ğ”›";
const xfr = "ğ”µ";
const xharr = "âŸ·";
const xhArr = "âŸº";
const Xi = "Î";
const xi = "Î¾";
const xlarr = "âŸµ";
const xlArr = "âŸ¸";
const xmap = "âŸ¼";
const xnis = "â‹»";
const xodot = "â¨€";
const Xopf = "ğ•";
const xopf = "ğ•©";
const xoplus = "â¨";
const xotime = "â¨‚";
const xrarr = "âŸ¶";
const xrArr = "âŸ¹";
const Xscr = "ğ’³";
const xscr = "ğ“";
const xsqcup = "â¨†";
const xuplus = "â¨„";
const xutri = "â–³";
const xvee = "â‹";
const xwedge = "â‹€";
const Yacute$1 = "Ã";
const yacute$1 = "Ã½";
const YAcy = "Ğ¯";
const yacy = "Ñ";
const Ycirc = "Å¶";
const ycirc = "Å·";
const Ycy = "Ğ«";
const ycy = "Ñ‹";
const yen$1 = "Â¥";
const Yfr = "ğ”œ";
const yfr = "ğ”¶";
const YIcy = "Ğ‡";
const yicy = "Ñ—";
const Yopf = "ğ•";
const yopf = "ğ•ª";
const Yscr = "ğ’´";
const yscr = "ğ“";
const YUcy = "Ğ®";
const yucy = "Ñ";
const yuml$1 = "Ã¿";
const Yuml = "Å¸";
const Zacute = "Å¹";
const zacute = "Åº";
const Zcaron = "Å½";
const zcaron = "Å¾";
const Zcy = "Ğ—";
const zcy = "Ğ·";
const Zdot = "Å»";
const zdot = "Å¼";
const zeetrf = "â„¨";
const ZeroWidthSpace = "â€‹";
const Zeta = "Î–";
const zeta = "Î¶";
const zfr = "ğ”·";
const Zfr = "â„¨";
const ZHcy = "Ğ–";
const zhcy = "Ğ¶";
const zigrarr = "â‡";
const zopf = "ğ•«";
const Zopf = "â„¤";
const Zscr = "ğ’µ";
const zscr = "ğ“";
const zwj = "â€";
const zwnj = "â€Œ";
const require$$1$2 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom: bottom$1,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap: gap$1,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$1,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "âˆˆ",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang: lang$1,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  "Map": "â¤…",
  map,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$2,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order: order$1,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target: target$1,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top: top$1,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj,
};

const Aacute = "Ã";
const aacute = "Ã¡";
const Acirc = "Ã‚";
const acirc = "Ã¢";
const acute = "Â´";
const AElig = "Ã†";
const aelig = "Ã¦";
const Agrave = "Ã€";
const agrave = "Ã ";
const amp$1 = "&";
const AMP = "&";
const Aring = "Ã…";
const aring = "Ã¥";
const Atilde = "Ãƒ";
const atilde = "Ã£";
const Auml = "Ã„";
const auml = "Ã¤";
const brvbar = "Â¦";
const Ccedil = "Ã‡";
const ccedil = "Ã§";
const cedil = "Â¸";
const cent = "Â¢";
const copy = "Â©";
const COPY = "Â©";
const curren = "Â¤";
const deg = "Â°";
const divide = "Ã·";
const Eacute = "Ã‰";
const eacute = "Ã©";
const Ecirc = "ÃŠ";
const ecirc = "Ãª";
const Egrave = "Ãˆ";
const egrave = "Ã¨";
const ETH = "Ã";
const eth = "Ã°";
const Euml = "Ã‹";
const euml = "Ã«";
const frac12 = "Â½";
const frac14 = "Â¼";
const frac34 = "Â¾";
const gt$1 = ">";
const GT = ">";
const Iacute = "Ã";
const iacute = "Ã­";
const Icirc = "Ã";
const icirc = "Ã®";
const iexcl = "Â¡";
const Igrave = "ÃŒ";
const igrave = "Ã¬";
const iquest = "Â¿";
const Iuml = "Ã";
const iuml = "Ã¯";
const laquo = "Â«";
const lt$1 = "<";
const LT = "<";
const macr = "Â¯";
const micro = "Âµ";
const middot = "Â·";
const nbsp = "Â ";
const not$1 = "Â¬";
const Ntilde = "Ã‘";
const ntilde = "Ã±";
const Oacute = "Ã“";
const oacute = "Ã³";
const Ocirc = "Ã”";
const ocirc = "Ã´";
const Ograve = "Ã’";
const ograve = "Ã²";
const ordf = "Âª";
const ordm = "Âº";
const Oslash = "Ã˜";
const oslash = "Ã¸";
const Otilde = "Ã•";
const otilde = "Ãµ";
const Ouml = "Ã–";
const ouml = "Ã¶";
const para = "Â¶";
const plusmn = "Â±";
const pound = "Â£";
const quot$1 = "\"";
const QUOT = "\"";
const raquo = "Â»";
const reg = "Â®";
const REG = "Â®";
const sect = "Â§";
const shy = "Â­";
const sup1 = "Â¹";
const sup2 = "Â²";
const sup3 = "Â³";
const szlig = "ÃŸ";
const THORN = "Ã";
const thorn = "Ã¾";
const times = "Ã—";
const Uacute = "Ãš";
const uacute = "Ãº";
const Ucirc = "Ã›";
const ucirc = "Ã»";
const Ugrave = "Ã™";
const ugrave = "Ã¹";
const uml = "Â¨";
const Uuml = "Ãœ";
const uuml = "Ã¼";
const Yacute = "Ã";
const yacute = "Ã½";
const yen = "Â¥";
const yuml = "Ã¿";
const require$$1$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not: not$1,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml,
};

const amp = "&";
const apos = "'";
const gt = ">";
const lt = "<";
const quot = "\"";
const require$$0$3 = {
  amp,
  apos,
  gt,
  lt,
  quot,
};

var decode_codepoint = {};

const require$$0$2 = {
  "0": 65533,
  "128": 8364,
  "130": 8218,
  "131": 402,
  "132": 8222,
  "133": 8230,
  "134": 8224,
  "135": 8225,
  "136": 710,
  "137": 8240,
  "138": 352,
  "139": 8249,
  "140": 338,
  "142": 381,
  "145": 8216,
  "146": 8217,
  "147": 8220,
  "148": 8221,
  "149": 8226,
  "150": 8211,
  "151": 8212,
  "152": 732,
  "153": 8482,
  "154": 353,
  "155": 8250,
  "156": 339,
  "158": 382,
  "159": 376,
};

var hasRequiredDecode_codepoint;

function requireDecode_codepoint () {
	if (hasRequiredDecode_codepoint) return decode_codepoint;
	hasRequiredDecode_codepoint = 1;
	var __importDefault = (decode_codepoint && decode_codepoint.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(decode_codepoint, "__esModule", { value: true });
	var decode_json_1 = __importDefault(require$$0$2);
	// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
	var fromCodePoint = 
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	String.fromCodePoint ||
	    function (codePoint) {
	        var output = "";
	        if (codePoint > 0xffff) {
	            codePoint -= 0x10000;
	            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
	            codePoint = 0xdc00 | (codePoint & 0x3ff);
	        }
	        output += String.fromCharCode(codePoint);
	        return output;
	    };
	function decodeCodePoint(codePoint) {
	    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
	        return "\uFFFD";
	    }
	    if (codePoint in decode_json_1.default) {
	        codePoint = decode_json_1.default[codePoint];
	    }
	    return fromCodePoint(codePoint);
	}
	decode_codepoint.default = decodeCodePoint;
	return decode_codepoint;
}

var hasRequiredDecode;

function requireDecode () {
	if (hasRequiredDecode) return decode;
	hasRequiredDecode = 1;
	var __importDefault = (decode && decode.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(decode, "__esModule", { value: true });
	decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
	var entities_json_1 = __importDefault(require$$1$2);
	var legacy_json_1 = __importDefault(require$$1$1);
	var xml_json_1 = __importDefault(require$$0$3);
	var decode_codepoint_1 = __importDefault(/*@__PURE__*/ requireDecode_codepoint());
	var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
	decode.decodeXML = getStrictDecoder(xml_json_1.default);
	decode.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
	function getStrictDecoder(map) {
	    var replace = getReplacer(map);
	    return function (str) { return String(str).replace(strictEntityRe, replace); };
	}
	var sorter = function (a, b) { return (a < b ? 1 : -1); };
	decode.decodeHTML = (function () {
	    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
	    var keys = Object.keys(entities_json_1.default).sort(sorter);
	    for (var i = 0, j = 0; i < keys.length; i++) {
	        if (legacy[j] === keys[i]) {
	            keys[i] += ";?";
	            j++;
	        }
	        else {
	            keys[i] += ";";
	        }
	    }
	    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
	    var replace = getReplacer(entities_json_1.default);
	    function replacer(str) {
	        if (str.substr(-1) !== ";")
	            str += ";";
	        return replace(str);
	    }
	    // TODO consider creating a merged map
	    return function (str) { return String(str).replace(re, replacer); };
	})();
	function getReplacer(map) {
	    return function replace(str) {
	        if (str.charAt(1) === "#") {
	            var secondChar = str.charAt(2);
	            if (secondChar === "X" || secondChar === "x") {
	                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
	            }
	            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
	        }
	        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
	        return map[str.slice(1, -1)] || str;
	    };
	}
	return decode;
}

var encode = {};

var hasRequiredEncode;

function requireEncode () {
	if (hasRequiredEncode) return encode;
	hasRequiredEncode = 1;
	var __importDefault = (encode && encode.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(encode, "__esModule", { value: true });
	encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
	var xml_json_1 = __importDefault(require$$0$3);
	var inverseXML = getInverseObj(xml_json_1.default);
	var xmlReplacer = getInverseReplacer(inverseXML);
	/**
	 * Encodes all non-ASCII characters, as well as characters not valid in XML
	 * documents using XML entities.
	 *
	 * If a character has no equivalent entity, a
	 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
	 */
	encode.encodeXML = getASCIIEncoder(inverseXML);
	var entities_json_1 = __importDefault(require$$1$2);
	var inverseHTML = getInverseObj(entities_json_1.default);
	var htmlReplacer = getInverseReplacer(inverseHTML);
	/**
	 * Encodes all entities and non-ASCII characters in the input.
	 *
	 * This includes characters that are valid ASCII characters in HTML documents.
	 * For example `#` will be encoded as `&num;`. To get a more compact output,
	 * consider using the `encodeNonAsciiHTML` function.
	 *
	 * If a character has no equivalent entity, a
	 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
	 */
	encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
	/**
	 * Encodes all non-ASCII characters, as well as characters not valid in HTML
	 * documents using HTML entities.
	 *
	 * If a character has no equivalent entity, a
	 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
	 */
	encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
	function getInverseObj(obj) {
	    return Object.keys(obj)
	        .sort()
	        .reduce(function (inverse, name) {
	        inverse[obj[name]] = "&" + name + ";";
	        return inverse;
	    }, {});
	}
	function getInverseReplacer(inverse) {
	    var single = [];
	    var multiple = [];
	    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
	        var k = _a[_i];
	        if (k.length === 1) {
	            // Add value to single array
	            single.push("\\" + k);
	        }
	        else {
	            // Add value to multiple array
	            multiple.push(k);
	        }
	    }
	    // Add ranges to single characters.
	    single.sort();
	    for (var start = 0; start < single.length - 1; start++) {
	        // Find the end of a run of characters
	        var end = start;
	        while (end < single.length - 1 &&
	            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
	            end += 1;
	        }
	        var count = 1 + end - start;
	        // We want to replace at least three characters
	        if (count < 3)
	            continue;
	        single.splice(start, count, single[start] + "-" + single[end]);
	    }
	    multiple.unshift("[" + single.join("") + "]");
	    return new RegExp(multiple.join("|"), "g");
	}
	// /[^\0-\x7F]/gu
	var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
	var getCodePoint = 
	// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	String.prototype.codePointAt != null
	    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        function (str) { return str.codePointAt(0); }
	    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	        function (c) {
	            return (c.charCodeAt(0) - 0xd800) * 0x400 +
	                c.charCodeAt(1) -
	                0xdc00 +
	                0x10000;
	        };
	function singleCharReplacer(c) {
	    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
	        .toString(16)
	        .toUpperCase() + ";";
	}
	function getInverse(inverse, re) {
	    return function (data) {
	        return data
	            .replace(re, function (name) { return inverse[name]; })
	            .replace(reNonASCII, singleCharReplacer);
	    };
	}
	var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
	/**
	 * Encodes all non-ASCII characters, as well as characters not valid in XML
	 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
	 *
	 * Have a look at `escapeUTF8` if you want a more concise output at the expense
	 * of reduced transportability.
	 *
	 * @param data String to escape.
	 */
	function escape(data) {
	    return data.replace(reEscapeChars, singleCharReplacer);
	}
	encode.escape = escape;
	/**
	 * Encodes all characters not valid in XML documents using numeric hexadecimal
	 * reference (eg. `&#xfc;`).
	 *
	 * Note that the output will be character-set dependent.
	 *
	 * @param data String to escape.
	 */
	function escapeUTF8(data) {
	    return data.replace(xmlReplacer, singleCharReplacer);
	}
	encode.escapeUTF8 = escapeUTF8;
	function getASCIIEncoder(obj) {
	    return function (data) {
	        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
	    };
	}
	return encode;
}

var hasRequiredLib$6;

function requireLib$6 () {
	if (hasRequiredLib$6) return lib$3;
	hasRequiredLib$6 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
		var decode_1 = /*@__PURE__*/ requireDecode();
		var encode_1 = /*@__PURE__*/ requireEncode();
		/**
		 * Decodes a string with entities.
		 *
		 * @param data String to decode.
		 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
		 * @deprecated Use `decodeXML` or `decodeHTML` directly.
		 */
		function decode(data, level) {
		    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
		}
		exports.decode = decode;
		/**
		 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
		 *
		 * @param data String to decode.
		 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
		 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
		 */
		function decodeStrict(data, level) {
		    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
		}
		exports.decodeStrict = decodeStrict;
		/**
		 * Encodes a string with entities.
		 *
		 * @param data String to encode.
		 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
		 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
		 */
		function encode(data, level) {
		    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
		}
		exports.encode = encode;
		var encode_2 = /*@__PURE__*/ requireEncode();
		Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
		Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
		Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
		Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
		Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
		// Legacy aliases (deprecated)
		Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
		Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
		var decode_2 = /*@__PURE__*/ requireDecode();
		Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
		Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
		Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
		// Legacy aliases (deprecated)
		Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
		Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
		Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
		Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
		Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } }); 
	} (lib$3));
	return lib$3;
}

var foreignNames = {};

var hasRequiredForeignNames;

function requireForeignNames () {
	if (hasRequiredForeignNames) return foreignNames;
	hasRequiredForeignNames = 1;
	Object.defineProperty(foreignNames, "__esModule", { value: true });
	foreignNames.attributeNames = foreignNames.elementNames = void 0;
	foreignNames.elementNames = new Map([
	    ["altglyph", "altGlyph"],
	    ["altglyphdef", "altGlyphDef"],
	    ["altglyphitem", "altGlyphItem"],
	    ["animatecolor", "animateColor"],
	    ["animatemotion", "animateMotion"],
	    ["animatetransform", "animateTransform"],
	    ["clippath", "clipPath"],
	    ["feblend", "feBlend"],
	    ["fecolormatrix", "feColorMatrix"],
	    ["fecomponenttransfer", "feComponentTransfer"],
	    ["fecomposite", "feComposite"],
	    ["feconvolvematrix", "feConvolveMatrix"],
	    ["fediffuselighting", "feDiffuseLighting"],
	    ["fedisplacementmap", "feDisplacementMap"],
	    ["fedistantlight", "feDistantLight"],
	    ["fedropshadow", "feDropShadow"],
	    ["feflood", "feFlood"],
	    ["fefunca", "feFuncA"],
	    ["fefuncb", "feFuncB"],
	    ["fefuncg", "feFuncG"],
	    ["fefuncr", "feFuncR"],
	    ["fegaussianblur", "feGaussianBlur"],
	    ["feimage", "feImage"],
	    ["femerge", "feMerge"],
	    ["femergenode", "feMergeNode"],
	    ["femorphology", "feMorphology"],
	    ["feoffset", "feOffset"],
	    ["fepointlight", "fePointLight"],
	    ["fespecularlighting", "feSpecularLighting"],
	    ["fespotlight", "feSpotLight"],
	    ["fetile", "feTile"],
	    ["feturbulence", "feTurbulence"],
	    ["foreignobject", "foreignObject"],
	    ["glyphref", "glyphRef"],
	    ["lineargradient", "linearGradient"],
	    ["radialgradient", "radialGradient"],
	    ["textpath", "textPath"],
	]);
	foreignNames.attributeNames = new Map([
	    ["definitionurl", "definitionURL"],
	    ["attributename", "attributeName"],
	    ["attributetype", "attributeType"],
	    ["basefrequency", "baseFrequency"],
	    ["baseprofile", "baseProfile"],
	    ["calcmode", "calcMode"],
	    ["clippathunits", "clipPathUnits"],
	    ["diffuseconstant", "diffuseConstant"],
	    ["edgemode", "edgeMode"],
	    ["filterunits", "filterUnits"],
	    ["glyphref", "glyphRef"],
	    ["gradienttransform", "gradientTransform"],
	    ["gradientunits", "gradientUnits"],
	    ["kernelmatrix", "kernelMatrix"],
	    ["kernelunitlength", "kernelUnitLength"],
	    ["keypoints", "keyPoints"],
	    ["keysplines", "keySplines"],
	    ["keytimes", "keyTimes"],
	    ["lengthadjust", "lengthAdjust"],
	    ["limitingconeangle", "limitingConeAngle"],
	    ["markerheight", "markerHeight"],
	    ["markerunits", "markerUnits"],
	    ["markerwidth", "markerWidth"],
	    ["maskcontentunits", "maskContentUnits"],
	    ["maskunits", "maskUnits"],
	    ["numoctaves", "numOctaves"],
	    ["pathlength", "pathLength"],
	    ["patterncontentunits", "patternContentUnits"],
	    ["patterntransform", "patternTransform"],
	    ["patternunits", "patternUnits"],
	    ["pointsatx", "pointsAtX"],
	    ["pointsaty", "pointsAtY"],
	    ["pointsatz", "pointsAtZ"],
	    ["preservealpha", "preserveAlpha"],
	    ["preserveaspectratio", "preserveAspectRatio"],
	    ["primitiveunits", "primitiveUnits"],
	    ["refx", "refX"],
	    ["refy", "refY"],
	    ["repeatcount", "repeatCount"],
	    ["repeatdur", "repeatDur"],
	    ["requiredextensions", "requiredExtensions"],
	    ["requiredfeatures", "requiredFeatures"],
	    ["specularconstant", "specularConstant"],
	    ["specularexponent", "specularExponent"],
	    ["spreadmethod", "spreadMethod"],
	    ["startoffset", "startOffset"],
	    ["stddeviation", "stdDeviation"],
	    ["stitchtiles", "stitchTiles"],
	    ["surfacescale", "surfaceScale"],
	    ["systemlanguage", "systemLanguage"],
	    ["tablevalues", "tableValues"],
	    ["targetx", "targetX"],
	    ["targety", "targetY"],
	    ["textlength", "textLength"],
	    ["viewbox", "viewBox"],
	    ["viewtarget", "viewTarget"],
	    ["xchannelselector", "xChannelSelector"],
	    ["ychannelselector", "yChannelSelector"],
	    ["zoomandpan", "zoomAndPan"],
	]);
	return foreignNames;
}

var hasRequiredLib$5;

function requireLib$5 () {
	if (hasRequiredLib$5) return lib$4;
	hasRequiredLib$5 = 1;
	var __assign = (lib$4 && lib$4.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __createBinding = (lib$4 && lib$4.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lib$4 && lib$4.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lib$4 && lib$4.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(lib$4, "__esModule", { value: true });
	/*
	 * Module dependencies
	 */
	var ElementType = __importStar(/*@__PURE__*/ requireLib$8());
	var entities_1 = /*@__PURE__*/ requireLib$6();
	/**
	 * Mixed-case SVG and MathML tags & attributes
	 * recognized by the HTML parser.
	 *
	 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
	 */
	var foreignNames_1 = /*@__PURE__*/ requireForeignNames();
	var unencodedElements = new Set([
	    "style",
	    "script",
	    "xmp",
	    "iframe",
	    "noembed",
	    "noframes",
	    "plaintext",
	    "noscript",
	]);
	/**
	 * Format attributes
	 */
	function formatAttributes(attributes, opts) {
	    if (!attributes)
	        return;
	    return Object.keys(attributes)
	        .map(function (key) {
	        var _a, _b;
	        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
	        if (opts.xmlMode === "foreign") {
	            /* Fix up mixed-case attribute names */
	            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
	        }
	        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
	            return key;
	        }
	        return key + "=\"" + (opts.decodeEntities !== false
	            ? entities_1.encodeXML(value)
	            : value.replace(/"/g, "&quot;")) + "\"";
	    })
	        .join(" ");
	}
	/**
	 * Self-enclosing tags
	 */
	var singleTag = new Set([
	    "area",
	    "base",
	    "basefont",
	    "br",
	    "col",
	    "command",
	    "embed",
	    "frame",
	    "hr",
	    "img",
	    "input",
	    "isindex",
	    "keygen",
	    "link",
	    "meta",
	    "param",
	    "source",
	    "track",
	    "wbr",
	]);
	/**
	 * Renders a DOM node or an array of DOM nodes to a string.
	 *
	 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
	 *
	 * @param node Node to be rendered.
	 * @param options Changes serialization behavior
	 */
	function render(node, options) {
	    if (options === void 0) { options = {}; }
	    var nodes = "length" in node ? node : [node];
	    var output = "";
	    for (var i = 0; i < nodes.length; i++) {
	        output += renderNode(nodes[i], options);
	    }
	    return output;
	}
	lib$4.default = render;
	function renderNode(node, options) {
	    switch (node.type) {
	        case ElementType.Root:
	            return render(node.children, options);
	        case ElementType.Directive:
	        case ElementType.Doctype:
	            return renderDirective(node);
	        case ElementType.Comment:
	            return renderComment(node);
	        case ElementType.CDATA:
	            return renderCdata(node);
	        case ElementType.Script:
	        case ElementType.Style:
	        case ElementType.Tag:
	            return renderTag(node, options);
	        case ElementType.Text:
	            return renderText(node, options);
	    }
	}
	var foreignModeIntegrationPoints = new Set([
	    "mi",
	    "mo",
	    "mn",
	    "ms",
	    "mtext",
	    "annotation-xml",
	    "foreignObject",
	    "desc",
	    "title",
	]);
	var foreignElements = new Set(["svg", "math"]);
	function renderTag(elem, opts) {
	    var _a;
	    // Handle SVG / MathML in HTML
	    if (opts.xmlMode === "foreign") {
	        /* Fix up mixed-case element names */
	        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
	        /* Exit foreign mode at integration points */
	        if (elem.parent &&
	            foreignModeIntegrationPoints.has(elem.parent.name)) {
	            opts = __assign(__assign({}, opts), { xmlMode: false });
	        }
	    }
	    if (!opts.xmlMode && foreignElements.has(elem.name)) {
	        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
	    }
	    var tag = "<" + elem.name;
	    var attribs = formatAttributes(elem.attribs, opts);
	    if (attribs) {
	        tag += " " + attribs;
	    }
	    if (elem.children.length === 0 &&
	        (opts.xmlMode
	            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
	                opts.selfClosingTags !== false
	            : // User explicitly asked for self-closing tags, even in HTML mode
	                opts.selfClosingTags && singleTag.has(elem.name))) {
	        if (!opts.xmlMode)
	            tag += " ";
	        tag += "/>";
	    }
	    else {
	        tag += ">";
	        if (elem.children.length > 0) {
	            tag += render(elem.children, opts);
	        }
	        if (opts.xmlMode || !singleTag.has(elem.name)) {
	            tag += "</" + elem.name + ">";
	        }
	    }
	    return tag;
	}
	function renderDirective(elem) {
	    return "<" + elem.data + ">";
	}
	function renderText(elem, opts) {
	    var data = elem.data || "";
	    // If entities weren't decoded, no need to encode them back
	    if (opts.decodeEntities !== false &&
	        !(!opts.xmlMode &&
	            elem.parent &&
	            unencodedElements.has(elem.parent.name))) {
	        data = entities_1.encodeXML(data);
	    }
	    return data;
	}
	function renderCdata(elem) {
	    return "<![CDATA[" + elem.children[0].data + "]]>";
	}
	function renderComment(elem) {
	    return "<!--" + elem.data + "-->";
	}
	return lib$4;
}

var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify$1;
	hasRequiredStringify = 1;
	var __importDefault = (stringify$1 && stringify$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(stringify$1, "__esModule", { value: true });
	stringify$1.innerText = stringify$1.textContent = stringify$1.getText = stringify$1.getInnerHTML = stringify$1.getOuterHTML = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$7();
	var dom_serializer_1 = __importDefault(/*@__PURE__*/ requireLib$5());
	var domelementtype_1 = /*@__PURE__*/ requireLib$8();
	/**
	 * @param node Node to get the outer HTML of.
	 * @param options Options for serialization.
	 * @deprecated Use the `dom-serializer` module directly.
	 * @returns `node`'s outer HTML.
	 */
	function getOuterHTML(node, options) {
	    return (0, dom_serializer_1.default)(node, options);
	}
	stringify$1.getOuterHTML = getOuterHTML;
	/**
	 * @param node Node to get the inner HTML of.
	 * @param options Options for serialization.
	 * @deprecated Use the `dom-serializer` module directly.
	 * @returns `node`'s inner HTML.
	 */
	function getInnerHTML(node, options) {
	    return (0, domhandler_1.hasChildren)(node)
	        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
	        : "";
	}
	stringify$1.getInnerHTML = getInnerHTML;
	/**
	 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
	 *
	 * @deprecated Use `textContent` instead.
	 * @param node Node to get the inner text of.
	 * @returns `node`'s inner text.
	 */
	function getText(node) {
	    if (Array.isArray(node))
	        return node.map(getText).join("");
	    if ((0, domhandler_1.isTag)(node))
	        return node.name === "br" ? "\n" : getText(node.children);
	    if ((0, domhandler_1.isCDATA)(node))
	        return getText(node.children);
	    if ((0, domhandler_1.isText)(node))
	        return node.data;
	    return "";
	}
	stringify$1.getText = getText;
	/**
	 * Get a node's text content.
	 *
	 * @param node Node to get the text content of.
	 * @returns `node`'s text content.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
	 */
	function textContent(node) {
	    if (Array.isArray(node))
	        return node.map(textContent).join("");
	    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
	        return textContent(node.children);
	    }
	    if ((0, domhandler_1.isText)(node))
	        return node.data;
	    return "";
	}
	stringify$1.textContent = textContent;
	/**
	 * Get a node's inner text.
	 *
	 * @param node Node to get the inner text of.
	 * @returns `node`'s inner text.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
	 */
	function innerText(node) {
	    if (Array.isArray(node))
	        return node.map(innerText).join("");
	    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
	        return innerText(node.children);
	    }
	    if ((0, domhandler_1.isText)(node))
	        return node.data;
	    return "";
	}
	stringify$1.innerText = innerText;
	return stringify$1;
}

var traversal = {};

var hasRequiredTraversal;

function requireTraversal () {
	if (hasRequiredTraversal) return traversal;
	hasRequiredTraversal = 1;
	Object.defineProperty(traversal, "__esModule", { value: true });
	traversal.prevElementSibling = traversal.nextElementSibling = traversal.getName = traversal.hasAttrib = traversal.getAttributeValue = traversal.getSiblings = traversal.getParent = traversal.getChildren = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$7();
	var emptyArray = [];
	/**
	 * Get a node's children.
	 *
	 * @param elem Node to get the children of.
	 * @returns `elem`'s children, or an empty array.
	 */
	function getChildren(elem) {
	    var _a;
	    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
	}
	traversal.getChildren = getChildren;
	/**
	 * Get a node's parent.
	 *
	 * @param elem Node to get the parent of.
	 * @returns `elem`'s parent node.
	 */
	function getParent(elem) {
	    return elem.parent || null;
	}
	traversal.getParent = getParent;
	/**
	 * Gets an elements siblings, including the element itself.
	 *
	 * Attempts to get the children through the element's parent first.
	 * If we don't have a parent (the element is a root node),
	 * we walk the element's `prev` & `next` to get all remaining nodes.
	 *
	 * @param elem Element to get the siblings of.
	 * @returns `elem`'s siblings.
	 */
	function getSiblings(elem) {
	    var _a, _b;
	    var parent = getParent(elem);
	    if (parent != null)
	        return getChildren(parent);
	    var siblings = [elem];
	    var prev = elem.prev, next = elem.next;
	    while (prev != null) {
	        siblings.unshift(prev);
	        (_a = prev, prev = _a.prev);
	    }
	    while (next != null) {
	        siblings.push(next);
	        (_b = next, next = _b.next);
	    }
	    return siblings;
	}
	traversal.getSiblings = getSiblings;
	/**
	 * Gets an attribute from an element.
	 *
	 * @param elem Element to check.
	 * @param name Attribute name to retrieve.
	 * @returns The element's attribute value, or `undefined`.
	 */
	function getAttributeValue(elem, name) {
	    var _a;
	    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
	}
	traversal.getAttributeValue = getAttributeValue;
	/**
	 * Checks whether an element has an attribute.
	 *
	 * @param elem Element to check.
	 * @param name Attribute name to look for.
	 * @returns Returns whether `elem` has the attribute `name`.
	 */
	function hasAttrib(elem, name) {
	    return (elem.attribs != null &&
	        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
	        elem.attribs[name] != null);
	}
	traversal.hasAttrib = hasAttrib;
	/**
	 * Get the tag name of an element.
	 *
	 * @param elem The element to get the name for.
	 * @returns The tag name of `elem`.
	 */
	function getName(elem) {
	    return elem.name;
	}
	traversal.getName = getName;
	/**
	 * Returns the next element sibling of a node.
	 *
	 * @param elem The element to get the next sibling of.
	 * @returns `elem`'s next sibling that is a tag.
	 */
	function nextElementSibling(elem) {
	    var _a;
	    var next = elem.next;
	    while (next !== null && !(0, domhandler_1.isTag)(next))
	        (_a = next, next = _a.next);
	    return next;
	}
	traversal.nextElementSibling = nextElementSibling;
	/**
	 * Returns the previous element sibling of a node.
	 *
	 * @param elem The element to get the previous sibling of.
	 * @returns `elem`'s previous sibling that is a tag.
	 */
	function prevElementSibling(elem) {
	    var _a;
	    var prev = elem.prev;
	    while (prev !== null && !(0, domhandler_1.isTag)(prev))
	        (_a = prev, prev = _a.prev);
	    return prev;
	}
	traversal.prevElementSibling = prevElementSibling;
	return traversal;
}

var manipulation = {};

var hasRequiredManipulation;

function requireManipulation () {
	if (hasRequiredManipulation) return manipulation;
	hasRequiredManipulation = 1;
	Object.defineProperty(manipulation, "__esModule", { value: true });
	manipulation.prepend = manipulation.prependChild = manipulation.append = manipulation.appendChild = manipulation.replaceElement = manipulation.removeElement = void 0;
	/**
	 * Remove an element from the dom
	 *
	 * @param elem The element to be removed
	 */
	function removeElement(elem) {
	    if (elem.prev)
	        elem.prev.next = elem.next;
	    if (elem.next)
	        elem.next.prev = elem.prev;
	    if (elem.parent) {
	        var childs = elem.parent.children;
	        childs.splice(childs.lastIndexOf(elem), 1);
	    }
	}
	manipulation.removeElement = removeElement;
	/**
	 * Replace an element in the dom
	 *
	 * @param elem The element to be replaced
	 * @param replacement The element to be added
	 */
	function replaceElement(elem, replacement) {
	    var prev = (replacement.prev = elem.prev);
	    if (prev) {
	        prev.next = replacement;
	    }
	    var next = (replacement.next = elem.next);
	    if (next) {
	        next.prev = replacement;
	    }
	    var parent = (replacement.parent = elem.parent);
	    if (parent) {
	        var childs = parent.children;
	        childs[childs.lastIndexOf(elem)] = replacement;
	    }
	}
	manipulation.replaceElement = replaceElement;
	/**
	 * Append a child to an element.
	 *
	 * @param elem The element to append to.
	 * @param child The element to be added as a child.
	 */
	function appendChild(elem, child) {
	    removeElement(child);
	    child.next = null;
	    child.parent = elem;
	    if (elem.children.push(child) > 1) {
	        var sibling = elem.children[elem.children.length - 2];
	        sibling.next = child;
	        child.prev = sibling;
	    }
	    else {
	        child.prev = null;
	    }
	}
	manipulation.appendChild = appendChild;
	/**
	 * Append an element after another.
	 *
	 * @param elem The element to append after.
	 * @param next The element be added.
	 */
	function append(elem, next) {
	    removeElement(next);
	    var parent = elem.parent;
	    var currNext = elem.next;
	    next.next = currNext;
	    next.prev = elem;
	    elem.next = next;
	    next.parent = parent;
	    if (currNext) {
	        currNext.prev = next;
	        if (parent) {
	            var childs = parent.children;
	            childs.splice(childs.lastIndexOf(currNext), 0, next);
	        }
	    }
	    else if (parent) {
	        parent.children.push(next);
	    }
	}
	manipulation.append = append;
	/**
	 * Prepend a child to an element.
	 *
	 * @param elem The element to prepend before.
	 * @param child The element to be added as a child.
	 */
	function prependChild(elem, child) {
	    removeElement(child);
	    child.parent = elem;
	    child.prev = null;
	    if (elem.children.unshift(child) !== 1) {
	        var sibling = elem.children[1];
	        sibling.prev = child;
	        child.next = sibling;
	    }
	    else {
	        child.next = null;
	    }
	}
	manipulation.prependChild = prependChild;
	/**
	 * Prepend an element before another.
	 *
	 * @param elem The element to prepend before.
	 * @param prev The element be added.
	 */
	function prepend(elem, prev) {
	    removeElement(prev);
	    var parent = elem.parent;
	    if (parent) {
	        var childs = parent.children;
	        childs.splice(childs.indexOf(elem), 0, prev);
	    }
	    if (elem.prev) {
	        elem.prev.next = prev;
	    }
	    prev.parent = parent;
	    prev.prev = elem.prev;
	    prev.next = elem;
	    elem.prev = prev;
	}
	manipulation.prepend = prepend;
	return manipulation;
}

var querying = {};

var hasRequiredQuerying;

function requireQuerying () {
	if (hasRequiredQuerying) return querying;
	hasRequiredQuerying = 1;
	Object.defineProperty(querying, "__esModule", { value: true });
	querying.findAll = querying.existsOne = querying.findOne = querying.findOneChild = querying.find = querying.filter = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$7();
	/**
	 * Search a node and its children for nodes passing a test function.
	 *
	 * @param test Function to test nodes on.
	 * @param node Node to search. Will be included in the result set if it matches.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes passing `test`.
	 */
	function filter(test, node, recurse, limit) {
	    if (recurse === void 0) { recurse = true; }
	    if (limit === void 0) { limit = Infinity; }
	    if (!Array.isArray(node))
	        node = [node];
	    return find(test, node, recurse, limit);
	}
	querying.filter = filter;
	/**
	 * Search an array of node and its children for nodes passing a test function.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes passing `test`.
	 */
	function find(test, nodes, recurse, limit) {
	    var result = [];
	    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
	        var elem = nodes_1[_i];
	        if (test(elem)) {
	            result.push(elem);
	            if (--limit <= 0)
	                break;
	        }
	        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
	            var children = find(test, elem.children, recurse, limit);
	            result.push.apply(result, children);
	            limit -= children.length;
	            if (limit <= 0)
	                break;
	        }
	    }
	    return result;
	}
	querying.find = find;
	/**
	 * Finds the first element inside of an array that matches a test function.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @returns The first node in the array that passes `test`.
	 */
	function findOneChild(test, nodes) {
	    return nodes.find(test);
	}
	querying.findOneChild = findOneChild;
	/**
	 * Finds one element in a tree that passes a test.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @param recurse Also consider child nodes.
	 * @returns The first child node that passes `test`.
	 */
	function findOne(test, nodes, recurse) {
	    if (recurse === void 0) { recurse = true; }
	    var elem = null;
	    for (var i = 0; i < nodes.length && !elem; i++) {
	        var checked = nodes[i];
	        if (!(0, domhandler_1.isTag)(checked)) {
	            continue;
	        }
	        else if (test(checked)) {
	            elem = checked;
	        }
	        else if (recurse && checked.children.length > 0) {
	            elem = findOne(test, checked.children);
	        }
	    }
	    return elem;
	}
	querying.findOne = findOne;
	/**
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @returns Whether a tree of nodes contains at least one node passing a test.
	 */
	function existsOne(test, nodes) {
	    return nodes.some(function (checked) {
	        return (0, domhandler_1.isTag)(checked) &&
	            (test(checked) ||
	                (checked.children.length > 0 &&
	                    existsOne(test, checked.children)));
	    });
	}
	querying.existsOne = existsOne;
	/**
	 * Search and array of nodes and its children for nodes passing a test function.
	 *
	 * Same as `find`, only with less options, leading to reduced complexity.
	 *
	 * @param test Function to test nodes on.
	 * @param nodes Array of nodes to search.
	 * @returns All nodes passing `test`.
	 */
	function findAll(test, nodes) {
	    var _a;
	    var result = [];
	    var stack = nodes.filter(domhandler_1.isTag);
	    var elem;
	    while ((elem = stack.shift())) {
	        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
	        if (children && children.length > 0) {
	            stack.unshift.apply(stack, children);
	        }
	        if (test(elem))
	            result.push(elem);
	    }
	    return result;
	}
	querying.findAll = findAll;
	return querying;
}

var legacy = {};

var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;
	Object.defineProperty(legacy, "__esModule", { value: true });
	legacy.getElementsByTagType = legacy.getElementsByTagName = legacy.getElementById = legacy.getElements = legacy.testElement = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$7();
	var querying_1 = /*@__PURE__*/ requireQuerying();
	var Checks = {
	    tag_name: function (name) {
	        if (typeof name === "function") {
	            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
	        }
	        else if (name === "*") {
	            return domhandler_1.isTag;
	        }
	        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
	    },
	    tag_type: function (type) {
	        if (typeof type === "function") {
	            return function (elem) { return type(elem.type); };
	        }
	        return function (elem) { return elem.type === type; };
	    },
	    tag_contains: function (data) {
	        if (typeof data === "function") {
	            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
	        }
	        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
	    },
	};
	/**
	 * @param attrib Attribute to check.
	 * @param value Attribute value to look for.
	 * @returns A function to check whether the a node has an attribute with a particular value.
	 */
	function getAttribCheck(attrib, value) {
	    if (typeof value === "function") {
	        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
	    }
	    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
	}
	/**
	 * @param a First function to combine.
	 * @param b Second function to combine.
	 * @returns A function taking a node and returning `true` if either
	 * of the input functions returns `true` for the node.
	 */
	function combineFuncs(a, b) {
	    return function (elem) { return a(elem) || b(elem); };
	}
	/**
	 * @param options An object describing nodes to look for.
	 * @returns A function executing all checks in `options` and returning `true`
	 * if any of them match a node.
	 */
	function compileTest(options) {
	    var funcs = Object.keys(options).map(function (key) {
	        var value = options[key];
	        return Object.prototype.hasOwnProperty.call(Checks, key)
	            ? Checks[key](value)
	            : getAttribCheck(key, value);
	    });
	    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
	}
	/**
	 * @param options An object describing nodes to look for.
	 * @param node The element to test.
	 * @returns Whether the element matches the description in `options`.
	 */
	function testElement(options, node) {
	    var test = compileTest(options);
	    return test ? test(node) : true;
	}
	legacy.testElement = testElement;
	/**
	 * @param options An object describing nodes to look for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes that match `options`.
	 */
	function getElements(options, nodes, recurse, limit) {
	    if (limit === void 0) { limit = Infinity; }
	    var test = compileTest(options);
	    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
	}
	legacy.getElements = getElements;
	/**
	 * @param id The unique ID attribute value to look for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @returns The node with the supplied ID.
	 */
	function getElementById(id, nodes, recurse) {
	    if (recurse === void 0) { recurse = true; }
	    if (!Array.isArray(nodes))
	        nodes = [nodes];
	    return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
	}
	legacy.getElementById = getElementById;
	/**
	 * @param tagName Tag name to search for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes with the supplied `tagName`.
	 */
	function getElementsByTagName(tagName, nodes, recurse, limit) {
	    if (recurse === void 0) { recurse = true; }
	    if (limit === void 0) { limit = Infinity; }
	    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
	}
	legacy.getElementsByTagName = getElementsByTagName;
	/**
	 * @param type Element type to look for.
	 * @param nodes Nodes to search through.
	 * @param recurse Also consider child nodes.
	 * @param limit Maximum number of nodes to return.
	 * @returns All nodes with the supplied `type`.
	 */
	function getElementsByTagType(type, nodes, recurse, limit) {
	    if (recurse === void 0) { recurse = true; }
	    if (limit === void 0) { limit = Infinity; }
	    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
	}
	legacy.getElementsByTagType = getElementsByTagType;
	return legacy;
}

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;
	Object.defineProperty(helpers, "__esModule", { value: true });
	helpers.uniqueSort = helpers.compareDocumentPosition = helpers.removeSubsets = void 0;
	var domhandler_1 = /*@__PURE__*/ requireLib$7();
	/**
	 * Given an array of nodes, remove any member that is contained by another.
	 *
	 * @param nodes Nodes to filter.
	 * @returns Remaining nodes that aren't subtrees of each other.
	 */
	function removeSubsets(nodes) {
	    var idx = nodes.length;
	    /*
	     * Check if each node (or one of its ancestors) is already contained in the
	     * array.
	     */
	    while (--idx >= 0) {
	        var node = nodes[idx];
	        /*
	         * Remove the node if it is not unique.
	         * We are going through the array from the end, so we only
	         * have to check nodes that preceed the node under consideration in the array.
	         */
	        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
	            nodes.splice(idx, 1);
	            continue;
	        }
	        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
	            if (nodes.includes(ancestor)) {
	                nodes.splice(idx, 1);
	                break;
	            }
	        }
	    }
	    return nodes;
	}
	helpers.removeSubsets = removeSubsets;
	/**
	 * Compare the position of one node against another node in any other document.
	 * The return value is a bitmask with the following values:
	 *
	 * Document order:
	 * > There is an ordering, document order, defined on all the nodes in the
	 * > document corresponding to the order in which the first character of the
	 * > XML representation of each node occurs in the XML representation of the
	 * > document after expansion of general entities. Thus, the document element
	 * > node will be the first node. Element nodes occur before their children.
	 * > Thus, document order orders element nodes in order of the occurrence of
	 * > their start-tag in the XML (after expansion of entities). The attribute
	 * > nodes of an element occur after the element and before its children. The
	 * > relative order of attribute nodes is implementation-dependent./
	 *
	 * Source:
	 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
	 *
	 * @param nodeA The first node to use in the comparison
	 * @param nodeB The second node to use in the comparison
	 * @returns A bitmask describing the input nodes' relative position.
	 *
	 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
	 * a description of these values.
	 */
	function compareDocumentPosition(nodeA, nodeB) {
	    var aParents = [];
	    var bParents = [];
	    if (nodeA === nodeB) {
	        return 0;
	    }
	    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
	    while (current) {
	        aParents.unshift(current);
	        current = current.parent;
	    }
	    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
	    while (current) {
	        bParents.unshift(current);
	        current = current.parent;
	    }
	    var maxIdx = Math.min(aParents.length, bParents.length);
	    var idx = 0;
	    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
	        idx++;
	    }
	    if (idx === 0) {
	        return 1 /* DISCONNECTED */;
	    }
	    var sharedParent = aParents[idx - 1];
	    var siblings = sharedParent.children;
	    var aSibling = aParents[idx];
	    var bSibling = bParents[idx];
	    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
	        if (sharedParent === nodeB) {
	            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
	        }
	        return 4 /* FOLLOWING */;
	    }
	    if (sharedParent === nodeA) {
	        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
	    }
	    return 2 /* PRECEDING */;
	}
	helpers.compareDocumentPosition = compareDocumentPosition;
	/**
	 * Sort an array of nodes based on their relative position in the document and
	 * remove any duplicate nodes. If the array contains nodes that do not belong
	 * to the same document, sort order is unspecified.
	 *
	 * @param nodes Array of DOM nodes.
	 * @returns Collection of unique nodes, sorted in document order.
	 */
	function uniqueSort(nodes) {
	    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
	    nodes.sort(function (a, b) {
	        var relative = compareDocumentPosition(a, b);
	        if (relative & 2 /* PRECEDING */) {
	            return -1;
	        }
	        else if (relative & 4 /* FOLLOWING */) {
	            return 1;
	        }
	        return 0;
	    });
	    return nodes;
	}
	helpers.uniqueSort = uniqueSort;
	return helpers;
}

var feeds = {};

var hasRequiredFeeds;

function requireFeeds () {
	if (hasRequiredFeeds) return feeds;
	hasRequiredFeeds = 1;
	Object.defineProperty(feeds, "__esModule", { value: true });
	feeds.getFeed = void 0;
	var stringify_1 = /*@__PURE__*/ requireStringify();
	var legacy_1 = /*@__PURE__*/ requireLegacy();
	/**
	 * Get the feed object from the root of a DOM tree.
	 *
	 * @param doc - The DOM to to extract the feed from.
	 * @returns The feed.
	 */
	function getFeed(doc) {
	    var feedRoot = getOneElement(isValidFeed, doc);
	    return !feedRoot
	        ? null
	        : feedRoot.name === "feed"
	            ? getAtomFeed(feedRoot)
	            : getRssFeed(feedRoot);
	}
	feeds.getFeed = getFeed;
	/**
	 * Parse an Atom feed.
	 *
	 * @param feedRoot The root of the feed.
	 * @returns The parsed feed.
	 */
	function getAtomFeed(feedRoot) {
	    var _a;
	    var childs = feedRoot.children;
	    var feed = {
	        type: "atom",
	        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
	            var _a;
	            var children = item.children;
	            var entry = { media: getMediaElements(children) };
	            addConditionally(entry, "id", "id", children);
	            addConditionally(entry, "title", "title", children);
	            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
	            if (href) {
	                entry.link = href;
	            }
	            var description = fetch("summary", children) || fetch("content", children);
	            if (description) {
	                entry.description = description;
	            }
	            var pubDate = fetch("updated", children);
	            if (pubDate) {
	                entry.pubDate = new Date(pubDate);
	            }
	            return entry;
	        }),
	    };
	    addConditionally(feed, "id", "id", childs);
	    addConditionally(feed, "title", "title", childs);
	    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
	    if (href) {
	        feed.link = href;
	    }
	    addConditionally(feed, "description", "subtitle", childs);
	    var updated = fetch("updated", childs);
	    if (updated) {
	        feed.updated = new Date(updated);
	    }
	    addConditionally(feed, "author", "email", childs, true);
	    return feed;
	}
	/**
	 * Parse a RSS feed.
	 *
	 * @param feedRoot The root of the feed.
	 * @returns The parsed feed.
	 */
	function getRssFeed(feedRoot) {
	    var _a, _b;
	    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
	    var feed = {
	        type: feedRoot.name.substr(0, 3),
	        id: "",
	        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
	            var children = item.children;
	            var entry = { media: getMediaElements(children) };
	            addConditionally(entry, "id", "guid", children);
	            addConditionally(entry, "title", "title", children);
	            addConditionally(entry, "link", "link", children);
	            addConditionally(entry, "description", "description", children);
	            var pubDate = fetch("pubDate", children);
	            if (pubDate)
	                entry.pubDate = new Date(pubDate);
	            return entry;
	        }),
	    };
	    addConditionally(feed, "title", "title", childs);
	    addConditionally(feed, "link", "link", childs);
	    addConditionally(feed, "description", "description", childs);
	    var updated = fetch("lastBuildDate", childs);
	    if (updated) {
	        feed.updated = new Date(updated);
	    }
	    addConditionally(feed, "author", "managingEditor", childs, true);
	    return feed;
	}
	var MEDIA_KEYS_STRING = ["url", "type", "lang"];
	var MEDIA_KEYS_INT = [
	    "fileSize",
	    "bitrate",
	    "framerate",
	    "samplingrate",
	    "channels",
	    "duration",
	    "height",
	    "width",
	];
	/**
	 * Get all media elements of a feed item.
	 *
	 * @param where Nodes to search in.
	 * @returns Media elements.
	 */
	function getMediaElements(where) {
	    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
	        var attribs = elem.attribs;
	        var media = {
	            medium: attribs.medium,
	            isDefault: !!attribs.isDefault,
	        };
	        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
	            var attrib = MEDIA_KEYS_STRING_1[_i];
	            if (attribs[attrib]) {
	                media[attrib] = attribs[attrib];
	            }
	        }
	        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
	            var attrib = MEDIA_KEYS_INT_1[_a];
	            if (attribs[attrib]) {
	                media[attrib] = parseInt(attribs[attrib], 10);
	            }
	        }
	        if (attribs.expression) {
	            media.expression =
	                attribs.expression;
	        }
	        return media;
	    });
	}
	/**
	 * Get one element by tag name.
	 *
	 * @param tagName Tag name to look for
	 * @param node Node to search in
	 * @returns The element or null
	 */
	function getOneElement(tagName, node) {
	    return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
	}
	/**
	 * Get the text content of an element with a certain tag name.
	 *
	 * @param tagName Tag name to look for.
	 * @param where  Node to search in.
	 * @param recurse Whether to recurse into child nodes.
	 * @returns The text content of the element.
	 */
	function fetch(tagName, where, recurse) {
	    if (recurse === void 0) { recurse = false; }
	    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
	}
	/**
	 * Adds a property to an object if it has a value.
	 *
	 * @param obj Object to be extended
	 * @param prop Property name
	 * @param tagName Tag name that contains the conditionally added property
	 * @param where Element to search for the property
	 * @param recurse Whether to recurse into child nodes.
	 */
	function addConditionally(obj, prop, tagName, where, recurse) {
	    if (recurse === void 0) { recurse = false; }
	    var val = fetch(tagName, where, recurse);
	    if (val)
	        obj[prop] = val;
	}
	/**
	 * Checks if an element is a feed root node.
	 *
	 * @param value The name of the element to check.
	 * @returns Whether an element is a feed root node.
	 */
	function isValidFeed(value) {
	    return value === "rss" || value === "feed" || value === "rdf:RDF";
	}
	return feeds;
}

var hasRequiredLib$4;

function requireLib$4 () {
	if (hasRequiredLib$4) return lib$7;
	hasRequiredLib$4 = 1;
	(function (exports) {
		var __createBinding = (lib$7 && lib$7.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (lib$7 && lib$7.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
		__exportStar(/*@__PURE__*/ requireStringify(), exports);
		__exportStar(/*@__PURE__*/ requireTraversal(), exports);
		__exportStar(/*@__PURE__*/ requireManipulation(), exports);
		__exportStar(/*@__PURE__*/ requireQuerying(), exports);
		__exportStar(/*@__PURE__*/ requireLegacy(), exports);
		__exportStar(/*@__PURE__*/ requireHelpers(), exports);
		__exportStar(/*@__PURE__*/ requireFeeds(), exports);
		/** @deprecated Use these methods from `domhandler` directly. */
		var domhandler_1 = /*@__PURE__*/ requireLib$7();
		Object.defineProperty(exports, "isTag", { enumerable: true, get: function () { return domhandler_1.isTag; } });
		Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });
		Object.defineProperty(exports, "isText", { enumerable: true, get: function () { return domhandler_1.isText; } });
		Object.defineProperty(exports, "isComment", { enumerable: true, get: function () { return domhandler_1.isComment; } });
		Object.defineProperty(exports, "isDocument", { enumerable: true, get: function () { return domhandler_1.isDocument; } });
		Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function () { return domhandler_1.hasChildren; } }); 
	} (lib$7));
	return lib$7;
}

var boolbase;
var hasRequiredBoolbase;

function requireBoolbase () {
	if (hasRequiredBoolbase) return boolbase;
	hasRequiredBoolbase = 1;
	boolbase = {
		trueFunc: function trueFunc(){
			return true;
		},
		falseFunc: function falseFunc(){
			return false;
		}
	};
	return boolbase;
}

var compile$1 = {};

var SelectorType;
(function (SelectorType) {
    SelectorType["Attribute"] = "attribute";
    SelectorType["Pseudo"] = "pseudo";
    SelectorType["PseudoElement"] = "pseudo-element";
    SelectorType["Tag"] = "tag";
    SelectorType["Universal"] = "universal";
    // Traversals
    SelectorType["Adjacent"] = "adjacent";
    SelectorType["Child"] = "child";
    SelectorType["Descendant"] = "descendant";
    SelectorType["Parent"] = "parent";
    SelectorType["Sibling"] = "sibling";
    SelectorType["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
/**
 * Modes for ignore case.
 *
 * This could be updated to an enum, and the object is
 * the current stand-in that will allow code to be updated
 * without big changes.
 */
const IgnoreCaseMode = {
    Unknown: null,
    QuirksMode: "quirks",
    IgnoreCase: true,
    CaseSensitive: false,
};
var AttributeAction;
(function (AttributeAction) {
    AttributeAction["Any"] = "any";
    AttributeAction["Element"] = "element";
    AttributeAction["End"] = "end";
    AttributeAction["Equals"] = "equals";
    AttributeAction["Exists"] = "exists";
    AttributeAction["Hyphen"] = "hyphen";
    AttributeAction["Not"] = "not";
    AttributeAction["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));

const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes = new Map([
    [126 /* Tilde */, AttributeAction.Element],
    [94 /* Circumflex */, AttributeAction.Start],
    [36 /* Dollar */, AttributeAction.End],
    [42 /* Asterisk */, AttributeAction.Any],
    [33 /* ExclamationMark */, AttributeAction.Not],
    [124 /* Pipe */, AttributeAction.Hyphen],
]);
// Pseudos, whose data property is parsed as well.
const unpackPseudos = new Set([
    "has",
    "not",
    "matches",
    "is",
    "where",
    "host",
    "host-context",
]);
/**
 * Checks whether a specific selector is a traversal.
 * This is useful eg. in swapping the order of elements that
 * are not traversals.
 *
 * @param selector Selector to check.
 */
function isTraversal(selector) {
    switch (selector.type) {
        case SelectorType.Adjacent:
        case SelectorType.Child:
        case SelectorType.Descendant:
        case SelectorType.Parent:
        case SelectorType.Sibling:
        case SelectorType.ColumnCombinator:
            return true;
        default:
            return false;
    }
}
const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
function funescape(_, escaped, escapedWhitespace) {
    const high = parseInt(escaped, 16) - 0x10000;
    // NaN means non-codepoint
    return high !== high || escapedWhitespace
        ? escaped
        : high < 0
            ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
            : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
}
function unescapeCSS(str) {
    return str.replace(reEscape, funescape);
}
function isQuote(c) {
    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
}
function isWhitespace(c) {
    return (c === 32 /* Space */ ||
        c === 9 /* Tab */ ||
        c === 10 /* NewLine */ ||
        c === 12 /* FormFeed */ ||
        c === 13 /* CarriageReturn */);
}
/**
 * Parses `selector`, optionally with the passed `options`.
 *
 * @param selector Selector to parse.
 * @param options Options for parsing.
 * @returns Returns a two-dimensional array.
 * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
 * the second contains the relevant tokens for that selector.
 */
function parse$1(selector) {
    const subselects = [];
    const endIndex = parseSelector(subselects, `${selector}`, 0);
    if (endIndex < selector.length) {
        throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
    }
    return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
    let tokens = [];
    function getName(offset) {
        const match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
            throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
        }
        const [name] = match;
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
    }
    function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length &&
            isWhitespace(selector.charCodeAt(selectorIndex))) {
            selectorIndex++;
        }
    }
    function readValueWithParenthesis() {
        selectorIndex += 1;
        const start = selectorIndex;
        let counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
            if (selector.charCodeAt(selectorIndex) ===
                40 /* LeftParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter++;
            }
            else if (selector.charCodeAt(selectorIndex) ===
                41 /* RightParenthesis */ &&
                !isEscaped(selectorIndex)) {
                counter--;
            }
        }
        if (counter) {
            throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
    }
    function isEscaped(pos) {
        let slashCount = 0;
        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
            slashCount++;
        return (slashCount & 1) === 1;
    }
    function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
        }
    }
    function addTraversal(type) {
        if (tokens.length > 0 &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens[tokens.length - 1].type = type;
            return;
        }
        ensureNotTraversal();
        tokens.push({ type });
    }
    function addSpecialAttribute(name, action) {
        tokens.push({
            type: SelectorType.Attribute,
            name,
            action,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks",
        });
    }
    /**
     * We have finished parsing the current part of the selector.
     *
     * Remove descendant tokens at the end if they exist,
     * and return the last index, so that parsing can be
     * picked up from here.
     */
    function finalizeSubselector() {
        if (tokens.length &&
            tokens[tokens.length - 1].type === SelectorType.Descendant) {
            tokens.pop();
        }
        if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
    }
    stripWhitespace(0);
    if (selector.length === selectorIndex) {
        return selectorIndex;
    }
    loop: while (selectorIndex < selector.length) {
        const firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
            // Whitespace
            case 32 /* Space */:
            case 9 /* Tab */:
            case 10 /* NewLine */:
            case 12 /* FormFeed */:
            case 13 /* CarriageReturn */: {
                if (tokens.length === 0 ||
                    tokens[0].type !== SelectorType.Descendant) {
                    ensureNotTraversal();
                    tokens.push({ type: SelectorType.Descendant });
                }
                stripWhitespace(1);
                break;
            }
            // Traversals
            case 62 /* GreaterThan */: {
                addTraversal(SelectorType.Child);
                stripWhitespace(1);
                break;
            }
            case 60 /* LessThan */: {
                addTraversal(SelectorType.Parent);
                stripWhitespace(1);
                break;
            }
            case 126 /* Tilde */: {
                addTraversal(SelectorType.Sibling);
                stripWhitespace(1);
                break;
            }
            case 43 /* Plus */: {
                addTraversal(SelectorType.Adjacent);
                stripWhitespace(1);
                break;
            }
            // Special attribute selectors: .class, #id
            case 46 /* Period */: {
                addSpecialAttribute("class", AttributeAction.Element);
                break;
            }
            case 35 /* Hash */: {
                addSpecialAttribute("id", AttributeAction.Equals);
                break;
            }
            case 91 /* LeftSquareBracket */: {
                stripWhitespace(1);
                // Determine attribute name and namespace
                let name;
                let namespace = null;
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                    // Equivalent to no namespace
                    name = getName(1);
                }
                else if (selector.startsWith("*|", selectorIndex)) {
                    namespace = "*";
                    name = getName(2);
                }
                else {
                    name = getName(0);
                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                        selector.charCodeAt(selectorIndex + 1) !==
                            61 /* Equal */) {
                        namespace = name;
                        name = getName(1);
                    }
                }
                stripWhitespace(0);
                // Determine comparison operation
                let action = AttributeAction.Exists;
                const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                if (possibleAction) {
                    action = possibleAction;
                    if (selector.charCodeAt(selectorIndex + 1) !==
                        61 /* Equal */) {
                        throw new Error("Expected `=`");
                    }
                    stripWhitespace(2);
                }
                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                    action = AttributeAction.Equals;
                    stripWhitespace(1);
                }
                // Determine value
                let value = "";
                let ignoreCase = null;
                if (action !== "exists") {
                    if (isQuote(selector.charCodeAt(selectorIndex))) {
                        const quote = selector.charCodeAt(selectorIndex);
                        let sectionEnd = selectorIndex + 1;
                        while (sectionEnd < selector.length &&
                            (selector.charCodeAt(sectionEnd) !== quote ||
                                isEscaped(sectionEnd))) {
                            sectionEnd += 1;
                        }
                        if (selector.charCodeAt(sectionEnd) !== quote) {
                            throw new Error("Attribute value didn't end");
                        }
                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                        selectorIndex = sectionEnd + 1;
                    }
                    else {
                        const valueStart = selectorIndex;
                        while (selectorIndex < selector.length &&
                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&
                                selector.charCodeAt(selectorIndex) !==
                                    93 /* RightSquareBracket */) ||
                                isEscaped(selectorIndex))) {
                            selectorIndex += 1;
                        }
                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                    }
                    stripWhitespace(0);
                    // See if we have a force ignore flag
                    const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                    // If the forceIgnore flag is set (either `i` or `s`), use that value
                    if (forceIgnore === 115 /* LowerS */) {
                        ignoreCase = false;
                        stripWhitespace(1);
                    }
                    else if (forceIgnore === 105 /* LowerI */) {
                        ignoreCase = true;
                        stripWhitespace(1);
                    }
                }
                if (selector.charCodeAt(selectorIndex) !==
                    93 /* RightSquareBracket */) {
                    throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                const attributeSelector = {
                    type: SelectorType.Attribute,
                    name,
                    action,
                    value,
                    namespace,
                    ignoreCase,
                };
                tokens.push(attributeSelector);
                break;
            }
            case 58 /* Colon */: {
                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                    tokens.push({
                        type: SelectorType.PseudoElement,
                        name: getName(2).toLowerCase(),
                        data: selector.charCodeAt(selectorIndex) ===
                            40 /* LeftParenthesis */
                            ? readValueWithParenthesis()
                            : null,
                    });
                    continue;
                }
                const name = getName(1).toLowerCase();
                let data = null;
                if (selector.charCodeAt(selectorIndex) ===
                    40 /* LeftParenthesis */) {
                    if (unpackPseudos.has(name)) {
                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                            throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                        }
                        data = [];
                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                        if (selector.charCodeAt(selectorIndex) !==
                            41 /* RightParenthesis */) {
                            throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                        }
                        selectorIndex += 1;
                    }
                    else {
                        data = readValueWithParenthesis();
                        if (stripQuotesFromPseudos.has(name)) {
                            const quot = data.charCodeAt(0);
                            if (quot === data.charCodeAt(data.length - 1) &&
                                isQuote(quot)) {
                                data = data.slice(1, -1);
                            }
                        }
                        data = unescapeCSS(data);
                    }
                }
                tokens.push({ type: SelectorType.Pseudo, name, data });
                break;
            }
            case 44 /* Comma */: {
                finalizeSubselector();
                tokens = [];
                stripWhitespace(1);
                break;
            }
            default: {
                if (selector.startsWith("/*", selectorIndex)) {
                    const endIndex = selector.indexOf("*/", selectorIndex + 2);
                    if (endIndex < 0) {
                        throw new Error("Comment was not terminated");
                    }
                    selectorIndex = endIndex + 2;
                    // Remove leading whitespace
                    if (tokens.length === 0) {
                        stripWhitespace(0);
                    }
                    break;
                }
                let namespace = null;
                let name;
                if (firstChar === 42 /* Asterisk */) {
                    selectorIndex += 1;
                    name = "*";
                }
                else if (firstChar === 124 /* Pipe */) {
                    name = "";
                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                        addTraversal(SelectorType.ColumnCombinator);
                        stripWhitespace(2);
                        break;
                    }
                }
                else if (reName.test(selector.slice(selectorIndex))) {
                    name = getName(0);
                }
                else {
                    break loop;
                }
                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                    namespace = name;
                    if (selector.charCodeAt(selectorIndex + 1) ===
                        42 /* Asterisk */) {
                        name = "*";
                        selectorIndex += 2;
                    }
                    else {
                        name = getName(1);
                    }
                }
                tokens.push(name === "*"
                    ? { type: SelectorType.Universal, namespace }
                    : { type: SelectorType.Tag, name, namespace });
            }
        }
    }
    finalizeSubselector();
    return selectorIndex;
}

const attribValChars = ["\\", '"'];
const pseudoValChars = [...attribValChars, "(", ")"];
const charsToEscapeInAttributeValue = new Set(attribValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c) => c.charCodeAt(0)));
const charsToEscapeInName = new Set([
    ...pseudoValChars,
    "~",
    "^",
    "$",
    "*",
    "+",
    "!",
    "|",
    ":",
    "[",
    "]",
    " ",
    ".",
].map((c) => c.charCodeAt(0)));
/**
 * Turns `selector` back into a string.
 *
 * @param selector Selector to stringify.
 */
function stringify(selector) {
    return selector
        .map((token) => token.map(stringifyToken).join(""))
        .join(", ");
}
function stringifyToken(token, index, arr) {
    switch (token.type) {
        // Simple types
        case SelectorType.Child:
            return index === 0 ? "> " : " > ";
        case SelectorType.Parent:
            return index === 0 ? "< " : " < ";
        case SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
        case SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
        case SelectorType.Descendant:
            return " ";
        case SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
        case SelectorType.Universal:
            // Return an empty string if the selector isn't needed.
            return token.namespace === "*" &&
                index + 1 < arr.length &&
                "name" in arr[index + 1]
                ? ""
                : `${getNamespace(token.namespace)}*`;
        case SelectorType.Tag:
            return getNamespacedName(token);
        case SelectorType.PseudoElement:
            return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
        case SelectorType.Pseudo:
            return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null
                ? ""
                : `(${typeof token.data === "string"
                    ? escapeName(token.data, charsToEscapeInPseudoValue)
                    : stringify(token.data)})`}`;
        case SelectorType.Attribute: {
            if (token.name === "id" &&
                token.action === AttributeAction.Equals &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `#${escapeName(token.value, charsToEscapeInName)}`;
            }
            if (token.name === "class" &&
                token.action === AttributeAction.Element &&
                token.ignoreCase === "quirks" &&
                !token.namespace) {
                return `.${escapeName(token.value, charsToEscapeInName)}`;
            }
            const name = getNamespacedName(token);
            if (token.action === AttributeAction.Exists) {
                return `[${name}]`;
            }
            return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
        }
    }
}
function getActionValue(action) {
    switch (action) {
        case AttributeAction.Equals:
            return "";
        case AttributeAction.Element:
            return "~";
        case AttributeAction.Start:
            return "^";
        case AttributeAction.End:
            return "$";
        case AttributeAction.Any:
            return "*";
        case AttributeAction.Not:
            return "!";
        case AttributeAction.Hyphen:
            return "|";
        case AttributeAction.Exists:
            throw new Error("Shouldn't be here");
    }
}
function getNamespacedName(token) {
    return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
    return namespace !== null
        ? `${namespace === "*"
            ? "*"
            : escapeName(namespace, charsToEscapeInName)}|`
        : "";
}
function escapeName(str, charsToEscape) {
    let lastIdx = 0;
    let ret = "";
    for (let i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
            ret += `${str.slice(lastIdx, i)}\\${str.charAt(i)}`;
            lastIdx = i + 1;
        }
    }
    return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}

const es = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  get AttributeAction () { return AttributeAction; },
  IgnoreCaseMode,
  get SelectorType () { return SelectorType; },
  isTraversal,
  parse: parse$1,
  stringify
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$1 = /*@__PURE__*/getAugmentedNamespace(es);

var sort = {};

var procedure = {};

var hasRequiredProcedure;

function requireProcedure () {
	if (hasRequiredProcedure) return procedure;
	hasRequiredProcedure = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isTraversal = exports.procedure = void 0;
		exports.procedure = {
		    universal: 50,
		    tag: 30,
		    attribute: 1,
		    pseudo: 0,
		    "pseudo-element": 0,
		    "column-combinator": -1,
		    descendant: -1,
		    child: -1,
		    parent: -1,
		    sibling: -1,
		    adjacent: -1,
		    _flexibleDescendant: -1,
		};
		function isTraversal(t) {
		    return exports.procedure[t.type] < 0;
		}
		exports.isTraversal = isTraversal; 
	} (procedure));
	return procedure;
}

var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort;
	hasRequiredSort = 1;
	Object.defineProperty(sort, "__esModule", { value: true });
	var css_what_1 = require$$0$1;
	var procedure_1 = requireProcedure();
	var attributes = {
	    exists: 10,
	    equals: 8,
	    not: 7,
	    start: 6,
	    end: 6,
	    any: 5,
	    hyphen: 4,
	    element: 4,
	};
	/**
	 * Sort the parts of the passed selector,
	 * as there is potential for optimization
	 * (some types of selectors are faster than others)
	 *
	 * @param arr Selector to sort
	 */
	function sortByProcedure(arr) {
	    var procs = arr.map(getProcedure);
	    for (var i = 1; i < arr.length; i++) {
	        var procNew = procs[i];
	        if (procNew < 0)
	            continue;
	        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
	            var token = arr[j + 1];
	            arr[j + 1] = arr[j];
	            arr[j] = token;
	            procs[j + 1] = procs[j];
	            procs[j] = procNew;
	        }
	    }
	}
	sort.default = sortByProcedure;
	function getProcedure(token) {
	    var proc = procedure_1.procedure[token.type];
	    if (token.type === css_what_1.SelectorType.Attribute) {
	        proc = attributes[token.action];
	        if (proc === attributes.equals && token.name === "id") {
	            // Prefer ID selectors (eg. #ID)
	            proc = 9;
	        }
	        if (token.ignoreCase) {
	            /*
	             * IgnoreCase adds some overhead, prefer "normal" token
	             * this is a binary operation, to ensure it's still an int
	             */
	            proc >>= 1;
	        }
	    }
	    else if (token.type === css_what_1.SelectorType.Pseudo) {
	        if (!token.data) {
	            proc = 3;
	        }
	        else if (token.name === "has" || token.name === "contains") {
	            proc = 0; // Expensive in any case
	        }
	        else if (Array.isArray(token.data)) {
	            // "matches" and "not"
	            proc = 0;
	            for (var i = 0; i < token.data.length; i++) {
	                // TODO better handling of complex selectors
	                if (token.data[i].length !== 1)
	                    continue;
	                var cur = getProcedure(token.data[i][0]);
	                // Avoid executing :has or :contains
	                if (cur === 0) {
	                    proc = 0;
	                    break;
	                }
	                if (cur > proc)
	                    proc = cur;
	            }
	            if (token.data.length > 1 && proc > 0)
	                proc -= 1;
	        }
	        else {
	            proc = 1;
	        }
	    }
	    return proc;
	}
	return sort;
}

var general = {};

var attributes = {};

var hasRequiredAttributes;

function requireAttributes () {
	if (hasRequiredAttributes) return attributes;
	hasRequiredAttributes = 1;
	Object.defineProperty(attributes, "__esModule", { value: true });
	attributes.attributeRules = void 0;
	var boolbase_1 = requireBoolbase();
	/**
	 * All reserved characters in a regex, used for escaping.
	 *
	 * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
	 * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
	 */
	var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
	function escapeRegex(value) {
	    return value.replace(reChars, "\\$&");
	}
	/**
	 * Attributes that are case-insensitive in HTML.
	 *
	 * @private
	 * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
	 */
	var caseInsensitiveAttributes = new Set([
	    "accept",
	    "accept-charset",
	    "align",
	    "alink",
	    "axis",
	    "bgcolor",
	    "charset",
	    "checked",
	    "clear",
	    "codetype",
	    "color",
	    "compact",
	    "declare",
	    "defer",
	    "dir",
	    "direction",
	    "disabled",
	    "enctype",
	    "face",
	    "frame",
	    "hreflang",
	    "http-equiv",
	    "lang",
	    "language",
	    "link",
	    "media",
	    "method",
	    "multiple",
	    "nohref",
	    "noresize",
	    "noshade",
	    "nowrap",
	    "readonly",
	    "rel",
	    "rev",
	    "rules",
	    "scope",
	    "scrolling",
	    "selected",
	    "shape",
	    "target",
	    "text",
	    "type",
	    "valign",
	    "valuetype",
	    "vlink",
	]);
	function shouldIgnoreCase(selector, options) {
	    return typeof selector.ignoreCase === "boolean"
	        ? selector.ignoreCase
	        : selector.ignoreCase === "quirks"
	            ? !!options.quirksMode
	            : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
	}
	/**
	 * Attribute selectors
	 */
	attributes.attributeRules = {
	    equals: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length === value.length &&
	                    attr.toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            return adapter.getAttributeValue(elem, name) === value && next(elem);
	        };
	    },
	    hyphen: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = value.length;
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function hyphenIC(elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    (attr.length === len || attr.charAt(len) === "-") &&
	                    attr.substr(0, len).toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function hyphen(elem) {
	            var attr = adapter.getAttributeValue(elem, name);
	            return (attr != null &&
	                (attr.length === len || attr.charAt(len) === "-") &&
	                attr.substr(0, len) === value &&
	                next(elem));
	        };
	    },
	    element: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name, value = data.value;
	        if (/\s/.test(value)) {
	            return boolbase_1.falseFunc;
	        }
	        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
	        return function element(elem) {
	            var attr = adapter.getAttributeValue(elem, name);
	            return (attr != null &&
	                attr.length >= value.length &&
	                regex.test(attr) &&
	                next(elem));
	        };
	    },
	    exists: function (next, _a, _b) {
	        var name = _a.name;
	        var adapter = _b.adapter;
	        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };
	    },
	    start: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = value.length;
	        if (len === 0) {
	            return boolbase_1.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length >= len &&
	                    attr.substr(0, len).toLowerCase() === value &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
	                next(elem);
	        };
	    },
	    end: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        var len = -value.length;
	        if (len === 0) {
	            return boolbase_1.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var _a;
	                return ((_a = adapter
	                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
	                next(elem);
	        };
	    },
	    any: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name, value = data.value;
	        if (value === "") {
	            return boolbase_1.falseFunc;
	        }
	        if (shouldIgnoreCase(data, options)) {
	            var regex_1 = new RegExp(escapeRegex(value), "i");
	            return function anyIC(elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return (attr != null &&
	                    attr.length >= value.length &&
	                    regex_1.test(attr) &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            var _a;
	            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
	                next(elem);
	        };
	    },
	    not: function (next, data, options) {
	        var adapter = options.adapter;
	        var name = data.name;
	        var value = data.value;
	        if (value === "") {
	            return function (elem) {
	                return !!adapter.getAttributeValue(elem, name) && next(elem);
	            };
	        }
	        else if (shouldIgnoreCase(data, options)) {
	            value = value.toLowerCase();
	            return function (elem) {
	                var attr = adapter.getAttributeValue(elem, name);
	                return ((attr == null ||
	                    attr.length !== value.length ||
	                    attr.toLowerCase() !== value) &&
	                    next(elem));
	            };
	        }
	        return function (elem) {
	            return adapter.getAttributeValue(elem, name) !== value && next(elem);
	        };
	    },
	};
	return attributes;
}

var pseudoSelectors = {};

var filters = {};

var lib$2 = {};

var parse = {};

var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse;
	hasRequiredParse$1 = 1;
	// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
	Object.defineProperty(parse, "__esModule", { value: true });
	parse.parse = void 0;
	// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
	var whitespace = new Set([9, 10, 12, 13, 32]);
	var ZERO = "0".charCodeAt(0);
	var NINE = "9".charCodeAt(0);
	/**
	 * Parses an expression.
	 *
	 * @throws An `Error` if parsing fails.
	 * @returns An array containing the integer step size and the integer offset of the nth rule.
	 * @example nthCheck.parse("2n+3"); // returns [2, 3]
	 */
	function parse$1(formula) {
	    formula = formula.trim().toLowerCase();
	    if (formula === "even") {
	        return [2, 0];
	    }
	    else if (formula === "odd") {
	        return [2, 1];
	    }
	    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
	    var idx = 0;
	    var a = 0;
	    var sign = readSign();
	    var number = readNumber();
	    if (idx < formula.length && formula.charAt(idx) === "n") {
	        idx++;
	        a = sign * (number !== null && number !== void 0 ? number : 1);
	        skipWhitespace();
	        if (idx < formula.length) {
	            sign = readSign();
	            skipWhitespace();
	            number = readNumber();
	        }
	        else {
	            sign = number = 0;
	        }
	    }
	    // Throw if there is anything else
	    if (number === null || idx < formula.length) {
	        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
	    }
	    return [a, sign * number];
	    function readSign() {
	        if (formula.charAt(idx) === "-") {
	            idx++;
	            return -1;
	        }
	        if (formula.charAt(idx) === "+") {
	            idx++;
	        }
	        return 1;
	    }
	    function readNumber() {
	        var start = idx;
	        var value = 0;
	        while (idx < formula.length &&
	            formula.charCodeAt(idx) >= ZERO &&
	            formula.charCodeAt(idx) <= NINE) {
	            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
	            idx++;
	        }
	        // Return `null` if we didn't read anything.
	        return idx === start ? null : value;
	    }
	    function skipWhitespace() {
	        while (idx < formula.length &&
	            whitespace.has(formula.charCodeAt(idx))) {
	            idx++;
	        }
	    }
	}
	parse.parse = parse$1;
	
	return parse;
}

var compile = {};

var hasRequiredCompile$1;

function requireCompile$1 () {
	if (hasRequiredCompile$1) return compile;
	hasRequiredCompile$1 = 1;
	var __importDefault = (compile && compile.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.generate = compile.compile = void 0;
	var boolbase_1 = __importDefault(requireBoolbase());
	/**
	 * Returns a function that checks if an elements index matches the given rule
	 * highly optimized to return the fastest solution.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A highly optimized function that returns whether an index matches the nth-check.
	 * @example
	 *
	 * ```js
	 * const check = nthCheck.compile([2, 3]);
	 *
	 * check(0); // `false`
	 * check(1); // `false`
	 * check(2); // `true`
	 * check(3); // `false`
	 * check(4); // `true`
	 * check(5); // `false`
	 * check(6); // `true`
	 * ```
	 */
	function compile$1(parsed) {
	    var a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    var b = parsed[1] - 1;
	    /*
	     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
	     * Besides, the specification states that no elements are
	     * matched when `a` and `b` are 0.
	     *
	     * `b < 0` here as we subtracted 1 from `b` above.
	     */
	    if (b < 0 && a <= 0)
	        return boolbase_1.default.falseFunc;
	    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
	    if (a === -1)
	        return function (index) { return index <= b; };
	    if (a === 0)
	        return function (index) { return index === b; };
	    // When `b <= 0` and `a === 1`, they match any element.
	    if (a === 1)
	        return b < 0 ? boolbase_1.default.trueFunc : function (index) { return index >= b; };
	    /*
	     * Otherwise, modulo can be used to check if there is a match.
	     *
	     * Modulo doesn't care about the sign, so let's use `a`s absolute value.
	     */
	    var absA = Math.abs(a);
	    // Get `b mod a`, + a if this is negative.
	    var bMod = ((b % absA) + absA) % absA;
	    return a > 1
	        ? function (index) { return index >= b && index % absA === bMod; }
	        : function (index) { return index <= b && index % absA === bMod; };
	}
	compile.compile = compile$1;
	/**
	 * Returns a function that produces a monotonously increasing sequence of indices.
	 *
	 * If the sequence has an end, the returned function will return `null` after
	 * the last index in the sequence.
	 *
	 * @param parsed A tuple [a, b], as returned by `parse`.
	 * @returns A function that produces a sequence of indices.
	 * @example <caption>Always increasing (2n+3)</caption>
	 *
	 * ```js
	 * const gen = nthCheck.generate([2, 3])
	 *
	 * gen() // `1`
	 * gen() // `3`
	 * gen() // `5`
	 * gen() // `8`
	 * gen() // `11`
	 * ```
	 *
	 * @example <caption>With end value (-2n+10)</caption>
	 *
	 * ```js
	 *
	 * const gen = nthCheck.generate([-2, 5]);
	 *
	 * gen() // 0
	 * gen() // 2
	 * gen() // 4
	 * gen() // null
	 * ```
	 */
	function generate(parsed) {
	    var a = parsed[0];
	    // Subtract 1 from `b`, to convert from one- to zero-indexed.
	    var b = parsed[1] - 1;
	    var n = 0;
	    // Make sure to always return an increasing sequence
	    if (a < 0) {
	        var aPos_1 = -a;
	        // Get `b mod a`
	        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;
	        return function () {
	            var val = minValue_1 + aPos_1 * n++;
	            return val > b ? null : val;
	        };
	    }
	    if (a === 0)
	        return b < 0
	            ? // There are no result â€” always return `null`
	                function () { return null; }
	            : // Return `b` exactly once
	                function () { return (n++ === 0 ? b : null); };
	    if (b < 0) {
	        b += a * Math.ceil(-b / a);
	    }
	    return function () { return a * n++ + b; };
	}
	compile.generate = generate;
	
	return compile;
}

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$2;
	hasRequiredLib$3 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
		var parse_js_1 = /*@__PURE__*/ requireParse$1();
		Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parse_js_1.parse; } });
		var compile_js_1 = /*@__PURE__*/ requireCompile$1();
		Object.defineProperty(exports, "compile", { enumerable: true, get: function () { return compile_js_1.compile; } });
		Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return compile_js_1.generate; } });
		/**
		 * Parses and compiles a formula to a highly optimized function.
		 * Combination of {@link parse} and {@link compile}.
		 *
		 * If the formula doesn't match any elements,
		 * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
		 * Otherwise, a function accepting an _index_ is returned, which returns
		 * whether or not the passed _index_ matches the formula.
		 *
		 * Note: The nth-rule starts counting at `1`, the returned function at `0`.
		 *
		 * @param formula The formula to compile.
		 * @example
		 * const check = nthCheck("2n+3");
		 *
		 * check(0); // `false`
		 * check(1); // `false`
		 * check(2); // `true`
		 * check(3); // `false`
		 * check(4); // `true`
		 * check(5); // `false`
		 * check(6); // `true`
		 */
		function nthCheck(formula) {
		    return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
		}
		exports.default = nthCheck;
		/**
		 * Parses and compiles a formula to a generator that produces a sequence of indices.
		 * Combination of {@link parse} and {@link generate}.
		 *
		 * @param formula The formula to compile.
		 * @returns A function that produces a sequence of indices.
		 * @example <caption>Always increasing</caption>
		 *
		 * ```js
		 * const gen = nthCheck.sequence('2n+3')
		 *
		 * gen() // `1`
		 * gen() // `3`
		 * gen() // `5`
		 * gen() // `8`
		 * gen() // `11`
		 * ```
		 *
		 * @example <caption>With end value</caption>
		 *
		 * ```js
		 *
		 * const gen = nthCheck.sequence('-2n+5');
		 *
		 * gen() // 0
		 * gen() // 2
		 * gen() // 4
		 * gen() // null
		 * ```
		 */
		function sequence(formula) {
		    return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
		}
		exports.sequence = sequence;
		
	} (lib$2));
	return lib$2;
}

var hasRequiredFilters;

function requireFilters () {
	if (hasRequiredFilters) return filters;
	hasRequiredFilters = 1;
	(function (exports) {
		var __importDefault = (filters && filters.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.filters = void 0;
		var nth_check_1 = __importDefault(/*@__PURE__*/ requireLib$3());
		var boolbase_1 = requireBoolbase();
		function getChildFunc(next, adapter) {
		    return function (elem) {
		        var parent = adapter.getParent(elem);
		        return parent != null && adapter.isTag(parent) && next(elem);
		    };
		}
		exports.filters = {
		    contains: function (next, text, _a) {
		        var adapter = _a.adapter;
		        return function contains(elem) {
		            return next(elem) && adapter.getText(elem).includes(text);
		        };
		    },
		    icontains: function (next, text, _a) {
		        var adapter = _a.adapter;
		        var itext = text.toLowerCase();
		        return function icontains(elem) {
		            return (next(elem) &&
		                adapter.getText(elem).toLowerCase().includes(itext));
		        };
		    },
		    // Location specific methods
		    "nth-child": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthChild(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = 0; i < siblings.length; i++) {
		                if (equals(elem, siblings[i]))
		                    break;
		                if (adapter.isTag(siblings[i])) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-last-child": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthLastChild(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = siblings.length - 1; i >= 0; i--) {
		                if (equals(elem, siblings[i]))
		                    break;
		                if (adapter.isTag(siblings[i])) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-of-type": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthOfType(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = 0; i < siblings.length; i++) {
		                var currentSibling = siblings[i];
		                if (equals(elem, currentSibling))
		                    break;
		                if (adapter.isTag(currentSibling) &&
		                    adapter.getName(currentSibling) === adapter.getName(elem)) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    "nth-last-of-type": function (next, rule, _a) {
		        var adapter = _a.adapter, equals = _a.equals;
		        var func = (0, nth_check_1.default)(rule);
		        if (func === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (func === boolbase_1.trueFunc)
		            return getChildFunc(next, adapter);
		        return function nthLastOfType(elem) {
		            var siblings = adapter.getSiblings(elem);
		            var pos = 0;
		            for (var i = siblings.length - 1; i >= 0; i--) {
		                var currentSibling = siblings[i];
		                if (equals(elem, currentSibling))
		                    break;
		                if (adapter.isTag(currentSibling) &&
		                    adapter.getName(currentSibling) === adapter.getName(elem)) {
		                    pos++;
		                }
		            }
		            return func(pos) && next(elem);
		        };
		    },
		    // TODO determine the actual root element
		    root: function (next, _rule, _a) {
		        var adapter = _a.adapter;
		        return function (elem) {
		            var parent = adapter.getParent(elem);
		            return (parent == null || !adapter.isTag(parent)) && next(elem);
		        };
		    },
		    scope: function (next, rule, options, context) {
		        var equals = options.equals;
		        if (!context || context.length === 0) {
		            // Equivalent to :root
		            return exports.filters.root(next, rule, options);
		        }
		        if (context.length === 1) {
		            // NOTE: can't be unpacked, as :has uses this for side-effects
		            return function (elem) { return equals(context[0], elem) && next(elem); };
		        }
		        return function (elem) { return context.includes(elem) && next(elem); };
		    },
		    hover: dynamicStatePseudo("isHovered"),
		    visited: dynamicStatePseudo("isVisited"),
		    active: dynamicStatePseudo("isActive"),
		};
		/**
		 * Dynamic state pseudos. These depend on optional Adapter methods.
		 *
		 * @param name The name of the adapter method to call.
		 * @returns Pseudo for the `filters` object.
		 */
		function dynamicStatePseudo(name) {
		    return function dynamicPseudo(next, _rule, _a) {
		        var adapter = _a.adapter;
		        var func = adapter[name];
		        if (typeof func !== "function") {
		            return boolbase_1.falseFunc;
		        }
		        return function active(elem) {
		            return func(elem) && next(elem);
		        };
		    };
		} 
	} (filters));
	return filters;
}

var pseudos = {};

var hasRequiredPseudos;

function requirePseudos () {
	if (hasRequiredPseudos) return pseudos;
	hasRequiredPseudos = 1;
	Object.defineProperty(pseudos, "__esModule", { value: true });
	pseudos.verifyPseudoArgs = pseudos.pseudos = void 0;
	// While filters are precompiled, pseudos get called when they are needed
	pseudos.pseudos = {
	    empty: function (elem, _a) {
	        var adapter = _a.adapter;
	        return !adapter.getChildren(elem).some(function (elem) {
	            // FIXME: `getText` call is potentially expensive.
	            return adapter.isTag(elem) || adapter.getText(elem) !== "";
	        });
	    },
	    "first-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var firstChild = adapter
	            .getSiblings(elem)
	            .find(function (elem) { return adapter.isTag(elem); });
	        return firstChild != null && equals(elem, firstChild);
	    },
	    "last-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        for (var i = siblings.length - 1; i >= 0; i--) {
	            if (equals(elem, siblings[i]))
	                return true;
	            if (adapter.isTag(siblings[i]))
	                break;
	        }
	        return false;
	    },
	    "first-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        var elemName = adapter.getName(elem);
	        for (var i = 0; i < siblings.length; i++) {
	            var currentSibling = siblings[i];
	            if (equals(elem, currentSibling))
	                return true;
	            if (adapter.isTag(currentSibling) &&
	                adapter.getName(currentSibling) === elemName) {
	                break;
	            }
	        }
	        return false;
	    },
	    "last-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var siblings = adapter.getSiblings(elem);
	        var elemName = adapter.getName(elem);
	        for (var i = siblings.length - 1; i >= 0; i--) {
	            var currentSibling = siblings[i];
	            if (equals(elem, currentSibling))
	                return true;
	            if (adapter.isTag(currentSibling) &&
	                adapter.getName(currentSibling) === elemName) {
	                break;
	            }
	        }
	        return false;
	    },
	    "only-of-type": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        var elemName = adapter.getName(elem);
	        return adapter
	            .getSiblings(elem)
	            .every(function (sibling) {
	            return equals(elem, sibling) ||
	                !adapter.isTag(sibling) ||
	                adapter.getName(sibling) !== elemName;
	        });
	    },
	    "only-child": function (elem, _a) {
	        var adapter = _a.adapter, equals = _a.equals;
	        return adapter
	            .getSiblings(elem)
	            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });
	    },
	};
	function verifyPseudoArgs(func, name, subselect) {
	    if (subselect === null) {
	        if (func.length > 2) {
	            throw new Error("pseudo-selector :".concat(name, " requires an argument"));
	        }
	    }
	    else if (func.length === 2) {
	        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
	    }
	}
	pseudos.verifyPseudoArgs = verifyPseudoArgs;
	return pseudos;
}

var aliases = {};

var hasRequiredAliases;

function requireAliases () {
	if (hasRequiredAliases) return aliases;
	hasRequiredAliases = 1;
	Object.defineProperty(aliases, "__esModule", { value: true });
	aliases.aliases = void 0;
	/**
	 * Aliases are pseudos that are expressed as selectors.
	 */
	aliases.aliases = {
	    // Links
	    "any-link": ":is(a, area, link)[href]",
	    link: ":any-link:not(:visited)",
	    // Forms
	    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
	    disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
	    enabled: ":not(:disabled)",
	    checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
	    required: ":is(input, select, textarea)[required]",
	    optional: ":is(input, select, textarea):not([required])",
	    // JQuery extensions
	    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
	    selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
	    checkbox: "[type=checkbox]",
	    file: "[type=file]",
	    password: "[type=password]",
	    radio: "[type=radio]",
	    reset: "[type=reset]",
	    image: "[type=image]",
	    submit: "[type=submit]",
	    parent: ":not(:empty)",
	    header: ":is(h1, h2, h3, h4, h5, h6)",
	    button: ":is(button, input[type=button])",
	    input: ":is(input, textarea, select, button)",
	    text: "input:is(:not([type!='']), [type=text])",
	};
	return aliases;
}

var subselects = {};

var hasRequiredSubselects;

function requireSubselects () {
	if (hasRequiredSubselects) return subselects;
	hasRequiredSubselects = 1;
	(function (exports) {
		var __spreadArray = (subselects && subselects.__spreadArray) || function (to, from, pack) {
		    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		        if (ar || !(i in from)) {
		            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		            ar[i] = from[i];
		        }
		    }
		    return to.concat(ar || Array.prototype.slice.call(from));
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
		var boolbase_1 = requireBoolbase();
		var procedure_1 = requireProcedure();
		/** Used as a placeholder for :has. Will be replaced with the actual element. */
		exports.PLACEHOLDER_ELEMENT = {};
		function ensureIsTag(next, adapter) {
		    if (next === boolbase_1.falseFunc)
		        return boolbase_1.falseFunc;
		    return function (elem) { return adapter.isTag(elem) && next(elem); };
		}
		exports.ensureIsTag = ensureIsTag;
		function getNextSiblings(elem, adapter) {
		    var siblings = adapter.getSiblings(elem);
		    if (siblings.length <= 1)
		        return [];
		    var elemIndex = siblings.indexOf(elem);
		    if (elemIndex < 0 || elemIndex === siblings.length - 1)
		        return [];
		    return siblings.slice(elemIndex + 1).filter(adapter.isTag);
		}
		exports.getNextSiblings = getNextSiblings;
		var is = function (next, token, options, context, compileToken) {
		    var opts = {
		        xmlMode: !!options.xmlMode,
		        adapter: options.adapter,
		        equals: options.equals,
		    };
		    var func = compileToken(token, opts, context);
		    return function (elem) { return func(elem) && next(elem); };
		};
		/*
		 * :not, :has, :is, :matches and :where have to compile selectors
		 * doing this in src/pseudos.ts would lead to circular dependencies,
		 * so we add them here
		 */
		exports.subselects = {
		    is: is,
		    /**
		     * `:matches` and `:where` are aliases for `:is`.
		     */
		    matches: is,
		    where: is,
		    not: function (next, token, options, context, compileToken) {
		        var opts = {
		            xmlMode: !!options.xmlMode,
		            adapter: options.adapter,
		            equals: options.equals,
		        };
		        var func = compileToken(token, opts, context);
		        if (func === boolbase_1.falseFunc)
		            return next;
		        if (func === boolbase_1.trueFunc)
		            return boolbase_1.falseFunc;
		        return function not(elem) {
		            return !func(elem) && next(elem);
		        };
		    },
		    has: function (next, subselect, options, _context, compileToken) {
		        var adapter = options.adapter;
		        var opts = {
		            xmlMode: !!options.xmlMode,
		            adapter: adapter,
		            equals: options.equals,
		        };
		        // @ts-expect-error Uses an array as a pointer to the current element (side effects)
		        var context = subselect.some(function (s) {
		            return s.some(procedure_1.isTraversal);
		        })
		            ? [exports.PLACEHOLDER_ELEMENT]
		            : undefined;
		        var compiled = compileToken(subselect, opts, context);
		        if (compiled === boolbase_1.falseFunc)
		            return boolbase_1.falseFunc;
		        if (compiled === boolbase_1.trueFunc) {
		            return function (elem) {
		                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
		            };
		        }
		        var hasElement = ensureIsTag(compiled, adapter);
		        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
		        /*
		         * `shouldTestNextSiblings` will only be true if the query starts with
		         * a traversal (sibling or adjacent). That means we will always have a context.
		         */
		        if (context) {
		            return function (elem) {
		                context[0] = elem;
		                var childs = adapter.getChildren(elem);
		                var nextElements = shouldTestNextSiblings
		                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
		                return (next(elem) && adapter.existsOne(hasElement, nextElements));
		            };
		        }
		        return function (elem) {
		            return next(elem) &&
		                adapter.existsOne(hasElement, adapter.getChildren(elem));
		        };
		    },
		}; 
	} (subselects));
	return subselects;
}

var hasRequiredPseudoSelectors;

function requirePseudoSelectors () {
	if (hasRequiredPseudoSelectors) return pseudoSelectors;
	hasRequiredPseudoSelectors = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
		/*
		 * Pseudo selectors
		 *
		 * Pseudo selectors are available in three forms:
		 *
		 * 1. Filters are called when the selector is compiled and return a function
		 *  that has to return either false, or the results of `next()`.
		 * 2. Pseudos are called on execution. They have to return a boolean.
		 * 3. Subselects work like filters, but have an embedded selector that will be run separately.
		 *
		 * Filters are great if you want to do some pre-processing, or change the call order
		 * of `next()` and your code.
		 * Pseudos should be used to implement simple checks.
		 */
		var boolbase_1 = requireBoolbase();
		var css_what_1 = require$$0$1;
		var filters_1 = requireFilters();
		Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return filters_1.filters; } });
		var pseudos_1 = requirePseudos();
		Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudos_1.pseudos; } });
		var aliases_1 = requireAliases();
		Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return aliases_1.aliases; } });
		var subselects_1 = requireSubselects();
		function compilePseudoSelector(next, selector, options, context, compileToken) {
		    var name = selector.name, data = selector.data;
		    if (Array.isArray(data)) {
		        return subselects_1.subselects[name](next, data, options, context, compileToken);
		    }
		    if (name in aliases_1.aliases) {
		        if (data != null) {
		            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
		        }
		        // The alias has to be parsed here, to make sure options are respected.
		        var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
		        return subselects_1.subselects.is(next, alias, options, context, compileToken);
		    }
		    if (name in filters_1.filters) {
		        return filters_1.filters[name](next, data, options, context);
		    }
		    if (name in pseudos_1.pseudos) {
		        var pseudo_1 = pseudos_1.pseudos[name];
		        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
		        return pseudo_1 === boolbase_1.falseFunc
		            ? boolbase_1.falseFunc
		            : next === boolbase_1.trueFunc
		                ? function (elem) { return pseudo_1(elem, options, data); }
		                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };
		    }
		    throw new Error("unmatched pseudo-class :".concat(name));
		}
		exports.compilePseudoSelector = compilePseudoSelector; 
	} (pseudoSelectors));
	return pseudoSelectors;
}

var hasRequiredGeneral;

function requireGeneral () {
	if (hasRequiredGeneral) return general;
	hasRequiredGeneral = 1;
	Object.defineProperty(general, "__esModule", { value: true });
	general.compileGeneralSelector = void 0;
	var attributes_1 = requireAttributes();
	var pseudo_selectors_1 = requirePseudoSelectors();
	var css_what_1 = require$$0$1;
	/*
	 * All available rules
	 */
	function compileGeneralSelector(next, selector, options, context, compileToken) {
	    var adapter = options.adapter, equals = options.equals;
	    switch (selector.type) {
	        case css_what_1.SelectorType.PseudoElement: {
	            throw new Error("Pseudo-elements are not supported by css-select");
	        }
	        case css_what_1.SelectorType.ColumnCombinator: {
	            throw new Error("Column combinators are not yet supported by css-select");
	        }
	        case css_what_1.SelectorType.Attribute: {
	            if (selector.namespace != null) {
	                throw new Error("Namespaced attributes are not yet supported by css-select");
	            }
	            if (!options.xmlMode || options.lowerCaseAttributeNames) {
	                selector.name = selector.name.toLowerCase();
	            }
	            return attributes_1.attributeRules[selector.action](next, selector, options);
	        }
	        case css_what_1.SelectorType.Pseudo: {
	            return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
	        }
	        // Tags
	        case css_what_1.SelectorType.Tag: {
	            if (selector.namespace != null) {
	                throw new Error("Namespaced tag names are not yet supported by css-select");
	            }
	            var name_1 = selector.name;
	            if (!options.xmlMode || options.lowerCaseTags) {
	                name_1 = name_1.toLowerCase();
	            }
	            return function tag(elem) {
	                return adapter.getName(elem) === name_1 && next(elem);
	            };
	        }
	        // Traversal
	        case css_what_1.SelectorType.Descendant: {
	            if (options.cacheResults === false ||
	                typeof WeakSet === "undefined") {
	                return function descendant(elem) {
	                    var current = elem;
	                    while ((current = adapter.getParent(current))) {
	                        if (adapter.isTag(current) && next(current)) {
	                            return true;
	                        }
	                    }
	                    return false;
	                };
	            }
	            // @ts-expect-error `ElementNode` is not extending object
	            var isFalseCache_1 = new WeakSet();
	            return function cachedDescendant(elem) {
	                var current = elem;
	                while ((current = adapter.getParent(current))) {
	                    if (!isFalseCache_1.has(current)) {
	                        if (adapter.isTag(current) && next(current)) {
	                            return true;
	                        }
	                        isFalseCache_1.add(current);
	                    }
	                }
	                return false;
	            };
	        }
	        case "_flexibleDescendant": {
	            // Include element itself, only used while querying an array
	            return function flexibleDescendant(elem) {
	                var current = elem;
	                do {
	                    if (adapter.isTag(current) && next(current))
	                        return true;
	                } while ((current = adapter.getParent(current)));
	                return false;
	            };
	        }
	        case css_what_1.SelectorType.Parent: {
	            return function parent(elem) {
	                return adapter
	                    .getChildren(elem)
	                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });
	            };
	        }
	        case css_what_1.SelectorType.Child: {
	            return function child(elem) {
	                var parent = adapter.getParent(elem);
	                return parent != null && adapter.isTag(parent) && next(parent);
	            };
	        }
	        case css_what_1.SelectorType.Sibling: {
	            return function sibling(elem) {
	                var siblings = adapter.getSiblings(elem);
	                for (var i = 0; i < siblings.length; i++) {
	                    var currentSibling = siblings[i];
	                    if (equals(elem, currentSibling))
	                        break;
	                    if (adapter.isTag(currentSibling) && next(currentSibling)) {
	                        return true;
	                    }
	                }
	                return false;
	            };
	        }
	        case css_what_1.SelectorType.Adjacent: {
	            if (adapter.prevElementSibling) {
	                return function adjacent(elem) {
	                    var previous = adapter.prevElementSibling(elem);
	                    return previous != null && next(previous);
	                };
	            }
	            return function adjacent(elem) {
	                var siblings = adapter.getSiblings(elem);
	                var lastElement;
	                for (var i = 0; i < siblings.length; i++) {
	                    var currentSibling = siblings[i];
	                    if (equals(elem, currentSibling))
	                        break;
	                    if (adapter.isTag(currentSibling)) {
	                        lastElement = currentSibling;
	                    }
	                }
	                return !!lastElement && next(lastElement);
	            };
	        }
	        case css_what_1.SelectorType.Universal: {
	            if (selector.namespace != null && selector.namespace !== "*") {
	                throw new Error("Namespaced universal selectors are not yet supported by css-select");
	            }
	            return next;
	        }
	    }
	}
	general.compileGeneralSelector = compileGeneralSelector;
	return general;
}

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile$1;
	hasRequiredCompile = 1;
	var __importDefault = (compile$1 && compile$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(compile$1, "__esModule", { value: true });
	compile$1.compileToken = compile$1.compileUnsafe = compile$1.compile = void 0;
	var css_what_1 = require$$0$1;
	var boolbase_1 = requireBoolbase();
	var sort_1 = __importDefault(requireSort());
	var procedure_1 = requireProcedure();
	var general_1 = requireGeneral();
	var subselects_1 = requireSubselects();
	/**
	 * Compiles a selector to an executable function.
	 *
	 * @param selector Selector to compile.
	 * @param options Compilation options.
	 * @param context Optional context for the selector.
	 */
	function compile(selector, options, context) {
	    var next = compileUnsafe(selector, options, context);
	    return (0, subselects_1.ensureIsTag)(next, options.adapter);
	}
	compile$1.compile = compile;
	function compileUnsafe(selector, options, context) {
	    var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
	    return compileToken(token, options, context);
	}
	compile$1.compileUnsafe = compileUnsafe;
	function includesScopePseudo(t) {
	    return (t.type === "pseudo" &&
	        (t.name === "scope" ||
	            (Array.isArray(t.data) &&
	                t.data.some(function (data) { return data.some(includesScopePseudo); }))));
	}
	var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
	var FLEXIBLE_DESCENDANT_TOKEN = {
	    type: "_flexibleDescendant",
	};
	var SCOPE_TOKEN = {
	    type: css_what_1.SelectorType.Pseudo,
	    name: "scope",
	    data: null,
	};
	/*
	 * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector
	 * http://www.w3.org/TR/selectors4/#absolutizing
	 */
	function absolutize(token, _a, context) {
	    var adapter = _a.adapter;
	    // TODO Use better check if the context is a document
	    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {
	        var parent = adapter.isTag(e) && adapter.getParent(e);
	        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
	    }));
	    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
	        var t = token_1[_i];
	        if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") ;
	        else if (hasContext && !t.some(includesScopePseudo)) {
	            t.unshift(DESCENDANT_TOKEN);
	        }
	        else {
	            continue;
	        }
	        t.unshift(SCOPE_TOKEN);
	    }
	}
	function compileToken(token, options, context) {
	    var _a;
	    token = token.filter(function (t) { return t.length > 0; });
	    token.forEach(sort_1.default);
	    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
	    var isArrayContext = Array.isArray(context);
	    var finalContext = context && (Array.isArray(context) ? context : [context]);
	    absolutize(token, options, finalContext);
	    var shouldTestNextSiblings = false;
	    var query = token
	        .map(function (rules) {
	        if (rules.length >= 2) {
	            var first = rules[0], second = rules[1];
	            if (first.type !== "pseudo" || first.name !== "scope") ;
	            else if (isArrayContext && second.type === "descendant") {
	                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
	            }
	            else if (second.type === "adjacent" ||
	                second.type === "sibling") {
	                shouldTestNextSiblings = true;
	            }
	        }
	        return compileRules(rules, options, finalContext);
	    })
	        .reduce(reduceRules, boolbase_1.falseFunc);
	    query.shouldTestNextSiblings = shouldTestNextSiblings;
	    return query;
	}
	compile$1.compileToken = compileToken;
	function compileRules(rules, options, context) {
	    var _a;
	    return rules.reduce(function (previous, rule) {
	        return previous === boolbase_1.falseFunc
	            ? boolbase_1.falseFunc
	            : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
	    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
	}
	function reduceRules(a, b) {
	    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
	        return a;
	    }
	    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
	        return b;
	    }
	    return function combine(elem) {
	        return a(elem) || b(elem);
	    };
	}
	return compile$1;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$8;
	hasRequiredLib$2 = 1;
	(function (exports) {
		var __createBinding = (lib$8 && lib$8.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$8 && lib$8.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (lib$8 && lib$8.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
		var DomUtils = __importStar(/*@__PURE__*/ requireLib$4());
		var boolbase_1 = requireBoolbase();
		var compile_1 = requireCompile();
		var subselects_1 = requireSubselects();
		var defaultEquals = function (a, b) { return a === b; };
		var defaultOptions = {
		    adapter: DomUtils,
		    equals: defaultEquals,
		};
		function convertOptionFormats(options) {
		    var _a, _b, _c, _d;
		    /*
		     * We force one format of options to the other one.
		     */
		    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
		    var opts = options !== null && options !== void 0 ? options : defaultOptions;
		    // @ts-expect-error Same as above.
		    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
		    // @ts-expect-error `equals` does not exist on `Options`
		    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
		    return opts;
		}
		function wrapCompile(func) {
		    return function addAdapter(selector, options, context) {
		        var opts = convertOptionFormats(options);
		        return func(selector, opts, context);
		    };
		}
		/**
		 * Compiles the query, returns a function.
		 */
		exports.compile = wrapCompile(compile_1.compile);
		exports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
		exports._compileToken = wrapCompile(compile_1.compileToken);
		function getSelectorFunc(searchFunc) {
		    return function select(query, elements, options) {
		        var opts = convertOptionFormats(options);
		        if (typeof query !== "function") {
		            query = (0, compile_1.compileUnsafe)(query, opts, elements);
		        }
		        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
		        return searchFunc(query, filteredElements, opts);
		    };
		}
		function prepareContext(elems, adapter, shouldTestNextSiblings) {
		    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }
		    /*
		     * Add siblings if the query requires them.
		     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
		     */
		    if (shouldTestNextSiblings) {
		        elems = appendNextSiblings(elems, adapter);
		    }
		    return Array.isArray(elems)
		        ? adapter.removeSubsets(elems)
		        : adapter.getChildren(elems);
		}
		exports.prepareContext = prepareContext;
		function appendNextSiblings(elem, adapter) {
		    // Order matters because jQuery seems to check the children before the siblings
		    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
		    var elemsLength = elems.length;
		    for (var i = 0; i < elemsLength; i++) {
		        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
		        elems.push.apply(elems, nextSiblings);
		    }
		    return elems;
		}
		/**
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elems Elements to query. If it is an element, its children will be queried..
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns All matching elements.
		 *
		 */
		exports.selectAll = getSelectorFunc(function (query, elems, options) {
		    return query === boolbase_1.falseFunc || !elems || elems.length === 0
		        ? []
		        : options.adapter.findAll(query, elems);
		});
		/**
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elems Elements to query. If it is an element, its children will be queried..
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns the first match, or null if there was no match.
		 */
		exports.selectOne = getSelectorFunc(function (query, elems, options) {
		    return query === boolbase_1.falseFunc || !elems || elems.length === 0
		        ? null
		        : options.adapter.findOne(query, elems);
		});
		/**
		 * Tests whether or not an element is matched by query.
		 *
		 * @template Node The generic Node type for the DOM adapter being used.
		 * @template ElementNode The Node type for elements for the DOM adapter being used.
		 * @param elem The element to test if it matches the query.
		 * @param query can be either a CSS selector string or a compiled query function.
		 * @param [options] options for querying the document.
		 * @see compile for supported selector queries.
		 * @returns
		 */
		function is(elem, query, options) {
		    var opts = convertOptionFormats(options);
		    return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
		}
		exports.is = is;
		/**
		 * Alias for selectAll(query, elems, options).
		 * @see [compile] for supported selector queries.
		 */
		exports.default = exports.selectAll;
		// Export filters, pseudos and aliases to allow users to supply their own.
		var pseudo_selectors_1 = requirePseudoSelectors();
		Object.defineProperty(exports, "filters", { enumerable: true, get: function () { return pseudo_selectors_1.filters; } });
		Object.defineProperty(exports, "pseudos", { enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } });
		Object.defineProperty(exports, "aliases", { enumerable: true, get: function () { return pseudo_selectors_1.aliases; } }); 
	} (lib$8));
	return lib$8;
}

var cssSelectAdapter;
var hasRequiredCssSelectAdapter;

function requireCssSelectAdapter () {
	if (hasRequiredCssSelectAdapter) return cssSelectAdapter;
	hasRequiredCssSelectAdapter = 1;

	const isTag = (node) => {
	  return node.type === 'element';
	};

	const existsOne = (test, elems) => {
	  return elems.some((elem) => {
	    if (isTag(elem)) {
	      return test(elem) || existsOne(test, getChildren(elem));
	    } else {
	      return false;
	    }
	  });
	};

	const getAttributeValue = (elem, name) => {
	  return elem.attributes[name];
	};

	const getChildren = (node) => {
	  return node.children || [];
	};

	const getName = (elemAst) => {
	  return elemAst.name;
	};

	const getParent = (node) => {
	  return node.parentNode || null;
	};

	const getSiblings = (elem) => {
	  var parent = getParent(elem);
	  return parent ? getChildren(parent) : [];
	};

	const getText = (node) => {
	  if (node.children[0].type === 'text' && node.children[0].type === 'cdata') {
	    return node.children[0].value;
	  }
	  return '';
	};

	const hasAttrib = (elem, name) => {
	  return elem.attributes[name] !== undefined;
	};

	const removeSubsets = (nodes) => {
	  let idx = nodes.length;
	  let node;
	  let ancestor;
	  let replace;
	  // Check if each node (or one of its ancestors) is already contained in the
	  // array.
	  while (--idx > -1) {
	    node = ancestor = nodes[idx];
	    // Temporarily remove the node under consideration
	    nodes[idx] = null;
	    replace = true;
	    while (ancestor) {
	      if (nodes.includes(ancestor)) {
	        replace = false;
	        nodes.splice(idx, 1);
	        break;
	      }
	      ancestor = getParent(ancestor);
	    }
	    // If the node has been found to be unique, re-insert it.
	    if (replace) {
	      nodes[idx] = node;
	    }
	  }
	  return nodes;
	};

	const findAll = (test, elems) => {
	  const result = [];
	  for (const elem of elems) {
	    if (isTag(elem)) {
	      if (test(elem)) {
	        result.push(elem);
	      }
	      result.push(...findAll(test, getChildren(elem)));
	    }
	  }
	  return result;
	};

	const findOne = (test, elems) => {
	  for (const elem of elems) {
	    if (isTag(elem)) {
	      if (test(elem)) {
	        return elem;
	      }
	      const result = findOne(test, getChildren(elem));
	      if (result) {
	        return result;
	      }
	    }
	  }
	  return null;
	};

	const svgoCssSelectAdapter = {
	  isTag,
	  existsOne,
	  getAttributeValue,
	  getChildren,
	  getName,
	  getParent,
	  getSiblings,
	  getText,
	  hasAttrib,
	  removeSubsets,
	  findAll,
	  findOne,
	};

	cssSelectAdapter = svgoCssSelectAdapter;
	return cssSelectAdapter;
}

var hasRequiredXast;

function requireXast () {
	if (hasRequiredXast) return xast;
	hasRequiredXast = 1;

	/**
	 * @typedef {import('./types').XastNode} XastNode
	 * @typedef {import('./types').XastChild} XastChild
	 * @typedef {import('./types').XastParent} XastParent
	 * @typedef {import('./types').Visitor} Visitor
	 */

	const { selectAll, selectOne, is } = requireLib$2();
	const xastAdaptor = requireCssSelectAdapter();

	const cssSelectOptions = {
	  xmlMode: true,
	  adapter: xastAdaptor,
	};

	/**
	 * @type {(node: XastNode, selector: string) => Array<XastChild>}
	 */
	const querySelectorAll = (node, selector) => {
	  return selectAll(selector, node, cssSelectOptions);
	};
	xast.querySelectorAll = querySelectorAll;

	/**
	 * @type {(node: XastNode, selector: string) => null | XastChild}
	 */
	const querySelector = (node, selector) => {
	  return selectOne(selector, node, cssSelectOptions);
	};
	xast.querySelector = querySelector;

	/**
	 * @type {(node: XastChild, selector: string) => boolean}
	 */
	const matches = (node, selector) => {
	  return is(node, selector, cssSelectOptions);
	};
	xast.matches = matches;

	/**
	 * @type {(node: XastChild, name: string) => null | XastChild}
	 */
	const closestByName = (node, name) => {
	  let currentNode = node;
	  while (currentNode) {
	    if (currentNode.type === 'element' && currentNode.name === name) {
	      return currentNode;
	    }
	    // @ts-ignore parentNode is hidden from public usage
	    currentNode = currentNode.parentNode;
	  }
	  return null;
	};
	xast.closestByName = closestByName;

	const visitSkip = Symbol();
	xast.visitSkip = visitSkip;

	/**
	 * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void}
	 */
	const visit = (node, visitor, parentNode) => {
	  const callbacks = visitor[node.type];
	  if (callbacks && callbacks.enter) {
	    // @ts-ignore hard to infer
	    const symbol = callbacks.enter(node, parentNode);
	    if (symbol === visitSkip) {
	      return;
	    }
	  }
	  // visit root children
	  if (node.type === 'root') {
	    // copy children array to not loose cursor when children is spliced
	    for (const child of node.children) {
	      visit(child, visitor, node);
	    }
	  }
	  // visit element children if still attached to parent
	  if (node.type === 'element') {
	    if (parentNode.children.includes(node)) {
	      for (const child of node.children) {
	        visit(child, visitor, node);
	      }
	    }
	  }
	  if (callbacks && callbacks.exit) {
	    // @ts-ignore hard to infer
	    callbacks.exit(node, parentNode);
	  }
	};
	xast.visit = visit;

	/**
	 * @type {(node: XastChild, parentNode: XastParent) => void}
	 */
	const detachNodeFromParent = (node, parentNode) => {
	  // avoid splice to not break for loops
	  parentNode.children = parentNode.children.filter((child) => child !== node);
	};
	xast.detachNodeFromParent = detachNodeFromParent;
	return xast;
}

var hasRequiredPlugins$1;

function requirePlugins$1 () {
	if (hasRequiredPlugins$1) return plugins;
	hasRequiredPlugins$1 = 1;

	const { visit } = requireXast();

	/**
	 * Plugins engine.
	 *
	 * @module plugins
	 *
	 * @param {Object} ast input ast
	 * @param {Object} info extra information
	 * @param {Array} plugins plugins object from config
	 * @return {Object} output ast
	 */
	const invokePlugins = (ast, info, plugins, overrides, globalOverrides) => {
	  for (const plugin of plugins) {
	    const override = overrides == null ? null : overrides[plugin.name];
	    if (override === false) {
	      continue;
	    }
	    const params = { ...plugin.params, ...globalOverrides, ...override };

	    if (plugin.type === 'perItem') {
	      ast = perItem(ast, info, plugin, params);
	    }
	    if (plugin.type === 'perItemReverse') {
	      ast = perItem(ast, info, plugin, params, true);
	    }
	    if (plugin.type === 'full') {
	      if (plugin.active) {
	        ast = plugin.fn(ast, params, info);
	      }
	    }
	    if (plugin.type === 'visitor') {
	      if (plugin.active) {
	        const visitor = plugin.fn(ast, params, info);
	        if (visitor != null) {
	          visit(ast, visitor);
	        }
	      }
	    }
	  }
	  return ast;
	};
	plugins.invokePlugins = invokePlugins;

	/**
	 * Direct or reverse per-item loop.
	 *
	 * @param {Object} data input data
	 * @param {Object} info extra information
	 * @param {Array} plugins plugins list to process
	 * @param {boolean} [reverse] reverse pass?
	 * @return {Object} output data
	 */
	function perItem(data, info, plugin, params, reverse) {
	  function monkeys(items) {
	    items.children = items.children.filter(function (item) {
	      // reverse pass
	      if (reverse && item.children) {
	        monkeys(item);
	      }
	      // main filter
	      let kept = true;
	      if (plugin.active) {
	        kept = plugin.fn(item, params, info) !== false;
	      }
	      // direct pass
	      if (!reverse && item.children) {
	        monkeys(item);
	      }
	      return kept;
	    });
	    return items;
	  }
	  return monkeys(data);
	}

	const createPreset = ({ name, plugins }) => {
	  return {
	    name,
	    type: 'full',
	    fn: (ast, params, info) => {
	      const { floatPrecision, overrides } = params;
	      const globalOverrides = {};
	      if (floatPrecision != null) {
	        globalOverrides.floatPrecision = floatPrecision;
	      }
	      if (overrides) {
	        for (const [pluginName, override] of Object.entries(overrides)) {
	          if (override === true) {
	            console.warn(
	              `You are trying to enable ${pluginName} which is not part of preset.\n` +
	                `Try to put it before or after preset, for example\n\n` +
	                `plugins: [\n` +
	                `  {\n` +
	                `    name: 'preset-default',\n` +
	                `  },\n` +
	                `  'cleanupListOfValues'\n` +
	                `]\n`
	            );
	          }
	        }
	      }
	      return invokePlugins(ast, info, plugins, overrides, globalOverrides);
	    },
	  };
	};
	plugins.createPreset = createPreset;
	return plugins;
}

var removeDoctype = {};

var hasRequiredRemoveDoctype;

function requireRemoveDoctype () {
	if (hasRequiredRemoveDoctype) return removeDoctype;
	hasRequiredRemoveDoctype = 1;

	const { detachNodeFromParent } = requireXast();

	removeDoctype.name = 'removeDoctype';
	removeDoctype.type = 'visitor';
	removeDoctype.active = true;
	removeDoctype.description = 'removes doctype declaration';

	/**
	 * Remove DOCTYPE declaration.
	 *
	 * "Unfortunately the SVG DTDs are a source of so many
	 * issues that the SVG WG has decided not to write one
	 * for the upcoming SVG 1.2 standard. In fact SVG WG
	 * members are even telling people not to use a DOCTYPE
	 * declaration in SVG 1.0 and 1.1 documents"
	 * https://jwatt.org/svg/authoring/#doctype-declaration
	 *
	 * @example
	 * <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
	 * q"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
	 *
	 * @example
	 * <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 * "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" [
	 *     <!-- an internal subset can be embedded here -->
	 * ]>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeDoctype.fn = () => {
	  return {
	    doctype: {
	      enter: (node, parentNode) => {
	        detachNodeFromParent(node, parentNode);
	      },
	    },
	  };
	};
	return removeDoctype;
}

var removeXMLProcInst = {};

var hasRequiredRemoveXMLProcInst;

function requireRemoveXMLProcInst () {
	if (hasRequiredRemoveXMLProcInst) return removeXMLProcInst;
	hasRequiredRemoveXMLProcInst = 1;

	const { detachNodeFromParent } = requireXast();

	removeXMLProcInst.name = 'removeXMLProcInst';
	removeXMLProcInst.type = 'visitor';
	removeXMLProcInst.active = true;
	removeXMLProcInst.description = 'removes XML processing instructions';

	/**
	 * Remove XML Processing Instruction.
	 *
	 * @example
	 * <?xml version="1.0" encoding="utf-8"?>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeXMLProcInst.fn = () => {
	  return {
	    instruction: {
	      enter: (node, parentNode) => {
	        if (node.name === 'xml') {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeXMLProcInst;
}

var removeComments = {};

var hasRequiredRemoveComments;

function requireRemoveComments () {
	if (hasRequiredRemoveComments) return removeComments;
	hasRequiredRemoveComments = 1;

	const { detachNodeFromParent } = requireXast();

	removeComments.name = 'removeComments';
	removeComments.type = 'visitor';
	removeComments.active = true;
	removeComments.description = 'removes comments';

	/**
	 * Remove comments.
	 *
	 * @example
	 * <!-- Generator: Adobe Illustrator 15.0.0, SVG Export
	 * Plug-In . SVG Version: 6.00 Build 0)  -->
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeComments.fn = () => {
	  return {
	    comment: {
	      enter: (node, parentNode) => {
	        if (node.value.charAt(0) !== '!') {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeComments;
}

var removeMetadata = {};

var hasRequiredRemoveMetadata;

function requireRemoveMetadata () {
	if (hasRequiredRemoveMetadata) return removeMetadata;
	hasRequiredRemoveMetadata = 1;

	const { detachNodeFromParent } = requireXast();

	removeMetadata.name = 'removeMetadata';
	removeMetadata.type = 'visitor';
	removeMetadata.active = true;
	removeMetadata.description = 'removes <metadata>';

	/**
	 * Remove <metadata>.
	 *
	 * https://www.w3.org/TR/SVG11/metadata.html
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeMetadata.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'metadata') {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeMetadata;
}

var removeEditorsNSData = {};

var _collections = {};

var hasRequired_collections;

function require_collections () {
	if (hasRequired_collections) return _collections;
	hasRequired_collections = 1;
	(function (exports) {

		// https://www.w3.org/TR/SVG11/intro.html#Definitions

		/**
		 * @type {Record<string, Array<string>>}
		 */
		exports.elemsGroups = {
		  animation: [
		    'animate',
		    'animateColor',
		    'animateMotion',
		    'animateTransform',
		    'set',
		  ],
		  descriptive: ['desc', 'metadata', 'title'],
		  shape: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'],
		  structural: ['defs', 'g', 'svg', 'symbol', 'use'],
		  paintServer: [
		    'solidColor',
		    'linearGradient',
		    'radialGradient',
		    'meshGradient',
		    'pattern',
		    'hatch',
		  ],
		  nonRendering: [
		    'linearGradient',
		    'radialGradient',
		    'pattern',
		    'clipPath',
		    'mask',
		    'marker',
		    'symbol',
		    'filter',
		    'solidColor',
		  ],
		  container: [
		    'a',
		    'defs',
		    'g',
		    'marker',
		    'mask',
		    'missing-glyph',
		    'pattern',
		    'svg',
		    'switch',
		    'symbol',
		    'foreignObject',
		  ],
		  textContent: [
		    'altGlyph',
		    'altGlyphDef',
		    'altGlyphItem',
		    'glyph',
		    'glyphRef',
		    'textPath',
		    'text',
		    'tref',
		    'tspan',
		  ],
		  textContentChild: ['altGlyph', 'textPath', 'tref', 'tspan'],
		  lightSource: [
		    'feDiffuseLighting',
		    'feSpecularLighting',
		    'feDistantLight',
		    'fePointLight',
		    'feSpotLight',
		  ],
		  filterPrimitive: [
		    'feBlend',
		    'feColorMatrix',
		    'feComponentTransfer',
		    'feComposite',
		    'feConvolveMatrix',
		    'feDiffuseLighting',
		    'feDisplacementMap',
		    'feDropShadow',
		    'feFlood',
		    'feFuncA',
		    'feFuncB',
		    'feFuncG',
		    'feFuncR',
		    'feGaussianBlur',
		    'feImage',
		    'feMerge',
		    'feMergeNode',
		    'feMorphology',
		    'feOffset',
		    'feSpecularLighting',
		    'feTile',
		    'feTurbulence',
		  ],
		};

		exports.textElems = exports.elemsGroups.textContent.concat('title');

		exports.pathElems = ['path', 'glyph', 'missing-glyph'];

		// https://www.w3.org/TR/SVG11/intro.html#Definitions
		/**
		 * @type {Record<string, Array<string>>}
		 */
		exports.attrsGroups = {
		  animationAddition: ['additive', 'accumulate'],
		  animationAttributeTarget: ['attributeType', 'attributeName'],
		  animationEvent: ['onbegin', 'onend', 'onrepeat', 'onload'],
		  animationTiming: [
		    'begin',
		    'dur',
		    'end',
		    'min',
		    'max',
		    'restart',
		    'repeatCount',
		    'repeatDur',
		    'fill',
		  ],
		  animationValue: [
		    'calcMode',
		    'values',
		    'keyTimes',
		    'keySplines',
		    'from',
		    'to',
		    'by',
		  ],
		  conditionalProcessing: [
		    'requiredFeatures',
		    'requiredExtensions',
		    'systemLanguage',
		  ],
		  core: ['id', 'tabindex', 'xml:base', 'xml:lang', 'xml:space'],
		  graphicalEvent: [
		    'onfocusin',
		    'onfocusout',
		    'onactivate',
		    'onclick',
		    'onmousedown',
		    'onmouseup',
		    'onmouseover',
		    'onmousemove',
		    'onmouseout',
		    'onload',
		  ],
		  presentation: [
		    'alignment-baseline',
		    'baseline-shift',
		    'clip',
		    'clip-path',
		    'clip-rule',
		    'color',
		    'color-interpolation',
		    'color-interpolation-filters',
		    'color-profile',
		    'color-rendering',
		    'cursor',
		    'direction',
		    'display',
		    'dominant-baseline',
		    'enable-background',
		    'fill',
		    'fill-opacity',
		    'fill-rule',
		    'filter',
		    'flood-color',
		    'flood-opacity',
		    'font-family',
		    'font-size',
		    'font-size-adjust',
		    'font-stretch',
		    'font-style',
		    'font-variant',
		    'font-weight',
		    'glyph-orientation-horizontal',
		    'glyph-orientation-vertical',
		    'image-rendering',
		    'letter-spacing',
		    'lighting-color',
		    'marker-end',
		    'marker-mid',
		    'marker-start',
		    'mask',
		    'opacity',
		    'overflow',
		    'paint-order',
		    'pointer-events',
		    'shape-rendering',
		    'stop-color',
		    'stop-opacity',
		    'stroke',
		    'stroke-dasharray',
		    'stroke-dashoffset',
		    'stroke-linecap',
		    'stroke-linejoin',
		    'stroke-miterlimit',
		    'stroke-opacity',
		    'stroke-width',
		    'text-anchor',
		    'text-decoration',
		    'text-overflow',
		    'text-rendering',
		    'transform',
		    'transform-origin',
		    'unicode-bidi',
		    'vector-effect',
		    'visibility',
		    'word-spacing',
		    'writing-mode',
		  ],
		  xlink: [
		    'xlink:href',
		    'xlink:show',
		    'xlink:actuate',
		    'xlink:type',
		    'xlink:role',
		    'xlink:arcrole',
		    'xlink:title',
		  ],
		  documentEvent: [
		    'onunload',
		    'onabort',
		    'onerror',
		    'onresize',
		    'onscroll',
		    'onzoom',
		  ],
		  filterPrimitive: ['x', 'y', 'width', 'height', 'result'],
		  transferFunction: [
		    'type',
		    'tableValues',
		    'slope',
		    'intercept',
		    'amplitude',
		    'exponent',
		    'offset',
		  ],
		};

		/**
		 * @type {Record<string, Record<string, string>>}
		 */
		exports.attrsGroupsDefaults = {
		  core: { 'xml:space': 'default' },
		  presentation: {
		    clip: 'auto',
		    'clip-path': 'none',
		    'clip-rule': 'nonzero',
		    mask: 'none',
		    opacity: '1',
		    'stop-color': '#000',
		    'stop-opacity': '1',
		    'fill-opacity': '1',
		    'fill-rule': 'nonzero',
		    fill: '#000',
		    stroke: 'none',
		    'stroke-width': '1',
		    'stroke-linecap': 'butt',
		    'stroke-linejoin': 'miter',
		    'stroke-miterlimit': '4',
		    'stroke-dasharray': 'none',
		    'stroke-dashoffset': '0',
		    'stroke-opacity': '1',
		    'paint-order': 'normal',
		    'vector-effect': 'none',
		    display: 'inline',
		    visibility: 'visible',
		    'marker-start': 'none',
		    'marker-mid': 'none',
		    'marker-end': 'none',
		    'color-interpolation': 'sRGB',
		    'color-interpolation-filters': 'linearRGB',
		    'color-rendering': 'auto',
		    'shape-rendering': 'auto',
		    'text-rendering': 'auto',
		    'image-rendering': 'auto',
		    'font-style': 'normal',
		    'font-variant': 'normal',
		    'font-weight': 'normal',
		    'font-stretch': 'normal',
		    'font-size': 'medium',
		    'font-size-adjust': 'none',
		    kerning: 'auto',
		    'letter-spacing': 'normal',
		    'word-spacing': 'normal',
		    'text-decoration': 'none',
		    'text-anchor': 'start',
		    'text-overflow': 'clip',
		    'writing-mode': 'lr-tb',
		    'glyph-orientation-vertical': 'auto',
		    'glyph-orientation-horizontal': '0deg',
		    direction: 'ltr',
		    'unicode-bidi': 'normal',
		    'dominant-baseline': 'auto',
		    'alignment-baseline': 'baseline',
		    'baseline-shift': 'baseline',
		  },
		  transferFunction: {
		    slope: '1',
		    intercept: '0',
		    amplitude: '1',
		    exponent: '1',
		    offset: '0',
		  },
		};

		// https://www.w3.org/TR/SVG11/eltindex.html
		/**
		 * @type {Record<string, {
		 *   attrsGroups: Array<string>,
		 *   attrs?: Array<string>,
		 *   defaults?: Record<string, string>,
		 *   contentGroups?: Array<string>,
		 *   content?: Array<string>,
		 * }>}
		 */
		exports.elems = {
		  a: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		      'xlink',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'target',
		    ],
		    defaults: {
		      target: '_self',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		      // not spec compliant
		      'tspan',
		    ],
		  },
		  altGlyph: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		      'xlink',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'x',
		      'y',
		      'dx',
		      'dy',
		      'glyphRef',
		      'format',
		      'rotate',
		    ],
		  },
		  altGlyphDef: {
		    attrsGroups: ['core'],
		    content: ['glyphRef'],
		  },
		  altGlyphItem: {
		    attrsGroups: ['core'],
		    content: ['glyphRef', 'altGlyphItem'],
		  },
		  animate: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'animationAddition',
		      'animationAttributeTarget',
		      'animationEvent',
		      'animationTiming',
		      'animationValue',
		      'presentation',
		      'xlink',
		    ],
		    attrs: ['externalResourcesRequired'],
		    contentGroups: ['descriptive'],
		  },
		  animateColor: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'animationEvent',
		      'xlink',
		      'animationAttributeTarget',
		      'animationTiming',
		      'animationValue',
		      'animationAddition',
		      'presentation',
		    ],
		    attrs: ['externalResourcesRequired'],
		    contentGroups: ['descriptive'],
		  },
		  animateMotion: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'animationEvent',
		      'xlink',
		      'animationTiming',
		      'animationValue',
		      'animationAddition',
		    ],
		    attrs: [
		      'externalResourcesRequired',
		      'path',
		      'keyPoints',
		      'rotate',
		      'origin',
		    ],
		    defaults: {
		      rotate: '0',
		    },
		    contentGroups: ['descriptive'],
		    content: ['mpath'],
		  },
		  animateTransform: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'animationEvent',
		      'xlink',
		      'animationAttributeTarget',
		      'animationTiming',
		      'animationValue',
		      'animationAddition',
		    ],
		    attrs: ['externalResourcesRequired', 'type'],
		    contentGroups: ['descriptive'],
		  },
		  circle: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'cx',
		      'cy',
		      'r',
		    ],
		    defaults: {
		      cx: '0',
		      cy: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  clipPath: {
		    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'clipPathUnits',
		    ],
		    defaults: {
		      clipPathUnits: 'userSpaceOnUse',
		    },
		    contentGroups: ['animation', 'descriptive', 'shape'],
		    content: ['text', 'use'],
		  },
		  'color-profile': {
		    attrsGroups: ['core', 'xlink'],
		    attrs: ['local', 'name', 'rendering-intent'],
		    defaults: {
		      name: 'sRGB',
		      'rendering-intent': 'auto',
		    },
		    contentGroups: ['descriptive'],
		  },
		  cursor: {
		    attrsGroups: ['core', 'conditionalProcessing', 'xlink'],
		    attrs: ['externalResourcesRequired', 'x', 'y'],
		    defaults: {
		      x: '0',
		      y: '0',
		    },
		    contentGroups: ['descriptive'],
		  },
		  defs: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  desc: {
		    attrsGroups: ['core'],
		    attrs: ['class', 'style'],
		  },
		  ellipse: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'cx',
		      'cy',
		      'rx',
		      'ry',
		    ],
		    defaults: {
		      cx: '0',
		      cy: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  feBlend: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: [
		      'class',
		      'style',
		      // TODO: in - 'If no value is provided and this is the first filter primitive,
		      // then this filter primitive will use SourceGraphic as its input'
		      'in',
		      'in2',
		      'mode',
		    ],
		    defaults: {
		      mode: 'normal',
		    },
		    content: ['animate', 'set'],
		  },
		  feColorMatrix: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in', 'type', 'values'],
		    defaults: {
		      type: 'matrix',
		    },
		    content: ['animate', 'set'],
		  },
		  feComponentTransfer: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in'],
		    content: ['feFuncA', 'feFuncB', 'feFuncG', 'feFuncR'],
		  },
		  feComposite: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in', 'in2', 'operator', 'k1', 'k2', 'k3', 'k4'],
		    defaults: {
		      operator: 'over',
		      k1: '0',
		      k2: '0',
		      k3: '0',
		      k4: '0',
		    },
		    content: ['animate', 'set'],
		  },
		  feConvolveMatrix: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: [
		      'class',
		      'style',
		      'in',
		      'order',
		      'kernelMatrix',
		      // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
		      // with the exception that if the sum is zero, then the divisor is set to 1'
		      'divisor',
		      'bias',
		      // TODO: targetX - 'By default, the convolution matrix is centered in X over each
		      // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
		      'targetX',
		      'targetY',
		      'edgeMode',
		      // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
		      // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
		      'kernelUnitLength',
		      'preserveAlpha',
		    ],
		    defaults: {
		      order: '3',
		      bias: '0',
		      edgeMode: 'duplicate',
		      preserveAlpha: 'false',
		    },
		    content: ['animate', 'set'],
		  },
		  feDiffuseLighting: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: [
		      'class',
		      'style',
		      'in',
		      'surfaceScale',
		      'diffuseConstant',
		      'kernelUnitLength',
		    ],
		    defaults: {
		      surfaceScale: '1',
		      diffuseConstant: '1',
		    },
		    contentGroups: ['descriptive'],
		    content: [
		      // TODO: 'exactly one light source element, in any order'
		      'feDistantLight',
		      'fePointLight',
		      'feSpotLight',
		    ],
		  },
		  feDisplacementMap: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: [
		      'class',
		      'style',
		      'in',
		      'in2',
		      'scale',
		      'xChannelSelector',
		      'yChannelSelector',
		    ],
		    defaults: {
		      scale: '0',
		      xChannelSelector: 'A',
		      yChannelSelector: 'A',
		    },
		    content: ['animate', 'set'],
		  },
		  feDistantLight: {
		    attrsGroups: ['core'],
		    attrs: ['azimuth', 'elevation'],
		    defaults: {
		      azimuth: '0',
		      elevation: '0',
		    },
		    content: ['animate', 'set'],
		  },
		  feFlood: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style'],
		    content: ['animate', 'animateColor', 'set'],
		  },
		  feFuncA: {
		    attrsGroups: ['core', 'transferFunction'],
		    content: ['set', 'animate'],
		  },
		  feFuncB: {
		    attrsGroups: ['core', 'transferFunction'],
		    content: ['set', 'animate'],
		  },
		  feFuncG: {
		    attrsGroups: ['core', 'transferFunction'],
		    content: ['set', 'animate'],
		  },
		  feFuncR: {
		    attrsGroups: ['core', 'transferFunction'],
		    content: ['set', 'animate'],
		  },
		  feGaussianBlur: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in', 'stdDeviation'],
		    defaults: {
		      stdDeviation: '0',
		    },
		    content: ['set', 'animate'],
		  },
		  feImage: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive', 'xlink'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'preserveAspectRatio',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      preserveAspectRatio: 'xMidYMid meet',
		    },
		    content: ['animate', 'animateTransform', 'set'],
		  },
		  feMerge: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style'],
		    content: ['feMergeNode'],
		  },
		  feMergeNode: {
		    attrsGroups: ['core'],
		    attrs: ['in'],
		    content: ['animate', 'set'],
		  },
		  feMorphology: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in', 'operator', 'radius'],
		    defaults: {
		      operator: 'erode',
		      radius: '0',
		    },
		    content: ['animate', 'set'],
		  },
		  feOffset: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in', 'dx', 'dy'],
		    defaults: {
		      dx: '0',
		      dy: '0',
		    },
		    content: ['animate', 'set'],
		  },
		  fePointLight: {
		    attrsGroups: ['core'],
		    attrs: ['x', 'y', 'z'],
		    defaults: {
		      x: '0',
		      y: '0',
		      z: '0',
		    },
		    content: ['animate', 'set'],
		  },
		  feSpecularLighting: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: [
		      'class',
		      'style',
		      'in',
		      'surfaceScale',
		      'specularConstant',
		      'specularExponent',
		      'kernelUnitLength',
		    ],
		    defaults: {
		      surfaceScale: '1',
		      specularConstant: '1',
		      specularExponent: '1',
		    },
		    contentGroups: [
		      'descriptive',
		      // TODO: exactly one 'light source element'
		      'lightSource',
		    ],
		  },
		  feSpotLight: {
		    attrsGroups: ['core'],
		    attrs: [
		      'x',
		      'y',
		      'z',
		      'pointsAtX',
		      'pointsAtY',
		      'pointsAtZ',
		      'specularExponent',
		      'limitingConeAngle',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		      z: '0',
		      pointsAtX: '0',
		      pointsAtY: '0',
		      pointsAtZ: '0',
		      specularExponent: '1',
		    },
		    content: ['animate', 'set'],
		  },
		  feTile: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: ['class', 'style', 'in'],
		    content: ['animate', 'set'],
		  },
		  feTurbulence: {
		    attrsGroups: ['core', 'presentation', 'filterPrimitive'],
		    attrs: [
		      'class',
		      'style',
		      'baseFrequency',
		      'numOctaves',
		      'seed',
		      'stitchTiles',
		      'type',
		    ],
		    defaults: {
		      baseFrequency: '0',
		      numOctaves: '1',
		      seed: '0',
		      stitchTiles: 'noStitch',
		      type: 'turbulence',
		    },
		    content: ['animate', 'set'],
		  },
		  filter: {
		    attrsGroups: ['core', 'presentation', 'xlink'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'x',
		      'y',
		      'width',
		      'height',
		      'filterRes',
		      'filterUnits',
		      'primitiveUnits',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      primitiveUnits: 'userSpaceOnUse',
		      x: '-10%',
		      y: '-10%',
		      width: '120%',
		      height: '120%',
		    },
		    contentGroups: ['descriptive', 'filterPrimitive'],
		    content: ['animate', 'set'],
		  },
		  font: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'horiz-origin-x',
		      'horiz-origin-y',
		      'horiz-adv-x',
		      'vert-origin-x',
		      'vert-origin-y',
		      'vert-adv-y',
		    ],
		    defaults: {
		      'horiz-origin-x': '0',
		      'horiz-origin-y': '0',
		    },
		    contentGroups: ['descriptive'],
		    content: ['font-face', 'glyph', 'hkern', 'missing-glyph', 'vkern'],
		  },
		  'font-face': {
		    attrsGroups: ['core'],
		    attrs: [
		      'font-family',
		      'font-style',
		      'font-variant',
		      'font-weight',
		      'font-stretch',
		      'font-size',
		      'unicode-range',
		      'units-per-em',
		      'panose-1',
		      'stemv',
		      'stemh',
		      'slope',
		      'cap-height',
		      'x-height',
		      'accent-height',
		      'ascent',
		      'descent',
		      'widths',
		      'bbox',
		      'ideographic',
		      'alphabetic',
		      'mathematical',
		      'hanging',
		      'v-ideographic',
		      'v-alphabetic',
		      'v-mathematical',
		      'v-hanging',
		      'underline-position',
		      'underline-thickness',
		      'strikethrough-position',
		      'strikethrough-thickness',
		      'overline-position',
		      'overline-thickness',
		    ],
		    defaults: {
		      'font-style': 'all',
		      'font-variant': 'normal',
		      'font-weight': 'all',
		      'font-stretch': 'normal',
		      'unicode-range': 'U+0-10FFFF',
		      'units-per-em': '1000',
		      'panose-1': '0 0 0 0 0 0 0 0 0 0',
		      slope: '0',
		    },
		    contentGroups: ['descriptive'],
		    content: [
		      // TODO: "at most one 'font-face-src' element"
		      'font-face-src',
		    ],
		  },
		  // TODO: empty content
		  'font-face-format': {
		    attrsGroups: ['core'],
		    attrs: ['string'],
		  },
		  'font-face-name': {
		    attrsGroups: ['core'],
		    attrs: ['name'],
		  },
		  'font-face-src': {
		    attrsGroups: ['core'],
		    content: ['font-face-name', 'font-face-uri'],
		  },
		  'font-face-uri': {
		    attrsGroups: ['core', 'xlink'],
		    attrs: ['href', 'xlink:href'],
		    content: ['font-face-format'],
		  },
		  foreignObject: {
		    attrsGroups: [
		      'core',
		      'conditionalProcessing',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'x',
		      'y',
		      'width',
		      'height',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		    },
		  },
		  g: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  glyph: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'd',
		      'horiz-adv-x',
		      'vert-origin-x',
		      'vert-origin-y',
		      'vert-adv-y',
		      'unicode',
		      'glyph-name',
		      'orientation',
		      'arabic-form',
		      'lang',
		    ],
		    defaults: {
		      'arabic-form': 'initial',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  glyphRef: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'd',
		      'horiz-adv-x',
		      'vert-origin-x',
		      'vert-origin-y',
		      'vert-adv-y',
		    ],
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  hatch: {
		    attrsGroups: ['core', 'presentation', 'xlink'],
		    attrs: [
		      'class',
		      'style',
		      'x',
		      'y',
		      'pitch',
		      'rotate',
		      'hatchUnits',
		      'hatchContentUnits',
		      'transform',
		    ],
		    defaults: {
		      hatchUnits: 'objectBoundingBox',
		      hatchContentUnits: 'userSpaceOnUse',
		      x: '0',
		      y: '0',
		      pitch: '0',
		      rotate: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		    content: ['hatchPath'],
		  },
		  hatchPath: {
		    attrsGroups: ['core', 'presentation', 'xlink'],
		    attrs: ['class', 'style', 'd', 'offset'],
		    defaults: {
		      offset: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  hkern: {
		    attrsGroups: ['core'],
		    attrs: ['u1', 'g1', 'u2', 'g2', 'k'],
		  },
		  image: {
		    attrsGroups: [
		      'core',
		      'conditionalProcessing',
		      'graphicalEvent',
		      'xlink',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'preserveAspectRatio',
		      'transform',
		      'x',
		      'y',
		      'width',
		      'height',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		      preserveAspectRatio: 'xMidYMid meet',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  line: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'x1',
		      'y1',
		      'x2',
		      'y2',
		    ],
		    defaults: {
		      x1: '0',
		      y1: '0',
		      x2: '0',
		      y2: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  linearGradient: {
		    attrsGroups: ['core', 'presentation', 'xlink'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'x1',
		      'y1',
		      'x2',
		      'y2',
		      'gradientUnits',
		      'gradientTransform',
		      'spreadMethod',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      x1: '0',
		      y1: '0',
		      x2: '100%',
		      y2: '0',
		      spreadMethod: 'pad',
		    },
		    contentGroups: ['descriptive'],
		    content: ['animate', 'animateTransform', 'set', 'stop'],
		  },
		  marker: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'viewBox',
		      'preserveAspectRatio',
		      'refX',
		      'refY',
		      'markerUnits',
		      'markerWidth',
		      'markerHeight',
		      'orient',
		    ],
		    defaults: {
		      markerUnits: 'strokeWidth',
		      refX: '0',
		      refY: '0',
		      markerWidth: '3',
		      markerHeight: '3',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  mask: {
		    attrsGroups: ['conditionalProcessing', 'core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'x',
		      'y',
		      'width',
		      'height',
		      'mask-type',
		      'maskUnits',
		      'maskContentUnits',
		    ],
		    defaults: {
		      maskUnits: 'objectBoundingBox',
		      maskContentUnits: 'userSpaceOnUse',
		      x: '-10%',
		      y: '-10%',
		      width: '120%',
		      height: '120%',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  metadata: {
		    attrsGroups: ['core'],
		  },
		  'missing-glyph': {
		    attrsGroups: ['core', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'd',
		      'horiz-adv-x',
		      'vert-origin-x',
		      'vert-origin-y',
		      'vert-adv-y',
		    ],
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  mpath: {
		    attrsGroups: ['core', 'xlink'],
		    attrs: ['externalResourcesRequired', 'href', 'xlink:href'],
		    contentGroups: ['descriptive'],
		  },
		  path: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'd',
		      'pathLength',
		    ],
		    contentGroups: ['animation', 'descriptive'],
		  },
		  pattern: {
		    attrsGroups: ['conditionalProcessing', 'core', 'presentation', 'xlink'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'viewBox',
		      'preserveAspectRatio',
		      'x',
		      'y',
		      'width',
		      'height',
		      'patternUnits',
		      'patternContentUnits',
		      'patternTransform',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      patternUnits: 'objectBoundingBox',
		      patternContentUnits: 'userSpaceOnUse',
		      x: '0',
		      y: '0',
		      width: '0',
		      height: '0',
		      preserveAspectRatio: 'xMidYMid meet',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'paintServer',
		      'shape',
		      'structural',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  polygon: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'points',
		    ],
		    contentGroups: ['animation', 'descriptive'],
		  },
		  polyline: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'points',
		    ],
		    contentGroups: ['animation', 'descriptive'],
		  },
		  radialGradient: {
		    attrsGroups: ['core', 'presentation', 'xlink'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'cx',
		      'cy',
		      'r',
		      'fx',
		      'fy',
		      'fr',
		      'gradientUnits',
		      'gradientTransform',
		      'spreadMethod',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      gradientUnits: 'objectBoundingBox',
		      cx: '50%',
		      cy: '50%',
		      r: '50%',
		    },
		    contentGroups: ['descriptive'],
		    content: ['animate', 'animateTransform', 'set', 'stop'],
		  },
		  meshGradient: {
		    attrsGroups: ['core', 'presentation', 'xlink'],
		    attrs: ['class', 'style', 'x', 'y', 'gradientUnits', 'transform'],
		    contentGroups: ['descriptive', 'paintServer', 'animation'],
		    content: ['meshRow'],
		  },
		  meshRow: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: ['class', 'style'],
		    contentGroups: ['descriptive'],
		    content: ['meshPatch'],
		  },
		  meshPatch: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: ['class', 'style'],
		    contentGroups: ['descriptive'],
		    content: ['stop'],
		  },
		  rect: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'x',
		      'y',
		      'width',
		      'height',
		      'rx',
		      'ry',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  script: {
		    attrsGroups: ['core', 'xlink'],
		    attrs: ['externalResourcesRequired', 'type', 'href', 'xlink:href'],
		  },
		  set: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'animation',
		      'xlink',
		      'animationAttributeTarget',
		      'animationTiming',
		    ],
		    attrs: ['externalResourcesRequired', 'to'],
		    contentGroups: ['descriptive'],
		  },
		  solidColor: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: ['class', 'style'],
		    contentGroups: ['paintServer'],
		  },
		  stop: {
		    attrsGroups: ['core', 'presentation'],
		    attrs: ['class', 'style', 'offset', 'path'],
		    content: ['animate', 'animateColor', 'set'],
		  },
		  style: {
		    attrsGroups: ['core'],
		    attrs: ['type', 'media', 'title'],
		    defaults: {
		      type: 'text/css',
		    },
		  },
		  svg: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'documentEvent',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'x',
		      'y',
		      'width',
		      'height',
		      'viewBox',
		      'preserveAspectRatio',
		      'zoomAndPan',
		      'version',
		      'baseProfile',
		      'contentScriptType',
		      'contentStyleType',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		      width: '100%',
		      height: '100%',
		      preserveAspectRatio: 'xMidYMid meet',
		      zoomAndPan: 'magnify',
		      version: '1.1',
		      baseProfile: 'none',
		      contentScriptType: 'application/ecmascript',
		      contentStyleType: 'text/css',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  switch: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: ['class', 'style', 'externalResourcesRequired', 'transform'],
		    contentGroups: ['animation', 'descriptive', 'shape'],
		    content: [
		      'a',
		      'foreignObject',
		      'g',
		      'image',
		      'svg',
		      'switch',
		      'text',
		      'use',
		    ],
		  },
		  symbol: {
		    attrsGroups: ['core', 'graphicalEvent', 'presentation'],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'preserveAspectRatio',
		      'viewBox',
		      'refX',
		      'refY',
		    ],
		    defaults: {
		      refX: '0',
		      refY: '0',
		    },
		    contentGroups: [
		      'animation',
		      'descriptive',
		      'shape',
		      'structural',
		      'paintServer',
		    ],
		    content: [
		      'a',
		      'altGlyphDef',
		      'clipPath',
		      'color-profile',
		      'cursor',
		      'filter',
		      'font',
		      'font-face',
		      'foreignObject',
		      'image',
		      'marker',
		      'mask',
		      'pattern',
		      'script',
		      'style',
		      'switch',
		      'text',
		      'view',
		    ],
		  },
		  text: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'lengthAdjust',
		      'x',
		      'y',
		      'dx',
		      'dy',
		      'rotate',
		      'textLength',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		      lengthAdjust: 'spacing',
		    },
		    contentGroups: ['animation', 'descriptive', 'textContentChild'],
		    content: ['a'],
		  },
		  textPath: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		      'xlink',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'href',
		      'xlink:href',
		      'startOffset',
		      'method',
		      'spacing',
		      'd',
		    ],
		    defaults: {
		      startOffset: '0',
		      method: 'align',
		      spacing: 'exact',
		    },
		    contentGroups: ['descriptive'],
		    content: [
		      'a',
		      'altGlyph',
		      'animate',
		      'animateColor',
		      'set',
		      'tref',
		      'tspan',
		    ],
		  },
		  title: {
		    attrsGroups: ['core'],
		    attrs: ['class', 'style'],
		  },
		  tref: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		      'xlink',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'href',
		      'xlink:href',
		    ],
		    contentGroups: ['descriptive'],
		    content: ['animate', 'animateColor', 'set'],
		  },
		  tspan: {
		    attrsGroups: [
		      'conditionalProcessing',
		      'core',
		      'graphicalEvent',
		      'presentation',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'x',
		      'y',
		      'dx',
		      'dy',
		      'rotate',
		      'textLength',
		      'lengthAdjust',
		    ],
		    contentGroups: ['descriptive'],
		    content: [
		      'a',
		      'altGlyph',
		      'animate',
		      'animateColor',
		      'set',
		      'tref',
		      'tspan',
		    ],
		  },
		  use: {
		    attrsGroups: [
		      'core',
		      'conditionalProcessing',
		      'graphicalEvent',
		      'presentation',
		      'xlink',
		    ],
		    attrs: [
		      'class',
		      'style',
		      'externalResourcesRequired',
		      'transform',
		      'x',
		      'y',
		      'width',
		      'height',
		      'href',
		      'xlink:href',
		    ],
		    defaults: {
		      x: '0',
		      y: '0',
		    },
		    contentGroups: ['animation', 'descriptive'],
		  },
		  view: {
		    attrsGroups: ['core'],
		    attrs: [
		      'externalResourcesRequired',
		      'viewBox',
		      'preserveAspectRatio',
		      'zoomAndPan',
		      'viewTarget',
		    ],
		    contentGroups: ['descriptive'],
		  },
		  vkern: {
		    attrsGroups: ['core'],
		    attrs: ['u1', 'g1', 'u2', 'g2', 'k'],
		  },
		};

		// https://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes
		exports.editorNamespaces = [
		  'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd',
		  'http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd',
		  'http://www.inkscape.org/namespaces/inkscape',
		  'http://www.bohemiancoding.com/sketch/ns',
		  'http://ns.adobe.com/AdobeIllustrator/10.0/',
		  'http://ns.adobe.com/Graphs/1.0/',
		  'http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/',
		  'http://ns.adobe.com/Variables/1.0/',
		  'http://ns.adobe.com/SaveForWeb/1.0/',
		  'http://ns.adobe.com/Extensibility/1.0/',
		  'http://ns.adobe.com/Flows/1.0/',
		  'http://ns.adobe.com/ImageReplacement/1.0/',
		  'http://ns.adobe.com/GenericCustomNamespace/1.0/',
		  'http://ns.adobe.com/XPath/1.0/',
		  'http://schemas.microsoft.com/visio/2003/SVGExtensions/',
		  'http://taptrix.com/vectorillustrator/svg_extensions',
		  'http://www.figma.com/figma/ns',
		  'http://purl.org/dc/elements/1.1/',
		  'http://creativecommons.org/ns#',
		  'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
		  'http://www.serif.com/',
		  'http://www.vector.evaxdesign.sk',
		];

		// https://www.w3.org/TR/SVG11/linking.html#processingIRI
		exports.referencesProps = [
		  'clip-path',
		  'color-profile',
		  'fill',
		  'filter',
		  'marker-start',
		  'marker-mid',
		  'marker-end',
		  'mask',
		  'stroke',
		  'style',
		];

		// https://www.w3.org/TR/SVG11/propidx.html
		exports.inheritableAttrs = [
		  'clip-rule',
		  'color',
		  'color-interpolation',
		  'color-interpolation-filters',
		  'color-profile',
		  'color-rendering',
		  'cursor',
		  'direction',
		  'dominant-baseline',
		  'fill',
		  'fill-opacity',
		  'fill-rule',
		  'font',
		  'font-family',
		  'font-size',
		  'font-size-adjust',
		  'font-stretch',
		  'font-style',
		  'font-variant',
		  'font-weight',
		  'glyph-orientation-horizontal',
		  'glyph-orientation-vertical',
		  'image-rendering',
		  'letter-spacing',
		  'marker',
		  'marker-end',
		  'marker-mid',
		  'marker-start',
		  'paint-order',
		  'pointer-events',
		  'shape-rendering',
		  'stroke',
		  'stroke-dasharray',
		  'stroke-dashoffset',
		  'stroke-linecap',
		  'stroke-linejoin',
		  'stroke-miterlimit',
		  'stroke-opacity',
		  'stroke-width',
		  'text-anchor',
		  'text-rendering',
		  'transform',
		  'visibility',
		  'word-spacing',
		  'writing-mode',
		];

		exports.presentationNonInheritableGroupAttrs = [
		  'display',
		  'clip-path',
		  'filter',
		  'mask',
		  'opacity',
		  'text-decoration',
		  'transform',
		  'unicode-bidi',
		];

		/**
		 * https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
		 *
		 * @type {Record<string, string>}
		 */
		exports.colorsNames = {
		  aliceblue: '#f0f8ff',
		  antiquewhite: '#faebd7',
		  aqua: '#0ff',
		  aquamarine: '#7fffd4',
		  azure: '#f0ffff',
		  beige: '#f5f5dc',
		  bisque: '#ffe4c4',
		  black: '#000',
		  blanchedalmond: '#ffebcd',
		  blue: '#00f',
		  blueviolet: '#8a2be2',
		  brown: '#a52a2a',
		  burlywood: '#deb887',
		  cadetblue: '#5f9ea0',
		  chartreuse: '#7fff00',
		  chocolate: '#d2691e',
		  coral: '#ff7f50',
		  cornflowerblue: '#6495ed',
		  cornsilk: '#fff8dc',
		  crimson: '#dc143c',
		  cyan: '#0ff',
		  darkblue: '#00008b',
		  darkcyan: '#008b8b',
		  darkgoldenrod: '#b8860b',
		  darkgray: '#a9a9a9',
		  darkgreen: '#006400',
		  darkgrey: '#a9a9a9',
		  darkkhaki: '#bdb76b',
		  darkmagenta: '#8b008b',
		  darkolivegreen: '#556b2f',
		  darkorange: '#ff8c00',
		  darkorchid: '#9932cc',
		  darkred: '#8b0000',
		  darksalmon: '#e9967a',
		  darkseagreen: '#8fbc8f',
		  darkslateblue: '#483d8b',
		  darkslategray: '#2f4f4f',
		  darkslategrey: '#2f4f4f',
		  darkturquoise: '#00ced1',
		  darkviolet: '#9400d3',
		  deeppink: '#ff1493',
		  deepskyblue: '#00bfff',
		  dimgray: '#696969',
		  dimgrey: '#696969',
		  dodgerblue: '#1e90ff',
		  firebrick: '#b22222',
		  floralwhite: '#fffaf0',
		  forestgreen: '#228b22',
		  fuchsia: '#f0f',
		  gainsboro: '#dcdcdc',
		  ghostwhite: '#f8f8ff',
		  gold: '#ffd700',
		  goldenrod: '#daa520',
		  gray: '#808080',
		  green: '#008000',
		  greenyellow: '#adff2f',
		  grey: '#808080',
		  honeydew: '#f0fff0',
		  hotpink: '#ff69b4',
		  indianred: '#cd5c5c',
		  indigo: '#4b0082',
		  ivory: '#fffff0',
		  khaki: '#f0e68c',
		  lavender: '#e6e6fa',
		  lavenderblush: '#fff0f5',
		  lawngreen: '#7cfc00',
		  lemonchiffon: '#fffacd',
		  lightblue: '#add8e6',
		  lightcoral: '#f08080',
		  lightcyan: '#e0ffff',
		  lightgoldenrodyellow: '#fafad2',
		  lightgray: '#d3d3d3',
		  lightgreen: '#90ee90',
		  lightgrey: '#d3d3d3',
		  lightpink: '#ffb6c1',
		  lightsalmon: '#ffa07a',
		  lightseagreen: '#20b2aa',
		  lightskyblue: '#87cefa',
		  lightslategray: '#789',
		  lightslategrey: '#789',
		  lightsteelblue: '#b0c4de',
		  lightyellow: '#ffffe0',
		  lime: '#0f0',
		  limegreen: '#32cd32',
		  linen: '#faf0e6',
		  magenta: '#f0f',
		  maroon: '#800000',
		  mediumaquamarine: '#66cdaa',
		  mediumblue: '#0000cd',
		  mediumorchid: '#ba55d3',
		  mediumpurple: '#9370db',
		  mediumseagreen: '#3cb371',
		  mediumslateblue: '#7b68ee',
		  mediumspringgreen: '#00fa9a',
		  mediumturquoise: '#48d1cc',
		  mediumvioletred: '#c71585',
		  midnightblue: '#191970',
		  mintcream: '#f5fffa',
		  mistyrose: '#ffe4e1',
		  moccasin: '#ffe4b5',
		  navajowhite: '#ffdead',
		  navy: '#000080',
		  oldlace: '#fdf5e6',
		  olive: '#808000',
		  olivedrab: '#6b8e23',
		  orange: '#ffa500',
		  orangered: '#ff4500',
		  orchid: '#da70d6',
		  palegoldenrod: '#eee8aa',
		  palegreen: '#98fb98',
		  paleturquoise: '#afeeee',
		  palevioletred: '#db7093',
		  papayawhip: '#ffefd5',
		  peachpuff: '#ffdab9',
		  peru: '#cd853f',
		  pink: '#ffc0cb',
		  plum: '#dda0dd',
		  powderblue: '#b0e0e6',
		  purple: '#800080',
		  rebeccapurple: '#639',
		  red: '#f00',
		  rosybrown: '#bc8f8f',
		  royalblue: '#4169e1',
		  saddlebrown: '#8b4513',
		  salmon: '#fa8072',
		  sandybrown: '#f4a460',
		  seagreen: '#2e8b57',
		  seashell: '#fff5ee',
		  sienna: '#a0522d',
		  silver: '#c0c0c0',
		  skyblue: '#87ceeb',
		  slateblue: '#6a5acd',
		  slategray: '#708090',
		  slategrey: '#708090',
		  snow: '#fffafa',
		  springgreen: '#00ff7f',
		  steelblue: '#4682b4',
		  tan: '#d2b48c',
		  teal: '#008080',
		  thistle: '#d8bfd8',
		  tomato: '#ff6347',
		  turquoise: '#40e0d0',
		  violet: '#ee82ee',
		  wheat: '#f5deb3',
		  white: '#fff',
		  whitesmoke: '#f5f5f5',
		  yellow: '#ff0',
		  yellowgreen: '#9acd32',
		};

		/**
		 * @type {Record<string, string>}
		 */
		exports.colorsShortNames = {
		  '#f0ffff': 'azure',
		  '#f5f5dc': 'beige',
		  '#ffe4c4': 'bisque',
		  '#a52a2a': 'brown',
		  '#ff7f50': 'coral',
		  '#ffd700': 'gold',
		  '#808080': 'gray',
		  '#008000': 'green',
		  '#4b0082': 'indigo',
		  '#fffff0': 'ivory',
		  '#f0e68c': 'khaki',
		  '#faf0e6': 'linen',
		  '#800000': 'maroon',
		  '#000080': 'navy',
		  '#808000': 'olive',
		  '#ffa500': 'orange',
		  '#da70d6': 'orchid',
		  '#cd853f': 'peru',
		  '#ffc0cb': 'pink',
		  '#dda0dd': 'plum',
		  '#800080': 'purple',
		  '#f00': 'red',
		  '#ff0000': 'red',
		  '#fa8072': 'salmon',
		  '#a0522d': 'sienna',
		  '#c0c0c0': 'silver',
		  '#fffafa': 'snow',
		  '#d2b48c': 'tan',
		  '#008080': 'teal',
		  '#ff6347': 'tomato',
		  '#ee82ee': 'violet',
		  '#f5deb3': 'wheat',
		};

		// https://www.w3.org/TR/SVG11/single-page.html#types-DataTypeColor
		exports.colorsProps = [
		  'color',
		  'fill',
		  'stroke',
		  'stop-color',
		  'flood-color',
		  'lighting-color',
		]; 
	} (_collections));
	return _collections;
}

var hasRequiredRemoveEditorsNSData;

function requireRemoveEditorsNSData () {
	if (hasRequiredRemoveEditorsNSData) return removeEditorsNSData;
	hasRequiredRemoveEditorsNSData = 1;

	const { detachNodeFromParent } = requireXast();
	const { editorNamespaces } = require_collections();

	removeEditorsNSData.type = 'visitor';
	removeEditorsNSData.name = 'removeEditorsNSData';
	removeEditorsNSData.active = true;
	removeEditorsNSData.description = 'removes editors namespaces, elements and attributes';

	/**
	 * Remove editors namespaces, elements and attributes.
	 *
	 * @example
	 * <svg xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd">
	 * <sodipodi:namedview/>
	 * <path sodipodi:nodetypes="cccc"/>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   additionalNamespaces?: Array<string>
	 * }>}
	 */
	removeEditorsNSData.fn = (_root, params) => {
	  let namespaces = editorNamespaces;
	  if (Array.isArray(params.additionalNamespaces)) {
	    namespaces = [...editorNamespaces, ...params.additionalNamespaces];
	  }
	  /**
	   * @type {Array<string>}
	   */
	  const prefixes = [];
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // collect namespace aliases from svg element
	        if (node.name === 'svg') {
	          for (const [name, value] of Object.entries(node.attributes)) {
	            if (name.startsWith('xmlns:') && namespaces.includes(value)) {
	              prefixes.push(name.slice('xmlns:'.length));
	              // <svg xmlns:sodipodi="">
	              delete node.attributes[name];
	            }
	          }
	        }
	        // remove editor attributes, for example
	        // <* sodipodi:*="">
	        for (const name of Object.keys(node.attributes)) {
	          if (name.includes(':')) {
	            const [prefix] = name.split(':');
	            if (prefixes.includes(prefix)) {
	              delete node.attributes[name];
	            }
	          }
	        }
	        // remove editor elements, for example
	        // <sodipodi:*>
	        if (node.name.includes(':')) {
	          const [prefix] = node.name.split(':');
	          if (prefixes.includes(prefix)) {
	            detachNodeFromParent(node, parentNode);
	          }
	        }
	      },
	    },
	  };
	};
	return removeEditorsNSData;
}

var cleanupAttrs = {};

var hasRequiredCleanupAttrs;

function requireCleanupAttrs () {
	if (hasRequiredCleanupAttrs) return cleanupAttrs;
	hasRequiredCleanupAttrs = 1;

	cleanupAttrs.name = 'cleanupAttrs';
	cleanupAttrs.type = 'visitor';
	cleanupAttrs.active = true;
	cleanupAttrs.description =
	  'cleanups attributes from newlines, trailing and repeating spaces';

	const regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
	const regNewlines = /\r?\n/g;
	const regSpaces = /\s{2,}/g;

	/**
	 * Cleanup attributes values from newlines, trailing and repeating spaces.
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   newlines?: boolean,
	 *   trim?: boolean,
	 *   spaces?: boolean
	 * }>}
	 */
	cleanupAttrs.fn = (root, params) => {
	  const { newlines = true, trim = true, spaces = true } = params;
	  return {
	    element: {
	      enter: (node) => {
	        for (const name of Object.keys(node.attributes)) {
	          if (newlines) {
	            // new line which requires a space instead of themselve
	            node.attributes[name] = node.attributes[name].replace(
	              regNewlinesNeedSpace,
	              (match, p1, p2) => p1 + ' ' + p2
	            );
	            // simple new line
	            node.attributes[name] = node.attributes[name].replace(
	              regNewlines,
	              ''
	            );
	          }
	          if (trim) {
	            node.attributes[name] = node.attributes[name].trim();
	          }
	          if (spaces) {
	            node.attributes[name] = node.attributes[name].replace(
	              regSpaces,
	              ' '
	            );
	          }
	        }
	      },
	    },
	  };
	};
	return cleanupAttrs;
}

var mergeStyles = {};

var cssClassList;
var hasRequiredCssClassList;

function requireCssClassList () {
	if (hasRequiredCssClassList) return cssClassList;
	hasRequiredCssClassList = 1;

	var CSSClassList = function (node) {
	  this.parentNode = node;
	  this.classNames = new Set();
	  const value = node.attributes.class;
	  if (value != null) {
	    this.addClassValueHandler();
	    this.setClassValue(value);
	  }
	};

	// attr.class.value

	CSSClassList.prototype.addClassValueHandler = function () {
	  Object.defineProperty(this.parentNode.attributes, 'class', {
	    get: this.getClassValue.bind(this),
	    set: this.setClassValue.bind(this),
	    enumerable: true,
	    configurable: true,
	  });
	};

	CSSClassList.prototype.getClassValue = function () {
	  var arrClassNames = Array.from(this.classNames);
	  return arrClassNames.join(' ');
	};

	CSSClassList.prototype.setClassValue = function (newValue) {
	  if (typeof newValue === 'undefined') {
	    this.classNames.clear();
	    return;
	  }
	  var arrClassNames = newValue.split(' ');
	  this.classNames = new Set(arrClassNames);
	};

	CSSClassList.prototype.add = function (/* variadic */) {
	  this.addClassValueHandler();
	  Object.values(arguments).forEach(this._addSingle.bind(this));
	};

	CSSClassList.prototype._addSingle = function (className) {
	  this.classNames.add(className);
	};

	CSSClassList.prototype.remove = function (/* variadic */) {
	  this.addClassValueHandler();
	  Object.values(arguments).forEach(this._removeSingle.bind(this));
	};

	CSSClassList.prototype._removeSingle = function (className) {
	  this.classNames.delete(className);
	};

	CSSClassList.prototype.item = function (index) {
	  var arrClassNames = Array.from(this.classNames);
	  return arrClassNames[index];
	};

	CSSClassList.prototype.toggle = function (className, force) {
	  if (this.contains(className) || force === false) {
	    this.classNames.delete(className);
	  }
	  this.classNames.add(className);
	};

	CSSClassList.prototype.contains = function (className) {
	  return this.classNames.has(className);
	};

	cssClassList = CSSClassList;
	return cssClassList;
}

var syntax = {exports: {}};

var create$4 = {};

var List_1;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return List_1;
	hasRequiredList = 1;
	//
	//                              list
	//                            â”Œâ”€â”€â”€â”€â”€â”€â”
	//             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€head â”‚
	//             â”‚              â”‚ tailâ”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
	//             â”‚              â””â”€â”€â”€â”€â”€â”€â”˜              â”‚
	//             â–¼                                    â–¼
	//            item        item        item        item
	//          â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”
	//  null â—€â”€â”€â”¼â”€prev â”‚â—€â”€â”€â”€â”¼â”€prev â”‚â—€â”€â”€â”€â”¼â”€prev â”‚â—€â”€â”€â”€â”¼â”€prev â”‚
	//          â”‚ nextâ”€â”¼â”€â”€â”€â–¶â”‚ nextâ”€â”¼â”€â”€â”€â–¶â”‚ nextâ”€â”¼â”€â”€â”€â–¶â”‚ nextâ”€â”¼â”€â”€â–¶ null
	//          â”œâ”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”¤
	//          â”‚ data â”‚    â”‚ data â”‚    â”‚ data â”‚    â”‚ data â”‚
	//          â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.reduce = function(fn, initialValue, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);
	    var acc = initialValue;

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        acc = fn.call(context, acc, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);

	    return acc;
	};

	List.prototype.reduceRight = function(fn, initialValue, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);
	    var acc = initialValue;

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        acc = fn.call(context, acc, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);

	    return acc;
	};

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	List_1 = List;
	return List_1;
}

var createCustomError;
var hasRequiredCreateCustomError;

function requireCreateCustomError () {
	if (hasRequiredCreateCustomError) return createCustomError;
	hasRequiredCreateCustomError = 1;
	createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};
	return createCustomError;
}

var _SyntaxError$1;
var hasRequired_SyntaxError$1;

function require_SyntaxError$1 () {
	if (hasRequired_SyntaxError$1) return _SyntaxError$1;
	hasRequired_SyntaxError$1 = 1;
	var createCustomError = requireCreateCustomError();
	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	_SyntaxError$1 = SyntaxError;
	return _SyntaxError$1;
}

var _const;
var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	_const = {
	    TYPE: TYPE,
	    NAME: NAME
	};
	return _const;
}

var charCodeDefinitions;
var hasRequiredCharCodeDefinitions;

function requireCharCodeDefinitions () {
	if (hasRequiredCharCodeDefinitions) return charCodeDefinitions;
	hasRequiredCharCodeDefinitions = 1;
	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// Â§ 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// Â§ 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// Â§ 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// Â§ 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};
	return charCodeDefinitions;
}

var utils$2;
var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	var charCodeDef = requireCharCodeDefinitions();
	var isDigit = charCodeDef.isDigit;
	var isHexDigit = charCodeDef.isHexDigit;
	var isUppercaseLetter = charCodeDef.isUppercaseLetter;
	var isName = charCodeDef.isName;
	var isWhiteSpace = charCodeDef.isWhiteSpace;
	var isValidEscape = charCodeDef.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// Â§ 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// Â§4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// Â§4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// Â§ 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	utils$2 = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};
	return utils$2;
}

var TokenStream_1;
var hasRequiredTokenStream;

function requireTokenStream () {
	if (hasRequiredTokenStream) return TokenStream_1;
	hasRequiredTokenStream = 1;
	var constants = require_const();
	var TYPE = constants.TYPE;
	var NAME = constants.NAME;

	var utils = requireUtils$2();
	var cmpStr = utils.cmpStr;

	var EOF = TYPE.EOF;
	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }

	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    forEachToken(fn) {
	        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
	            var start = offset;
	            var item = this.offsetAndType[i];
	            var end = item & OFFSET_MASK;
	            var type = item >> TYPE_SHIFT;

	            offset = end;

	            fn(type, start, end, i);
	        }
	    },

	    dump() {
	        var tokens = new Array(this.tokenCount);

	        this.forEachToken((type, start, end, index) => {
	            tokens[index] = {
	                idx: index,
	                type: NAME[type],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[index]
	            };
	        });

	        return tokens;
	    }
	};

	TokenStream_1 = TokenStream;
	return TokenStream_1;
}

var generate_1;
var hasRequiredGenerate;

function requireGenerate () {
	if (hasRequiredGenerate) return generate_1;
	hasRequiredGenerate = 1;
	function noop(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-âˆ' : node.min) +
	                ',' +
	                (node.max === null ? 'âˆ' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	generate_1 = function(node, options) {
	    var decorate = noop;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};
	return generate_1;
}

var error;
var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	const createCustomError = requireCreateCustomError();
	const generate = requireGenerate();
	const defaultLoc = { offset: 0, line: 1, column: 1 };

	function locateMismatch(matchResult, node) {
	    const tokens = matchResult.tokens;
	    const longestMatch = matchResult.longestMatch;
	    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
	    const badNode = mismatchNode !== node ? mismatchNode : null;
	    let mismatchOffset = 0;
	    let mismatchLength = 0;
	    let entries = 0;
	    let css = '';
	    let start;
	    let end;

	    for (let i = 0; i < tokens.length; i++) {
	        const token = tokens[i].value;

	        if (i === longestMatch) {
	            mismatchLength = token.length;
	            mismatchOffset = css.length;
	        }

	        if (badNode !== null && tokens[i].node === badNode) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += token;
	    }

	    if (longestMatch === tokens.length || entries > 1) { // last
	        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
	        end = buildLoc(start);
	    } else {
	        start = fromLoc(badNode, 'start') ||
	            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
	        end = fromLoc(badNode, 'end') ||
	            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
	    }

	    return {
	        css,
	        mismatchOffset,
	        mismatchLength,
	        start,
	        end
	    };
	}

	function fromLoc(node, point) {
	    const value = node && node.loc && node.loc[point];

	    if (value) {
	        return 'line' in value ? buildLoc(value) : value;
	    }

	    return null;
	}

	function buildLoc({ offset, line, column }, extra) {
	    const loc = {
	        offset,
	        line,
	        column
	    };

	    if (extra) {
	        const lines = extra.split(/\n|\r\n?|\f/);

	        loc.offset += extra.length;
	        loc.line += lines.length - 1;
	        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
	    }

	    return loc;
	}

	const SyntaxReferenceError = function(type, referenceName) {
	    const error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	const SyntaxMatchError = function(message, syntax, node, matchResult) {
	    const error = createCustomError('SyntaxMatchError', message);
	    const {
	        css,
	        mismatchOffset,
	        mismatchLength,
	        start,
	        end
	    } = locateMismatch(matchResult, node);

	    error.rawMessage = message;
	    error.syntax = syntax ? generate(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.mismatchLength = mismatchLength;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    Object.assign(error, start);
	    error.loc = {
	        source: (node && node.loc && node.loc.source) || '<unknown>',
	        start,
	        end
	    };

	    return error;
	};

	error = {
	    SyntaxReferenceError,
	    SyntaxMatchError
	};
	return error;
}

var names;
var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};
	return names;
}

var adoptBuffer;
var hasRequiredAdoptBuffer;

function requireAdoptBuffer () {
	if (hasRequiredAdoptBuffer) return adoptBuffer;
	hasRequiredAdoptBuffer = 1;
	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};
	return adoptBuffer;
}

var tokenizer$1;
var hasRequiredTokenizer$1;

function requireTokenizer$1 () {
	if (hasRequiredTokenizer$1) return tokenizer$1;
	hasRequiredTokenizer$1 = 1;
	var TokenStream = requireTokenStream();
	var adoptBuffer = requireAdoptBuffer();

	var constants = require_const();
	var TYPE = constants.TYPE;

	var charCodeDefinitions = requireCharCodeDefinitions();
	var isNewline = charCodeDefinitions.isNewline;
	var isName = charCodeDefinitions.isName;
	var isValidEscape = charCodeDefinitions.isValidEscape;
	var isNumberStart = charCodeDefinitions.isNumberStart;
	var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory = charCodeDefinitions.charCodeCategory;
	var isBOM = charCodeDefinitions.isBOM;

	var utils = requireUtils$2();
	var cmpStr = utils.cmpStr;
	var getNewlineLength = utils.getNewlineLength;
	var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
	var consumeEscaped = utils.consumeEscaped;
	var consumeName = utils.consumeName;
	var consumeNumber = utils.consumeNumber;
	var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // Â§ 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>â€™s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE.Dimension;
	            offset = consumeName(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE.Number;
	    }

	    // Â§ 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName(source, offset);

	        // If stringâ€™s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE.Ident;
	    }

	    // Â§ 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory.WhiteSpace:
	                    if (isNewline(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength(source, offset, code);
	                        type = TYPE.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline(nextCode)) {
	                        offset += getNewlineLength(source, offset + 1, nextCode);
	                    } else if (isValidEscape(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>â€™s value.
	                        offset = consumeEscaped(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>â€™s value.
	            }
	        }
	    }

	    // Â§ 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that itâ€™s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldnâ€™t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants(source, offset);
	                    type = TYPE.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants(source, offset);
	                    type = TYPE.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>â€™s value.
	                    if (isValidEscape(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants(source, offset);
	                    type = TYPE.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>â€™s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // Â§ 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory(code)) {
	            // whitespace
	            case charCodeCategory.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE.WhiteSpace;
	                offset = findWhiteSpaceEnd(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>â€™s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>â€™s value to the returned string.
	                    offset = consumeName(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE.AtKeyword;
	                    offset = consumeName(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE.LeftParenthesis:
	            case TYPE.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
	                break;

	            case TYPE.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
	                break;

	            case TYPE.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(constants).forEach(function(key) {
	    tokenize[key] = constants[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	tokenizer$1 = tokenize;
	return tokenizer$1;
}

var genericAnPlusB;
var hasRequiredGenericAnPlusB;

function requireGenericAnPlusB () {
	if (hasRequiredGenericAnPlusB) return genericAnPlusB;
	hasRequiredGenericAnPlusB = 1;
	var isDigit = requireTokenizer$1().isDigit;
	var cmpChar = requireTokenizer$1().cmpChar;
	var TYPE = requireTokenizer$1().TYPE;

	var DELIM = TYPE.Delim;
	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var IDENT = TYPE.Ident;
	var NUMBER = TYPE.Number;
	var DIMENSION = TYPE.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
	        // expect 1st char is N
	        if (!cmpChar(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};
	return genericAnPlusB;
}

var genericUrange;
var hasRequiredGenericUrange;

function requireGenericUrange () {
	if (hasRequiredGenericUrange) return genericUrange;
	hasRequiredGenericUrange = 1;
	var isHexDigit = requireTokenizer$1().isHexDigit;
	var cmpChar = requireTokenizer$1().cmpChar;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var DELIM = TYPE.Delim;
	var NUMBER = TYPE.Number;
	var DIMENSION = TYPE.Dimension;
	var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }	    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim(token, PLUSSIGN)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER) {
	        if (!startsWith(token, PLUSSIGN)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION || token.type === NUMBER) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION) {
	        if (!startsWith(token, PLUSSIGN)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};
	return genericUrange;
}

var generic;
var hasRequiredGeneric;

function requireGeneric () {
	if (hasRequiredGeneric) return generic;
	hasRequiredGeneric = 1;
	var tokenizer = requireTokenizer$1();
	var isIdentifierStart = tokenizer.isIdentifierStart;
	var isHexDigit = tokenizer.isHexDigit;
	var isDigit = tokenizer.isDigit;
	var cmpStr = tokenizer.cmpStr;
	var consumeNumber = tokenizer.consumeNumber;
	var TYPE = tokenizer.TYPE;
	var anPlusB = requireGenericAnPlusB();
	var urange = requireGenericUrange();

	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that propertyâ€™s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if anyâ€”for example by saying that any pre-defined keywords
	    // in that propertyâ€™s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: itâ€™s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesnâ€™t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE.BadString:
	            case TYPE.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE.RightCurlyBracket:
	            case TYPE.RightParenthesis:
	            case TYPE.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE.Function:
	            case TYPE.LeftParenthesis:
	            case TYPE.LeftSquareBracket:
	            case TYPE.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE.BadString:
	            case TYPE.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE.RightCurlyBracket:
	            case TYPE.RightParenthesis:
	            case TYPE.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// Â§5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// Â§ 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// Â§5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integerâ€™s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	generic = {
	    // token types
	    'ident-token': tokenType(TYPE.Ident),
	    'function-token': tokenType(TYPE.Function),
	    'at-keyword-token': tokenType(TYPE.AtKeyword),
	    'hash-token': tokenType(TYPE.Hash),
	    'string-token': tokenType(TYPE.String),
	    'bad-string-token': tokenType(TYPE.BadString),
	    'url-token': tokenType(TYPE.Url),
	    'bad-url-token': tokenType(TYPE.BadUrl),
	    'delim-token': tokenType(TYPE.Delim),
	    'number-token': tokenType(TYPE.Number),
	    'percentage-token': tokenType(TYPE.Percentage),
	    'dimension-token': tokenType(TYPE.Dimension),
	    'whitespace-token': tokenType(TYPE.WhiteSpace),
	    'CDO-token': tokenType(TYPE.CDO),
	    'CDC-token': tokenType(TYPE.CDC),
	    'colon-token': tokenType(TYPE.Colon),
	    'semicolon-token': tokenType(TYPE.Semicolon),
	    'comma-token': tokenType(TYPE.Comma),
	    '[-token': tokenType(TYPE.LeftSquareBracket),
	    ']-token': tokenType(TYPE.RightSquareBracket),
	    '(-token': tokenType(TYPE.LeftParenthesis),
	    ')-token': tokenType(TYPE.RightParenthesis),
	    '{-token': tokenType(TYPE.LeftCurlyBracket),
	    '}-token': tokenType(TYPE.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE.String),
	    'ident': tokenType(TYPE.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': anPlusB,
	    'urange': urange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};
	return generic;
}

var _SyntaxError;
var hasRequired_SyntaxError;

function require_SyntaxError () {
	if (hasRequired_SyntaxError) return _SyntaxError;
	hasRequired_SyntaxError = 1;
	var createCustomError = requireCreateCustomError();

	_SyntaxError = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};
	return _SyntaxError;
}

var tokenizer;
var hasRequiredTokenizer;

function requireTokenizer () {
	if (hasRequiredTokenizer) return tokenizer;
	hasRequiredTokenizer = 1;
	var SyntaxError = require_SyntaxError();

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new SyntaxError(message, this.str, this.pos);
	    }
	};

	tokenizer = Tokenizer;
	return tokenizer;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	var Tokenizer = requireTokenizer();
	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // âˆ
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notationâ€”[min,max]â€”within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [âˆ’âˆ,âˆ] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE:
	        case TAB:
	        case N:
	        case R:
	        case F:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN:
	        case QUESTIONMARK:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new Tokenizer(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	parse_1 = parse;
	return parse_1;
}

var walk;
var hasRequiredWalk;

function requireWalk () {
	if (hasRequiredWalk) return walk;
	hasRequiredWalk = 1;
	var noop = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop;
	}

	walk = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop;
	    var leave = noop;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop && leave === noop) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};
	return walk;
}

var prepareTokens_1;
var hasRequiredPrepareTokens;

function requirePrepareTokens () {
	if (hasRequiredPrepareTokens) return prepareTokens_1;
	hasRequiredPrepareTokens = 1;
	var tokenize = requireTokenizer$1();
	var TokenStream = requireTokenStream();
	var tokenStream = new TokenStream();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenize(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};
	return prepareTokens_1;
}

var matchGraph;
var hasRequiredMatchGraph;

function requireMatchGraph () {
	if (hasRequiredMatchGraph) return matchGraph;
	hasRequiredMatchGraph = 1;
	var parse = requireParse();

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS = 40;  // (
	var RIGHTPARENTHESIS = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};
	return matchGraph;
}

var match;
var hasRequiredMatch;

function requireMatch () {
	if (hasRequiredMatch) return match;
	hasRequiredMatch = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var matchGraph = requireMatchGraph();
	var MATCH = matchGraph.MATCH;
	var MISMATCH = matchGraph.MISMATCH;
	var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
	var TYPE = require_const().TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isContextEdgeDelim(token) {
	    if (token.type !== TYPE.Delim) {
	        return false;
	    }

	    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
	    // Probably we need to check out previous match instead
	    return token.value !== '?';
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE.Comma ||
	        token.type === TYPE.Function ||
	        token.type === TYPE.LeftParenthesis ||
	        token.type === TYPE.LeftSquareBracket ||
	        token.type === TYPE.LeftCurlyBracket ||
	        isContextEdgeDelim(token)
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE.RightParenthesis ||
	        token.type === TYPE.RightSquareBracket ||
	        token.type === TYPE.RightCurlyBracket ||
	        token.type === TYPE.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null â€“ stashing allowed, nothing stashed
	    // false â€“ stashing disabled, nothing stashed
	    // anithing else â€“ fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH;
	                        break;
	                    } else {
	                        state = MATCH;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH;
	                } else {
	                    state = MISMATCH;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH;
	                        break;
	                    }
	                }

	                state = MISMATCH;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH;
	                    break;
	                }

	                state = MISMATCH;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH;
	                    break;
	                }

	                state = MISMATCH;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH;
	                } else {
	                    state = MISMATCH;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};
	return match;
}

var trace;
var hasRequiredTrace;

function requireTrace () {
	if (hasRequiredTrace) return trace;
	hasRequiredTrace = 1;
	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};
	return trace;
}

var search;
var hasRequiredSearch;

function requireSearch () {
	if (hasRequiredSearch) return search;
	hasRequiredSearch = 1;
	var List = requireList();

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	search = {
	    matchFragments: matchFragments
	};
	return search;
}

var structure;
var hasRequiredStructure;

function requireStructure () {
	if (hasRequiredStructure) return structure;
	hasRequiredStructure = 1;
	var List = requireList();
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty.call(fields, key) &&
	                hasOwnProperty.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};
	return structure;
}

var Lexer_1;
var hasRequiredLexer$1;

function requireLexer$1 () {
	if (hasRequiredLexer$1) return Lexer_1;
	hasRequiredLexer$1 = 1;
	var SyntaxReferenceError = requireError().SyntaxReferenceError;
	var SyntaxMatchError = requireError().SyntaxMatchError;
	var names = requireNames();
	var generic = requireGeneric();
	var parse = requireParse();
	var generate = requireGenerate();
	var walk = requireWalk();
	var prepareTokens = requirePrepareTokens();
	var buildMatchGraph = requireMatchGraph().buildMatchGraph;
	var matchAsTree = requireMatch().matchAsTree;
	var trace = requireTrace();
	var search = requireSearch();
	var getStructureFromConfig = requireStructure().getStructureFromConfig;
	var cssWideKeywords = buildMatchGraph('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
	    const result = {};

	    for (const [name, atrule] of Object.entries(map)) {
	        result[name] = {
	            prelude: atrule.prelude && (
	                syntaxAsAst
	                    ? atrule.prelude.syntax
	                    : generate(atrule.prelude.syntax, { compact })
	            ),
	            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
	        };
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name, parent = null) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            parent: parent,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        if (!syntax) {
	            return;
	        }

	        this.atrules[name] = {
	            type: 'Atrule',
	            name: name,
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, descName) => {
	                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        if (!syntax) {
	            return;
	        }

	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        if (!syntax) {
	            return;
	        }

	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    checkAtruleName: function(atruleName) {
	        if (!this.getAtrule(atruleName)) {
	            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
	        }
	    },
	    checkAtrulePrelude: function(atruleName, prelude) {
	        let error = this.checkAtruleName(atruleName);

	        if (error) {
	            return error;
	        }

	        var atrule = this.getAtrule(atruleName);

	        if (!atrule.prelude && prelude) {
	            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
	        }

	        if (atrule.prelude && !prelude) {
	            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
	        }
	    },
	    checkAtruleDescriptorName: function(atruleName, descriptorName) {
	        let error = this.checkAtruleName(atruleName);

	        if (error) {
	            return error;
	        }

	        var atrule = this.getAtrule(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        if (!atrule.descriptors) {
	            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
	        }

	        if (!atrule.descriptors[descriptor.name] &&
	            !atrule.descriptors[descriptor.basename]) {
	            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
	        }
	    },
	    checkPropertyName: function(propertyName) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return new Error('Lexer matching doesn\'t applicable for custom properties');
	        }

	        if (!this.getProperty(propertyName)) {
	            return new SyntaxReferenceError('Unknown property', propertyName);
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var error = this.checkAtrulePrelude(atruleName, prelude);

	        if (error) {
	            return buildMatchResult(null, error);
	        }

	        if (!prelude) {
	            return buildMatchResult(null, null);
	        }

	        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);

	        if (error) {
	            return buildMatchResult(null, error);
	        }

	        var atrule = this.getAtrule(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var error = this.checkPropertyName(propertyName);

	        if (error) {
	            return buildMatchResult(null, error);
	        }

	        return matchSyntax(this, this.getProperty(propertyName), value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrule: function(atruleName, fallbackBasename = true) {
	        var atrule = names.keyword(atruleName);
	        var atruleEntry = atrule.vendor && fallbackBasename
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        return atruleEntry || null;
	    },
	    getAtrulePrelude: function(atruleName, fallbackBasename = true) {
	        const atrule = this.getAtrule(atruleName, fallbackBasename);

	        return atrule && atrule.prelude || null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(propertyName, fallbackBasename = true) {
	        var property = names.property(propertyName);
	        var propertyEntry = property.vendor && fallbackBasename
	            ? this.properties[property.name] || this.properties[property.basename]
	            : this.properties[property.name];

	        return propertyEntry || null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
	            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	Lexer_1 = Lexer;
	return Lexer_1;
}

var definitionSyntax;
var hasRequiredDefinitionSyntax;

function requireDefinitionSyntax () {
	if (hasRequiredDefinitionSyntax) return definitionSyntax;
	hasRequiredDefinitionSyntax = 1;
	definitionSyntax = {
	    SyntaxError: require_SyntaxError(),
	    parse: requireParse(),
	    generate: requireGenerate(),
	    walk: requireWalk()
	};
	return definitionSyntax;
}

var OffsetToLocation_1;
var hasRequiredOffsetToLocation;

function requireOffsetToLocation () {
	if (hasRequiredOffsetToLocation) return OffsetToLocation_1;
	hasRequiredOffsetToLocation = 1;
	var adoptBuffer = requireAdoptBuffer();
	var isBOM = requireTokenizer$1().isBOM;

	var N = 10;
	var F = 12;
	var R = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N || code === R || code === F) {
	            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	OffsetToLocation_1 = OffsetToLocation;
	return OffsetToLocation_1;
}

var sequence;
var hasRequiredSequence;

function requireSequence () {
	if (hasRequiredSequence) return sequence;
	hasRequiredSequence = 1;
	var TYPE = requireTokenizer$1().TYPE;
	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;

	sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT:
	                this.scanner.next();
	                continue;

	            case WHITESPACE:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};
	return sequence;
}

var create$3;
var hasRequiredCreate$4;

function requireCreate$4 () {
	if (hasRequiredCreate$4) return create$3;
	hasRequiredCreate$4 = 1;
	var OffsetToLocation = requireOffsetToLocation();
	var SyntaxError = require_SyntaxError$1();
	var TokenStream = requireTokenStream();
	var List = requireList();
	var tokenize = requireTokenizer$1();
	var constants = require_const();
	var { findWhiteSpaceStart, cmpStr } = requireUtils$2();
	var sequence = requireSequence();
	var noop = function() {};

	var TYPE = constants.TYPE;
	var NAME = constants.NAME;
	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var IDENT = TYPE.Ident;
	var FUNCTION = TYPE.Function;
	var URL = TYPE.Url;
	var HASH = TYPE.Hash;
	var PERCENTAGE = TYPE.Percentage;
	var NUMBER = TYPE.Number;
	var NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	create$3 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream(),
	        locationMap: new OffsetToLocation(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List();
	        },
	        createSingleNodeList: function(node) {
	            return new List().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var onComment = options.onComment;
	        var ast;

	        tokenize(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        if (typeof onComment === 'function') {
	            parser.scanner.forEachToken((type, start, end) => {
	                if (type === COMMENT) {
	                    const loc = parser.getLocation(start, end);
	                    const value = cmpStr(source, end - 2, end, '*/')
	                        ? source.slice(start + 2, end - 2)
	                        : source.slice(start + 2, end);

	                    onComment(value, loc);
	                }
	            });
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};
	return create$3;
}

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = requireBase64();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);

		  var parts = path.split(/\/+/);
		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		}
		exports.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;

		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   â€œsourcesâ€ entry.  This value is prepended to the individual
		    //   entries in the â€œsourceâ€ field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   â€œsourceRootâ€, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL; 
	} (util));
	return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList.MappingList = MappingList;
	return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = requireBase64Vlq();
	var util = requireUtil();
	var ArraySet = requireArraySet().ArraySet;
	var MappingList = requireMappingList().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMap;
var hasRequiredSourceMap;

function requireSourceMap () {
	if (hasRequiredSourceMap) return sourceMap;
	hasRequiredSourceMap = 1;
	var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};
	return sourceMap;
}

var create$2;
var hasRequiredCreate$3;

function requireCreate$3 () {
	if (hasRequiredCreate$3) return create$2;
	hasRequiredCreate$3 = 1;
	var sourceMap = requireSourceMap();
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};
	return create$2;
}

var create$1;
var hasRequiredCreate$2;

function requireCreate$2 () {
	if (hasRequiredCreate$2) return create$1;
	hasRequiredCreate$2 = 1;
	var List = requireList();

	create$1 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List === false) {
	                        node.children = new List().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};
	return create$1;
}

var create;
var hasRequiredCreate$1;

function requireCreate$1 () {
	if (hasRequiredCreate$1) return create;
	hasRequiredCreate$1 = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var noop = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk, walkReducer) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    var breakWalk = reverse
	                        ? ref.reduceRight(walkReducer, false)
	                        : ref.reduce(walkReducer, false);

	                    if (breakWalk) {
	                        return true;
	                    }
	                } else if (walk(ref)) {
	                    return true;
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	create = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};
	    var breakWalk = Symbol('break-walk');
	    var skipNode = Symbol('skip-node');

	    for (var name in types) {
	        if (hasOwnProperty.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            var enterRet = enter.call(context, node, item, list);

	            if (enterRet === breakWalk) {
	                debugger;
	                return true;
	            }

	            if (enterRet === skipNode) {
	                return false;
	            }

	            if (iterators.hasOwnProperty(node.type)) {
	                if (iterators[node.type](node, context, walkNode, walkReducer)) {
	                    return true;
	                }
	            }

	            if (leave.call(context, node, item, list) === breakWalk) {
	                return true;
	            }

	            return false;
	        }

	        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
	        var enter = noop;
	        var leave = noop;
	        var iterators = iteratorsNatural;
	        var context = {
	            break: breakWalk,
	            skip: skipNode,

	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction(options.enter);
	            leave = ensureFunction(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop && leave === noop) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        walkNode(root);
	    };

	    walk.break = breakWalk;
	    walk.skip = skipNode;

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found = node;
	                return breakWalk;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (fn.call(this, node, item, list)) {
	                    found = node;
	                    return breakWalk;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};
	return create;
}

var clone;
var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone;
	hasRequiredClone = 1;
	var List = requireList();

	clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};
	return clone;
}

var mix_1;
var hasRequiredMix;

function requireMix () {
	if (hasRequiredMix) return mix_1;
	hasRequiredMix = 1;
	const hasOwnProperty = Object.prototype.hasOwnProperty;
	const shape = {
	    generic: true,
	    types: appendOrAssign,
	    atrules: {
	        prelude: appendOrAssignOrNull,
	        descriptors: appendOrAssignOrNull
	    },
	    properties: appendOrAssign,
	    parseContext: assign,
	    scope: deepAssign,
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    return isObject(value)
	        ? Object.assign({}, value)
	        : value;
	}

	function assign(dest, src) {
	    return Object.assign(dest, src);
	}

	function deepAssign(dest, src) {
	    for (const key in src) {
	        if (hasOwnProperty.call(src, key)) {
	            if (isObject(dest[key])) {
	                deepAssign(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }

	    return dest;
	}

	function append(a, b) {
	    if (typeof b === 'string' && /^\s*\|/.test(b)) {
	        return typeof a === 'string'
	            ? a + b
	            : b.replace(/^\s*\|\s*/, '');
	    }

	    return b || null;
	}

	function appendOrAssign(a, b) {
	    if (typeof b === 'string') {
	        return append(a, b);
	    }

	    const result = Object.assign({}, a);
	    for (let key in b) {
	        if (hasOwnProperty.call(b, key)) {
	            result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);
	        }
	    }

	    return result;
	}

	function appendOrAssignOrNull(a, b) {
	    const result = appendOrAssign(a, b);

	    return !isObject(result) || Object.keys(result).length
	        ? result
	        : null;
	}

	function mix(dest, src, shape) {
	    for (const key in shape) {
	        if (hasOwnProperty.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (typeof shape[key] === 'function') {
	                const fn = shape[key];
	                dest[key] = fn({}, dest[key]);
	                dest[key] = fn(dest[key] || {}, src[key]);
	            } else if (isObject(shape[key])) {
	                const result = {};

	                for (let name in dest[key]) {
	                    result[name] = mix({}, dest[key][name], shape[key]);
	                }

	                for (let name in src[key]) {
	                    result[name] = mix(result[name] || {}, src[key][name], shape[key]);
	                }

	                dest[key] = result;
	            } else if (Array.isArray(shape[key])) {
	                const res = {};
	                const innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});

	                for (const [name, value] of Object.entries(dest[key] || {})) {
	                    res[name] = {};
	                    if (value) {
	                        mix(res[name], value, innerShape);
	                    }
	                }

	                for (const name in src[key]) {
	                    if (hasOwnProperty.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }

	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }

	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	mix_1 = (dest, src) => mix(dest, src, shape);
	return mix_1;
}

var hasRequiredCreate;

function requireCreate () {
	if (hasRequiredCreate) return create$4;
	hasRequiredCreate = 1;
	var List = requireList();
	var SyntaxError = require_SyntaxError$1();
	var TokenStream = requireTokenStream();
	var Lexer = requireLexer$1();
	var definitionSyntax = requireDefinitionSyntax();
	var tokenize = requireTokenizer$1();
	var createParser = requireCreate$4();
	var createGenerator = requireCreate$3();
	var createConvertor = requireCreate$2();
	var createWalker = requireCreate$1();
	var clone = requireClone();
	var names = requireNames();
	var mix = requireMix();

	function createSyntax(config) {
	    var parse = createParser(config);
	    var walk = createWalker(config);
	    var generate = createGenerator(config);
	    var convert = createConvertor(walk);

	    var syntax = {
	        List: List,
	        SyntaxError: SyntaxError,
	        TokenStream: TokenStream,
	        Lexer: Lexer,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenize,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix({}, config));
	        },
	        fork: function(extension) {
	            var base = mix({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	create$4.create = function(config) {
	    return createSyntax(mix({}, config));
	};
	return create$4;
}

const require$$0 = {
  "@charset": {"syntax":"@charset \"<charset>\";","groups":["CSS Charsets"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@charset"},
  "@counter-style": {"syntax":"@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}","interfaces":["CSSCounterStyleRule"],"groups":["CSS Counter Styles"],"descriptors":{"additive-symbols":{"syntax":"[ <integer> && <symbol> ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"fallback":{"syntax":"<counter-style-name>","media":"all","initial":"decimal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"negative":{"syntax":"<symbol> <symbol>?","media":"all","initial":"\"-\" hyphen-minus","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"pad":{"syntax":"<integer> && <symbol>","media":"all","initial":"0 \"\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"prefix":{"syntax":"<symbol>","media":"all","initial":"\"\"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"range":{"syntax":"[ [ <integer> | infinite ]{2} ]# | auto","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"speak-as":{"syntax":"auto | bullets | numbers | words | spell-out | <counter-style-name>","media":"all","initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"suffix":{"syntax":"<symbol>","media":"all","initial":"\". \"","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"symbols":{"syntax":"<symbol>+","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"system":{"syntax":"cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]","media":"all","initial":"symbolic","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@counter-style"},
  "@document": {"syntax":"@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}","interfaces":["CSSGroupingRule","CSSConditionRule"],"groups":["CSS Conditional Rules"],"status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@document"},
  "@font-face": {"syntax":"@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}","interfaces":["CSSFontFaceRule"],"groups":["CSS Fonts"],"descriptors":{"font-display":{"syntax":"[ auto | block | swap | fallback | optional ]","media":"visual","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"font-family":{"syntax":"<family-name>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-feature-settings":{"syntax":"normal | <feature-tag-value>#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-variation-settings":{"syntax":"normal | [ <string> <number> ]#","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"font-stretch":{"syntax":"<font-stretch-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-style":{"syntax":"normal | italic | oblique <angle>{0,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-weight":{"syntax":"<font-weight-absolute>{1,2}","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"font-variant":{"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"all","initial":"normal","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"src":{"syntax":"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"unicode-range":{"syntax":"<unicode-range>#","media":"all","initial":"U+0-10FFFF","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-face"},
  "@font-feature-values": {"syntax":"@font-feature-values <family-name># {\n  <feature-value-block-list>\n}","interfaces":["CSSFontFeatureValuesRule"],"groups":["CSS Fonts"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"},
  "@import": {"syntax":"@import [ <string> | <url> ] [ <media-query-list> ]?;","groups":["Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@import"},
  "@keyframes": {"syntax":"@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}","interfaces":["CSSKeyframeRule","CSSKeyframesRule"],"groups":["CSS Animations"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@keyframes"},
  "@media": {"syntax":"@media <media-query-list> {\n  <group-rule-body>\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSMediaRule","CSSCustomMediaRule"],"groups":["CSS Conditional Rules","Media Queries"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@media"},
  "@namespace": {"syntax":"@namespace <namespace-prefix>? [ <string> | <url> ];","groups":["CSS Namespaces"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@namespace"},
  "@page": {"syntax":"@page <page-selector-list> {\n  <page-body>\n}","interfaces":["CSSPageRule"],"groups":["CSS Pages"],"descriptors":{"bleed":{"syntax":"auto | <length>","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"marks":{"syntax":"none | [ crop || cross ]","media":["visual","paged"],"initial":"none","percentages":"no","computed":"asSpecified","order":"orderOfAppearance","status":"standard"},"size":{"syntax":"<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]","media":["visual","paged"],"initial":"auto","percentages":"no","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"orderOfAppearance","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@page"},
  "@property": {"syntax":"@property <custom-property-name> {\n  <declaration-list>\n}","interfaces":["CSS","CSSPropertyRule"],"groups":["CSS Houdini"],"descriptors":{"syntax":{"syntax":"<string>","media":"all","percentages":"no","initial":"n/a (required)","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"inherits":{"syntax":"true | false","media":"all","percentages":"no","initial":"auto","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},"initial-value":{"syntax":"<string>","media":"all","initial":"n/a (required)","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"experimental"}},"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@property"},
  "@supports": {"syntax":"@supports <supports-condition> {\n  <group-rule-body>\n}","interfaces":["CSSGroupingRule","CSSConditionRule","CSSSupportsRule"],"groups":["CSS Conditional Rules"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@supports"},
  "@viewport": {"syntax":"@viewport {\n  <group-rule-body>\n}","interfaces":["CSSViewportRule"],"groups":["CSS Device Adaptation"],"descriptors":{"height":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-height","max-height"],"percentages":["min-height","max-height"],"computed":["min-height","max-height"],"order":"orderOfAppearance","status":"standard"},"max-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"max-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"min-height":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToHeightOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-width":{"syntax":"<viewport-length>","media":["visual","continuous"],"initial":"auto","percentages":"referToWidthOfInitialViewport","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard"},"min-zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"},"orientation":{"syntax":"auto | portrait | landscape","media":["visual","continuous"],"initial":"auto","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"user-zoom":{"syntax":"zoom | fixed","media":["visual","continuous"],"initial":"zoom","percentages":"referToSizeOfBoundingBox","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"viewport-fit":{"syntax":"auto | contain | cover","media":["visual","continuous"],"initial":"auto","percentages":"no","computed":"asSpecified","order":"uniqueOrder","status":"standard"},"width":{"syntax":"<viewport-length>{1,2}","media":["visual","continuous"],"initial":["min-width","max-width"],"percentages":["min-width","max-width"],"computed":["min-width","max-width"],"order":"orderOfAppearance","status":"standard"},"zoom":{"syntax":"auto | <number> | <percentage>","media":["visual","continuous"],"initial":"auto","percentages":"the zoom factor itself","computed":"autoNonNegativeOrPercentage","order":"uniqueOrder","status":"standard"}},"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/@viewport"},
};

const all = {"syntax":"initial | inherit | unset | revert","media":"noPracticalMedia","inherited":false,"animationType":"eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection","percentages":"no","groups":["CSS Miscellaneous"],"initial":"noPracticalInitialValue","appliesto":"allElements","computed":"asSpecifiedAppliesToEachProperty","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/all"};
const animation = {"syntax":"<single-animation>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-iteration-count","animation-direction","animation-fill-mode","animation-play-state"],"appliesto":"allElementsAndPseudos","computed":["animation-name","animation-duration","animation-timing-function","animation-delay","animation-direction","animation-iteration-count","animation-fill-mode","animation-play-state"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation"};
const appearance = {"syntax":"none | auto | textfield | menulist-button | <compat-auto>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"};
const azimuth = {"syntax":"<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards","media":"aural","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Speech"],"initial":"center","appliesto":"allElements","computed":"normalizedAngle","order":"orderOfAppearance","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/azimuth"};
const background$1 = {"syntax":"[ <bg-layer> , ]* <final-bg-layer>","media":"visual","inherited":false,"animationType":["background-color","background-image","background-clip","background-position","background-size","background-repeat","background-attachment"],"percentages":["background-position","background-size"],"groups":["CSS Backgrounds and Borders"],"initial":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"appliesto":"allElements","computed":["background-image","background-position","background-size","background-repeat","background-origin","background-clip","background-attachment","background-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background"};
const border$1 = {"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-color","border-style","border-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-width","border-style","border-color"],"appliesto":"allElements","computed":["border-width","border-style","border-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border"};
const bottom = {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/bottom"};
const clear = {"syntax":"none | left | right | both | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clear"};
const clip = {"syntax":"<shape> | auto","media":"visual","inherited":false,"animationType":"rectangle","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"absolutelyPositionedElements","computed":"autoOrRectangle","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip"};
const color$2 = {"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Color"],"initial":"variesFromBrowserToBrowser","appliesto":"allElements","computed":"translucentValuesRGBAOtherwiseRGB","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color"};
const columns = {"syntax":"<'column-width'> || <'column-count'>","media":"visual","inherited":false,"animationType":["column-width","column-count"],"percentages":"no","groups":["CSS Columns"],"initial":["column-width","column-count"],"appliesto":"blockContainersExceptTableWrappers","computed":["column-width","column-count"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/columns"};
const contain = {"syntax":"none | strict | content | [ size || layout || style || paint ]","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Containment"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/contain"};
const content = {"syntax":"normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"normal","appliesto":"beforeAndAfterPseudos","computed":"normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/content"};
const cursor = {"syntax":"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]","media":["visual","interactive"],"inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/cursor"};
const direction = {"syntax":"ltr | rtl","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"ltr","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/direction"};
const display = {"syntax":"[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Display"],"initial":"inline","appliesto":"allElements","computed":"asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/display"};
const filter = {"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/filter"};
const flex = {"syntax":"none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]","media":"visual","inherited":false,"animationType":["flex-grow","flex-shrink","flex-basis"],"percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-grow","flex-shrink","flex-basis"],"appliesto":"flexItemsAndInFlowPseudos","computed":["flex-grow","flex-shrink","flex-basis"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex"};
const float = {"syntax":"left | right | none | inline-start | inline-end","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"none","appliesto":"allElementsNoEffectIfDisplayNone","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/float"};
const font$1 = {"syntax":"[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar","media":"visual","inherited":true,"animationType":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"percentages":["font-size","line-height"],"groups":["CSS Fonts"],"initial":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"appliesto":"allElements","computed":["font-style","font-variant","font-weight","font-stretch","font-size","line-height","font-family"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font"};
const gap = {"syntax":"<'row-gap'> <'column-gap'>?","media":"visual","inherited":false,"animationType":["row-gap","column-gap"],"percentages":"no","groups":["CSS Box Alignment"],"initial":["row-gap","column-gap"],"appliesto":"multiColumnElementsFlexContainersGridContainers","computed":["row-gap","column-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"};
const grid = {"syntax":"<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-rows","grid-template-columns","grid-auto-rows","grid-auto-columns"],"groups":["CSS Grid Layout"],"initial":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"appliesto":"gridContainers","computed":["grid-template-rows","grid-template-columns","grid-template-areas","grid-auto-rows","grid-auto-columns","grid-auto-flow","grid-column-gap","grid-row-gap","column-gap","row-gap"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid"};
const height = {"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAutoOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/height"};
const hyphens = {"syntax":"none | manual | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"manual","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hyphens"};
const inset = {"syntax":"<'top'>{1,4}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset"};
const isolation = {"syntax":"auto | isolate","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"auto","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/isolation"};
const left = {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/left"};
const margin = {"syntax":"[ <length> | <percentage> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["margin-bottom","margin-left","margin-right","margin-top"],"appliesto":"allElementsExceptTableDisplayTypes","computed":["margin-bottom","margin-left","margin-right","margin-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin"};
const mask = {"syntax":"<mask-layer>#","media":"visual","inherited":false,"animationType":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"percentages":["mask-position"],"groups":["CSS Masking"],"initial":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"appliesto":"allElementsSVGContainerElements","computed":["mask-image","mask-mode","mask-repeat","mask-position","mask-clip","mask-origin","mask-size","mask-composite"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"};
const offset = {"syntax":"[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?","media":"visual","inherited":false,"animationType":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"percentages":["offset-position","offset-distance","offset-anchor"],"groups":["CSS Motion Path"],"initial":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"appliesto":"transformableElements","computed":["offset-position","offset-path","offset-distance","offset-anchor","offset-rotate"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset"};
const opacity = {"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Color"],"initial":"1.0","appliesto":"allElements","computed":"specifiedValueClipped0To1","order":"uniqueOrder","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/opacity"};
const order = {"syntax":"<integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsGridItemsAbsolutelyPositionedContainerChildren","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/order"};
const orphans = {"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/orphans"};
const outline = {"syntax":"[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]","media":["visual","interactive"],"inherited":false,"animationType":["outline-color","outline-width","outline-style"],"percentages":"no","groups":["CSS Basic User Interface"],"initial":["outline-color","outline-style","outline-width"],"appliesto":"allElements","computed":["outline-color","outline-width","outline-style"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline"};
const overflow = {"syntax":"[ visible | hidden | clip | scroll | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":["overflow-x","overflow-y"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow"};
const padding = {"syntax":"[ <length> | <percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":["padding-bottom","padding-left","padding-right","padding-top"],"appliesto":"allElementsExceptInternalTableDisplayTypes","computed":["padding-bottom","padding-left","padding-right","padding-top"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding"};
const perspective = {"syntax":"none | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"absoluteLengthOrNone","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective"};
const position$1 = {"syntax":"static | relative | absolute | sticky | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Positioning"],"initial":"static","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/position"};
const quotes = {"syntax":"none | auto | [ <string> <string> ]+","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Generated Content"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/quotes"};
const resize = {"syntax":"none | both | horizontal | vertical | block | inline","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"elementsWithOverflowNotVisibleAndReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/resize"};
const right = {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/right"};
const rotate = {"syntax":"none | <angle> | [ x | y | z | <number>{3} ] && <angle>","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/rotate"};
const scale = {"syntax":"none | <number>{1,3}","media":"visual","inherited":false,"animationType":"transform","percentages":"no","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scale"};
const top = {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToContainingBlockHeight","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/top"};
const transform = {"syntax":"none | <transform-list>","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform"};
const transition = {"syntax":"<single-transition>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":["transition-delay","transition-duration","transition-property","transition-timing-function"],"appliesto":"allElementsAndPseudos","computed":["transition-delay","transition-duration","transition-property","transition-timing-function"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition"};
const translate = {"syntax":"none | <length-percentage> [ <length-percentage> <length>? ]?","media":"visual","inherited":false,"animationType":"transform","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"none","appliesto":"transformableElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/translate"};
const visibility = {"syntax":"visible | hidden | collapse","media":"visual","inherited":true,"animationType":"visibility","percentages":"no","groups":["CSS Box Model"],"initial":"visible","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/visibility"};
const widows = {"syntax":"<integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"2","appliesto":"blockContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/widows"};
const width = {"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAutoOrAbsoluteLength","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/width"};
const zoom = {"syntax":"normal | reset | <number> | <percentage>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["Microsoft Extensions"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/zoom"};
const require$$1 = {
  "--*": {"syntax":"<declaration-value>","media":"all","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Variables"],"initial":"seeProse","appliesto":"allElements","computed":"asSpecifiedWithVarsSubstituted","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/--*"},
  "-ms-accelerator": {"syntax":"false | true","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"false","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"},
  "-ms-block-progression": {"syntax":"tb | rl | bt | lr","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"tb","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"},
  "-ms-content-zoom-chaining": {"syntax":"none | chained","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"},
  "-ms-content-zooming": {"syntax":"none | zoom","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"zoomForTheTopLevelNoneForTheRest","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"},
  "-ms-content-zoom-limit": {"syntax":"<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-limit-max","-ms-content-zoom-limit-min"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"},
  "-ms-content-zoom-limit-max": {"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"maxZoomFactor","groups":["Microsoft Extensions"],"initial":"400%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"},
  "-ms-content-zoom-limit-min": {"syntax":"<percentage>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"minZoomFactor","groups":["Microsoft Extensions"],"initial":"100%","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"},
  "-ms-content-zoom-snap": {"syntax":"<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-content-zoom-snap-type","-ms-content-zoom-snap-points"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"},
  "-ms-content-zoom-snap-points": {"syntax":"snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0%, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"},
  "-ms-content-zoom-snap-type": {"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"},
  "-ms-filter": {"syntax":"<string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"\"\"","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-filter"},
  "-ms-flow-from": {"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"},
  "-ms-flow-into": {"syntax":"[ none | <custom-ident> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"iframeElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"},
  "-ms-grid-columns": {"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"},
  "-ms-grid-rows": {"syntax":"none | <track-list> | <auto-track-list>","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"},
  "-ms-high-contrast-adjust": {"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"},
  "-ms-hyphenate-limit-chars": {"syntax":"auto | <integer>{1,3}","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"},
  "-ms-hyphenate-limit-lines": {"syntax":"no-limit | <integer>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"no-limit","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"},
  "-ms-hyphenate-limit-zone": {"syntax":"<percentage> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToLineBoxWidth","groups":["Microsoft Extensions"],"initial":"0","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"},
  "-ms-ime-align": {"syntax":"auto | after","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"},
  "-ms-overflow-style": {"syntax":"auto | none | scrollbar | -ms-autohiding-scrollbar","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"},
  "-ms-scrollbar-3dlight-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"},
  "-ms-scrollbar-arrow-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ButtonText","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"},
  "-ms-scrollbar-base-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"},
  "-ms-scrollbar-darkshadow-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"},
  "-ms-scrollbar-face-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDFace","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"},
  "-ms-scrollbar-highlight-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDHighlight","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"},
  "-ms-scrollbar-shadow-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"ThreeDDarkShadow","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"},
  "-ms-scrollbar-track-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"Scrollbar","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"},
  "-ms-scroll-chaining": {"syntax":"chained | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"chained","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"},
  "-ms-scroll-limit": {"syntax":"<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-limit-x-min","-ms-scroll-limit-y-min","-ms-scroll-limit-x-max","-ms-scroll-limit-y-max"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"},
  "-ms-scroll-limit-x-max": {"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"},
  "-ms-scroll-limit-x-min": {"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"},
  "-ms-scroll-limit-y-max": {"syntax":"auto | <length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"},
  "-ms-scroll-limit-y-min": {"syntax":"<length>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"},
  "-ms-scroll-rails": {"syntax":"none | railed","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"railed","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"},
  "-ms-scroll-snap-points-x": {"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"},
  "-ms-scroll-snap-points-y": {"syntax":"snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"snapInterval(0px, 100%)","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"},
  "-ms-scroll-snap-type": {"syntax":"none | proximity | mandatory","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"},
  "-ms-scroll-snap-x": {"syntax":"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-x"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"},
  "-ms-scroll-snap-y": {"syntax":"<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"appliesto":"nonReplacedBlockAndInlineBlockElements","computed":["-ms-scroll-snap-type","-ms-scroll-snap-points-y"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"},
  "-ms-scroll-translation": {"syntax":"none | vertical-to-horizontal","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"},
  "-ms-text-autospace": {"syntax":"none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"},
  "-ms-touch-select": {"syntax":"grippers | none","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"grippers","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"},
  "-ms-user-select": {"syntax":"none | element | text","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"text","appliesto":"nonReplacedElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"},
  "-ms-wrap-flow": {"syntax":"auto | both | start | end | maximum | clear","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"},
  "-ms-wrap-margin": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"0","appliesto":"exclusionElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"},
  "-ms-wrap-through": {"syntax":"wrap | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Microsoft Extensions"],"initial":"wrap","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"},
  "-moz-appearance": {"syntax":"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},
  "-moz-binding": {"syntax":"<url> | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsExceptGeneratedContentOrPseudoElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-binding"},
  "-moz-border-bottom-colors": {"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"},
  "-moz-border-left-colors": {"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"},
  "-moz-border-right-colors": {"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"},
  "-moz-border-top-colors": {"syntax":"<color>+ | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"},
  "-moz-context-properties": {"syntax":"none | [ fill | fill-opacity | stroke | stroke-opacity ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElementsThatCanReferenceImages","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"},
  "-moz-float-edge": {"syntax":"border-box | content-box | margin-box | padding-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"content-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"},
  "-moz-force-broken-image-icon": {"syntax":"<integer [0,1]>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"0","appliesto":"images","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"},
  "-moz-image-region": {"syntax":"<shape> | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"xulImageElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"},
  "-moz-orient": {"syntax":"inline | block | horizontal | vertical","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"inline","appliesto":"anyElementEffectOnProgressAndMeter","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-orient"},
  "-moz-outline-radius": {"syntax":"<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?","media":"visual","inherited":false,"animationType":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"percentages":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"groups":["Mozilla Extensions"],"initial":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"appliesto":"allElements","computed":["-moz-outline-radius-topleft","-moz-outline-radius-topright","-moz-outline-radius-bottomright","-moz-outline-radius-bottomleft"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"},
  "-moz-outline-radius-bottomleft": {"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"},
  "-moz-outline-radius-bottomright": {"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"},
  "-moz-outline-radius-topleft": {"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"},
  "-moz-outline-radius-topright": {"syntax":"<outline-radius>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["Mozilla Extensions"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"},
  "-moz-stack-sizing": {"syntax":"ignore | stretch-to-fit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"stretch-to-fit","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"},
  "-moz-text-blink": {"syntax":"none | blink","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"},
  "-moz-user-focus": {"syntax":"ignore | normal | select-after | select-before | select-menu | select-same | select-all | none","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"},
  "-moz-user-input": {"syntax":"auto | none | enabled | disabled","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"},
  "-moz-user-modify": {"syntax":"read-only | read-write | write-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"},
  "-moz-window-dragging": {"syntax":"drag | no-drag","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"drag","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"},
  "-moz-window-shadow": {"syntax":"default | menu | tooltip | sheet | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"default","appliesto":"allElementsCreatingNativeWindows","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"},
  "-webkit-appearance": {"syntax":"none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"noneButOverriddenInUserAgentCSS","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/appearance"},
  "-webkit-border-before": {"syntax":"<'border-width'> || <'border-style'> || <'color'>","media":"visual","inherited":true,"animationType":"discrete","percentages":["-webkit-border-before-width"],"groups":["WebKit Extensions"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","color"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"},
  "-webkit-border-before-color": {"syntax":"<'color'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard"},
  "-webkit-border-before-style": {"syntax":"<'border-style'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},
  "-webkit-border-before-width": {"syntax":"<'border-width'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["WebKit Extensions"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"nonstandard"},
  "-webkit-box-reflect": {"syntax":"[ above | below | right | left ]? <length>? <image>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"},
  "-webkit-line-clamp": {"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["WebKit Extensions","CSS Overflow"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"},
  "-webkit-mask": {"syntax":"[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"appliesto":"allElements","computed":["-webkit-mask-image","-webkit-mask-repeat","-webkit-mask-attachment","-webkit-mask-position","-webkit-mask-origin","-webkit-mask-clip"],"order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask"},
  "-webkit-mask-attachment": {"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"},
  "-webkit-mask-clip": {"syntax":"[ <box> | border | padding | content | text ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"border","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},
  "-webkit-mask-composite": {"syntax":"<composite-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"source-over","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"},
  "-webkit-mask-image": {"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"none","appliesto":"allElements","computed":"absoluteURIOrNone","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},
  "-webkit-mask-origin": {"syntax":"[ <box> | border | padding | content ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"padding","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},
  "-webkit-mask-position": {"syntax":"<position>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0% 0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},
  "-webkit-mask-position-x": {"syntax":"[ <length-percentage> | left | center | right ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"},
  "-webkit-mask-position-y": {"syntax":"[ <length-percentage> | top | center | bottom ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfElement","groups":["WebKit Extensions"],"initial":"0%","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"},
  "-webkit-mask-repeat": {"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},
  "-webkit-mask-repeat-x": {"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"},
  "-webkit-mask-repeat-y": {"syntax":"repeat | no-repeat | space | round","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"repeat","appliesto":"allElements","computed":"absoluteLengthOrPercentage","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"},
  "-webkit-mask-size": {"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToBackgroundPositioningArea","groups":["WebKit Extensions"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},
  "-webkit-overflow-scrolling": {"syntax":"auto | touch","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"orderOfAppearance","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"},
  "-webkit-tap-highlight-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"black","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"},
  "-webkit-text-fill-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"},
  "-webkit-text-stroke": {"syntax":"<length> || <color>","media":"visual","inherited":true,"animationType":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"percentages":"no","groups":["WebKit Extensions"],"initial":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"appliesto":"allElements","computed":["-webkit-text-stroke-width","-webkit-text-stroke-color"],"order":"canonicalOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"},
  "-webkit-text-stroke-color": {"syntax":"<color>","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["WebKit Extensions"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"},
  "-webkit-text-stroke-width": {"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"0","appliesto":"allElements","computed":"absoluteLength","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"},
  "-webkit-touch-callout": {"syntax":"default | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"default","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"},
  "-webkit-user-modify": {"syntax":"read-only | read-write | read-write-plaintext-only","media":"interactive","inherited":true,"animationType":"discrete","percentages":"no","groups":["WebKit Extensions"],"initial":"read-only","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard"},
  "align-content": {"syntax":"normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-content"},
  "align-items": {"syntax":"normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-items"},
  "align-self": {"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"flexItemsGridItemsAndAbsolutelyPositionedBoxes","computed":"autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-self"},
  "align-tracks": {"syntax":"[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirBlockAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/align-tracks"},
  all,
  animation,
  "animation-delay": {"syntax":"<time>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-delay"},
  "animation-direction": {"syntax":"<single-animation-direction>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"normal","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-direction"},
  "animation-duration": {"syntax":"<time>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-duration"},
  "animation-fill-mode": {"syntax":"<single-animation-fill-mode>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"},
  "animation-iteration-count": {"syntax":"<single-animation-iteration-count>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"1","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"},
  "animation-name": {"syntax":"[ none | <keyframes-name> ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"none","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-name"},
  "animation-play-state": {"syntax":"<single-animation-play-state>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"running","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-play-state"},
  "animation-timing-function": {"syntax":"<timing-function>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Animations"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"},
  appearance,
  "aspect-ratio": {"syntax":"auto | <ratio>","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes","computed":"asSpecified","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"},
  azimuth,
  "backdrop-filter": {"syntax":"none | <filter-function-list>","media":"visual","inherited":false,"animationType":"filterList","percentages":"no","groups":["Filter Effects"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"},
  "backface-visibility": {"syntax":"visible | hidden","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"visible","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/backface-visibility"},
  background: background$1,
  "background-attachment": {"syntax":"<attachment>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"scroll","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-attachment"},
  "background-blend-mode": {"syntax":"<blend-mode>#","media":"none","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElementsSVGContainerGraphicsAndGraphicsReferencingElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"},
  "background-clip": {"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"border-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-clip"},
  "background-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"transparent","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-color"},
  "background-image": {"syntax":"<bg-image>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-image"},
  "background-origin": {"syntax":"<box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-origin"},
  "background-position": {"syntax":"<bg-position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize","groups":["CSS Backgrounds and Borders"],"initial":"0% 0%","appliesto":"allElements","computed":"listEachItemTwoKeywordsOriginOffsets","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position"},
  "background-position-x": {"syntax":"[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"left","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-x"},
  "background-position-y": {"syntax":"[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight","groups":["CSS Backgrounds and Borders"],"initial":"top","appliesto":"allElements","computed":"listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-position-y"},
  "background-repeat": {"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"repeat","appliesto":"allElements","computed":"listEachItemHasTwoKeywordsOnePerDimension","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-repeat"},
  "background-size": {"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"relativeToBackgroundPositioningArea","groups":["CSS Backgrounds and Borders"],"initial":"auto auto","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/background-size"},
  "block-overflow": {"syntax":"clip | ellipsis | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"clip","appliesto":"blockContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},
  "block-size": {"syntax":"<'width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/block-size"},
  border: border$1,
  "border-block": {"syntax":"<'border-top-width'> || <'border-top-style'> || <'color'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block"},
  "border-block-color": {"syntax":"<'border-top-color'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-color"},
  "border-block-style": {"syntax":"<'border-top-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-style"},
  "border-block-width": {"syntax":"<'border-top-width'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-width"},
  "border-block-end": {"syntax":"<'border-top-width'> || <'border-top-style'> || <'color'>","media":"visual","inherited":false,"animationType":["border-block-end-color","border-block-end-style","border-block-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end"},
  "border-block-end-color": {"syntax":"<'border-top-color'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"},
  "border-block-end-style": {"syntax":"<'border-top-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"},
  "border-block-end-width": {"syntax":"<'border-top-width'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"},
  "border-block-start": {"syntax":"<'border-top-width'> || <'border-top-style'> || <'color'>","media":"visual","inherited":false,"animationType":["border-block-start-color","border-block-start-style","border-block-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-block-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start"},
  "border-block-start-color": {"syntax":"<'border-top-color'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"},
  "border-block-start-style": {"syntax":"<'border-top-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"},
  "border-block-start-width": {"syntax":"<'border-top-width'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"},
  "border-bottom": {"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-bottom-color","border-bottom-style","border-bottom-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-bottom-width","border-bottom-style","border-bottom-color"],"appliesto":"allElements","computed":["border-bottom-width","border-bottom-style","border-bottom-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom"},
  "border-bottom-color": {"syntax":"<'border-top-color'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"},
  "border-bottom-left-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"},
  "border-bottom-right-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"},
  "border-bottom-style": {"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"},
  "border-bottom-width": {"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderBottomStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"},
  "border-collapse": {"syntax":"collapse | separate","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"separate","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-collapse"},
  "border-color": {"syntax":"<color>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-color","border-right-color","border-bottom-color","border-left-color"],"appliesto":"allElements","computed":["border-bottom-color","border-left-color","border-right-color","border-top-color"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-color"},
  "border-end-end-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"},
  "border-end-start-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"},
  "border-image": {"syntax":"<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>","media":"visual","inherited":false,"animationType":"discrete","percentages":["border-image-slice","border-image-width"],"groups":["CSS Backgrounds and Borders"],"initial":["border-image-source","border-image-slice","border-image-width","border-image-outset","border-image-repeat"],"appliesto":"allElementsExceptTableElementsWhenCollapse","computed":["border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image"},
  "border-image-outset": {"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-outset"},
  "border-image-repeat": {"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"stretch","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"},
  "border-image-slice": {"syntax":"<number-percentage>{1,4} && fill?","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToSizeOfBorderImage","groups":["CSS Backgrounds and Borders"],"initial":"100%","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"oneToFourPercentagesOrAbsoluteLengthsPlusFill","order":"percentagesOrLengthsFollowedByFill","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-slice"},
  "border-image-source": {"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"noneOrImageWithAbsoluteURI","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-source"},
  "border-image-width": {"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToWidthOrHeightOfBorderImageArea","groups":["CSS Backgrounds and Borders"],"initial":"1","appliesto":"allElementsExceptTableElementsWhenCollapse","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-image-width"},
  "border-inline": {"syntax":"<'border-top-width'> || <'border-top-style'> || <'color'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline"},
  "border-inline-end": {"syntax":"<'border-top-width'> || <'border-top-style'> || <'color'>","media":"visual","inherited":false,"animationType":["border-inline-end-color","border-inline-end-style","border-inline-end-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-end-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end"},
  "border-inline-color": {"syntax":"<'border-top-color'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-color"},
  "border-inline-style": {"syntax":"<'border-top-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-style"},
  "border-inline-width": {"syntax":"<'border-top-width'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-width"},
  "border-inline-end-color": {"syntax":"<'border-top-color'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"},
  "border-inline-end-style": {"syntax":"<'border-top-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"},
  "border-inline-end-width": {"syntax":"<'border-top-width'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"},
  "border-inline-start": {"syntax":"<'border-top-width'> || <'border-top-style'> || <'color'>","media":"visual","inherited":false,"animationType":["border-inline-start-color","border-inline-start-style","border-inline-start-width"],"percentages":"no","groups":["CSS Logical Properties"],"initial":["border-width","border-style","color"],"appliesto":"allElements","computed":["border-width","border-style","border-inline-start-color"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start"},
  "border-inline-start-color": {"syntax":"<'border-top-color'>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Logical Properties"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"},
  "border-inline-start-style": {"syntax":"<'border-top-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Logical Properties"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"},
  "border-inline-start-width": {"syntax":"<'border-top-width'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthZeroIfBorderStyleNoneOrHidden","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"},
  "border-left": {"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-left-color","border-left-style","border-left-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-left-width","border-left-style","border-left-color"],"appliesto":"allElements","computed":["border-left-width","border-left-style","border-left-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left"},
  "border-left-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-color"},
  "border-left-style": {"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-style"},
  "border-left-width": {"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderLeftStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-left-width"},
  "border-radius": {"syntax":"<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?","media":"visual","inherited":false,"animationType":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":["border-top-left-radius","border-top-right-radius","border-bottom-right-radius","border-bottom-left-radius"],"appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-radius"},
  "border-right": {"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-right-color","border-right-style","border-right-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-right-width","border-right-style","border-right-color"],"appliesto":"allElements","computed":["border-right-width","border-right-style","border-right-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right"},
  "border-right-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-color"},
  "border-right-style": {"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-style"},
  "border-right-width": {"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderRightStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-right-width"},
  "border-spacing": {"syntax":"<length> <length>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"0","appliesto":"tableElements","computed":"twoAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-spacing"},
  "border-start-end-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"},
  "border-start-start-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"},
  "border-style": {"syntax":"<line-style>{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-style","border-right-style","border-bottom-style","border-left-style"],"appliesto":"allElements","computed":["border-bottom-style","border-left-style","border-right-style","border-top-style"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-style"},
  "border-top": {"syntax":"<line-width> || <line-style> || <color>","media":"visual","inherited":false,"animationType":["border-top-color","border-top-style","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-top-style","border-top-color"],"appliesto":"allElements","computed":["border-top-width","border-top-style","border-top-color"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top"},
  "border-top-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-color"},
  "border-top-left-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"},
  "border-top-right-radius": {"syntax":"<length-percentage>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfBorderBox","groups":["CSS Backgrounds and Borders"],"initial":"0","appliesto":"allElementsUAsNotRequiredWhenCollapse","computed":"twoAbsoluteLengthOrPercentages","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"},
  "border-top-style": {"syntax":"<line-style>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-style"},
  "border-top-width": {"syntax":"<line-width>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"medium","appliesto":"allElements","computed":"absoluteLengthOr0IfBorderTopStyleNoneOrHidden","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-top-width"},
  "border-width": {"syntax":"<line-width>{1,4}","media":"visual","inherited":false,"animationType":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":["border-top-width","border-right-width","border-bottom-width","border-left-width"],"appliesto":"allElements","computed":["border-bottom-width","border-left-width","border-right-width","border-top-width"],"order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/border-width"},
  bottom,
  "box-align": {"syntax":"start | center | end | baseline | stretch","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"stretch","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-align"},
  "box-decoration-break": {"syntax":"slice | clone","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"slice","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"},
  "box-direction": {"syntax":"normal | reverse | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"normal","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-direction"},
  "box-flex": {"syntax":"<number>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"0","appliesto":"directChildrenOfElementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex"},
  "box-flex-group": {"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"inFlowChildrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-flex-group"},
  "box-lines": {"syntax":"single | multiple","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"single","appliesto":"boxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-lines"},
  "box-ordinal-group": {"syntax":"<integer>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"1","appliesto":"childrenOfBoxElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"},
  "box-orient": {"syntax":"horizontal | vertical | inline-axis | block-axis | inherit","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"inlineAxisHorizontalInXUL","appliesto":"elementsWithDisplayBoxOrInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-orient"},
  "box-pack": {"syntax":"start | center | end | justify","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions","WebKit Extensions"],"initial":"start","appliesto":"elementsWithDisplayMozBoxMozInlineBox","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-pack"},
  "box-shadow": {"syntax":"none | <shadow>#","media":"visual","inherited":false,"animationType":"shadowList","percentages":"no","groups":["CSS Backgrounds and Borders"],"initial":"none","appliesto":"allElements","computed":"absoluteLengthsSpecifiedColorAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-shadow"},
  "box-sizing": {"syntax":"content-box | border-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"content-box","appliesto":"allElementsAcceptingWidthOrHeight","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/box-sizing"},
  "break-after": {"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-after"},
  "break-before": {"syntax":"auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-before"},
  "break-inside": {"syntax":"auto | avoid | avoid-page | avoid-column | avoid-region","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Fragmentation"],"initial":"auto","appliesto":"blockLevelElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/break-inside"},
  "caption-side": {"syntax":"top | bottom | block-start | block-end | inline-start | inline-end","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"top","appliesto":"tableCaptionElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caption-side"},
  "caret-color": {"syntax":"auto | <color>","media":"interactive","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asAutoOrColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/caret-color"},
  clear,
  clip,
  "clip-path": {"syntax":"<clip-source> | [ <basic-shape> || <geometry-box> ] | none","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"referToReferenceBoxWhenSpecifiedOtherwiseBorderBox","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/clip-path"},
  color: color$2,
  "color-adjust": {"syntax":"economy | exact","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Color"],"initial":"economy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/color-adjust"},
  "column-count": {"syntax":"<integer> | auto","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-count"},
  "column-fill": {"syntax":"auto | balance | balance-all","media":"visualInContinuousMediaNoEffectInOverflowColumns","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"balance","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-fill"},
  "column-gap": {"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},
  "column-rule": {"syntax":"<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>","media":"visual","inherited":false,"animationType":["column-rule-color","column-rule-style","column-rule-width"],"percentages":"no","groups":["CSS Columns"],"initial":["column-rule-width","column-rule-style","column-rule-color"],"appliesto":"multicolElements","computed":["column-rule-color","column-rule-style","column-rule-width"],"order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule"},
  "column-rule-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Columns"],"initial":"currentcolor","appliesto":"multicolElements","computed":"computedColor","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-color"},
  "column-rule-style": {"syntax":"<'border-style'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"multicolElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-style"},
  "column-rule-width": {"syntax":"<'border-width'>","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"medium","appliesto":"multicolElements","computed":"absoluteLength0IfColumnRuleStyleNoneOrHidden","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-rule-width"},
  "column-span": {"syntax":"none | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Columns"],"initial":"none","appliesto":"inFlowBlockLevelElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-span"},
  "column-width": {"syntax":"<length> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"no","groups":["CSS Columns"],"initial":"auto","appliesto":"blockContainersExceptTableWrappers","computed":"absoluteLengthZeroOrLarger","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-width"},
  columns,
  contain,
  content,
  "counter-increment": {"syntax":"[ <custom-ident> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-increment"},
  "counter-reset": {"syntax":"[ <custom-ident> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-reset"},
  "counter-set": {"syntax":"[ <custom-ident> <integer>? ]+ | none","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Counter Styles"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/counter-set"},
  cursor,
  direction,
  display,
  "empty-cells": {"syntax":"show | hide","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"show","appliesto":"tableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/empty-cells"},
  filter,
  flex,
  "flex-basis": {"syntax":"content | <'width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToFlexContainersInnerMainSize","groups":["CSS Flexible Box Layout"],"initial":"auto","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"lengthOrPercentageBeforeKeywordIfBothPresent","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-basis"},
  "flex-direction": {"syntax":"row | row-reverse | column | column-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"row","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-direction"},
  "flex-flow": {"syntax":"<'flex-direction'> || <'flex-wrap'>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":["flex-direction","flex-wrap"],"appliesto":"flexContainers","computed":["flex-direction","flex-wrap"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-flow"},
  "flex-grow": {"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"0","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-grow"},
  "flex-shrink": {"syntax":"<number>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"1","appliesto":"flexItemsAndInFlowPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-shrink"},
  "flex-wrap": {"syntax":"nowrap | wrap | wrap-reverse","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Flexible Box Layout"],"initial":"nowrap","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/flex-wrap"},
  float,
  font: font$1,
  "font-family": {"syntax":"[ <family-name> | <generic-family> ]#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"dependsOnUserAgent","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-family"},
  "font-feature-settings": {"syntax":"normal | <feature-tag-value>#","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"},
  "font-kerning": {"syntax":"auto | normal | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-kerning"},
  "font-language-override": {"syntax":"normal | <string>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-language-override"},
  "font-optical-sizing": {"syntax":"auto | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"},
  "font-variation-settings": {"syntax":"normal | [ <string> <number> ]#","media":"visual","inherited":true,"animationType":"transform","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"},
  "font-size": {"syntax":"<absolute-size> | <relative-size> | <length-percentage>","media":"visual","inherited":true,"animationType":"length","percentages":"referToParentElementsFontSize","groups":["CSS Fonts"],"initial":"medium","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size"},
  "font-size-adjust": {"syntax":"none | <number>","media":"visual","inherited":true,"animationType":"number","percentages":"no","groups":["CSS Fonts"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"},
  "font-smooth": {"syntax":"auto | never | always | <absolute-size> | <length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-smooth"},
  "font-stretch": {"syntax":"<font-stretch-absolute>","media":"visual","inherited":true,"animationType":"fontStretch","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-stretch"},
  "font-style": {"syntax":"normal | italic | oblique <angle>?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-style"},
  "font-synthesis": {"syntax":"none | [ weight || style ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"weight style","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-synthesis"},
  "font-variant": {"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant"},
  "font-variant-alternates": {"syntax":"normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"},
  "font-variant-caps": {"syntax":"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"},
  "font-variant-east-asian": {"syntax":"normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"},
  "font-variant-ligatures": {"syntax":"normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"},
  "font-variant-numeric": {"syntax":"normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"},
  "font-variant-position": {"syntax":"normal | sub | super","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-variant-position"},
  "font-weight": {"syntax":"<font-weight-absolute> | bolder | lighter","media":"visual","inherited":true,"animationType":"fontWeight","percentages":"no","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"keywordOrNumericalValueBolderLighterTransformedToRealValue","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/font-weight"},
  gap,
  grid,
  "grid-area": {"syntax":"<grid-line> [ / <grid-line> ]{0,3}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-column-start","grid-row-end","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-area"},
  "grid-auto-columns": {"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"},
  "grid-auto-flow": {"syntax":"[ row | column ] || dense","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"row","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"},
  "grid-auto-rows": {"syntax":"<track-size>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"},
  "grid-column": {"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-column-start","grid-column-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-column-start","grid-column-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column"},
  "grid-column-end": {"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-end"},
  "grid-column-gap": {"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/column-gap"},
  "grid-column-start": {"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-column-start"},
  "grid-gap": {"syntax":"<'grid-row-gap'> <'grid-column-gap'>?","media":"visual","inherited":false,"animationType":["grid-row-gap","grid-column-gap"],"percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-gap","grid-column-gap"],"appliesto":"gridContainers","computed":["grid-row-gap","grid-column-gap"],"order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/gap"},
  "grid-row": {"syntax":"<grid-line> [ / <grid-line> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":["grid-row-start","grid-row-end"],"appliesto":"gridItemsAndBoxesWithinGridContainer","computed":["grid-row-start","grid-row-end"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row"},
  "grid-row-end": {"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-end"},
  "grid-row-gap": {"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"0","appliesto":"gridContainers","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},
  "grid-row-start": {"syntax":"<grid-line>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"auto","appliesto":"gridItemsAndBoxesWithinGridContainer","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-row-start"},
  "grid-template": {"syntax":"none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?","media":"visual","inherited":false,"animationType":"discrete","percentages":["grid-template-columns","grid-template-rows"],"groups":["CSS Grid Layout"],"initial":["grid-template-columns","grid-template-rows","grid-template-areas"],"appliesto":"gridContainers","computed":["grid-template-columns","grid-template-rows","grid-template-areas"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template"},
  "grid-template-areas": {"syntax":"none | <string>+","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"},
  "grid-template-columns": {"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"},
  "grid-template-rows": {"syntax":"none | <track-list> | <auto-track-list> | subgrid <line-name-list>?","media":"visual","inherited":false,"animationType":"simpleListOfLpcDifferenceLpc","percentages":"referToDimensionOfContentArea","groups":["CSS Grid Layout"],"initial":"none","appliesto":"gridContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"},
  "hanging-punctuation": {"syntax":"none | [ first || [ force-end | allow-end ] || last ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"},
  height,
  hyphens,
  "image-orientation": {"syntax":"from-image | <angle> | [ <angle>? flip ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"from-image","appliesto":"allElements","computed":"angleRoundedToNextQuarter","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-orientation"},
  "image-rendering": {"syntax":"auto | crisp-edges | pixelated","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/image-rendering"},
  "image-resolution": {"syntax":"[ from-image || <resolution> ] && snap?","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"1dppx","appliesto":"allElements","computed":"asSpecifiedWithExceptionOfResolution","order":"uniqueOrder","status":"experimental"},
  "ime-mode": {"syntax":"auto | normal | active | inactive | disabled","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"textFields","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ime-mode"},
  "initial-letter": {"syntax":"normal | [ <number> <integer>? ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"normal","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter"},
  "initial-letter-align": {"syntax":"[ auto | alphabetic | hanging | ideographic ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Inline"],"initial":"auto","appliesto":"firstLetterPseudoElementsAndInlineLevelFirstChildren","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"},
  "inline-size": {"syntax":"<'width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"sameAsWidthAndHeight","computed":"sameAsWidthAndHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inline-size"},
  inset,
  "inset-block": {"syntax":"<'top'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block"},
  "inset-block-end": {"syntax":"<'top'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-end"},
  "inset-block-start": {"syntax":"<'top'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalHeightOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-block-start"},
  "inset-inline": {"syntax":"<'top'>{1,2}","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline"},
  "inset-inline-end": {"syntax":"<'top'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"},
  "inset-inline-start": {"syntax":"<'top'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"auto","appliesto":"positionedElements","computed":"sameAsBoxOffsets","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"},
  isolation,
  "justify-content": {"syntax":"normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"flexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-content"},
  "justify-items": {"syntax":"normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"legacy","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-items"},
  "justify-self": {"syntax":"auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"auto","appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-self"},
  "justify-tracks": {"syntax":"[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"normal","appliesto":"gridContainersWithMasonryLayoutInTheirInlineAxis","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/justify-tracks"},
  left,
  "letter-spacing": {"syntax":"normal | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumValueOfAbsoluteLengthOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/letter-spacing"},
  "line-break": {"syntax":"auto | loose | normal | strict | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-break"},
  "line-clamp": {"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},
  "line-height": {"syntax":"normal | <number> | <length> | <percentage>","media":"visual","inherited":true,"animationType":"numberOrLength","percentages":"referToElementFontSize","groups":["CSS Fonts"],"initial":"normal","appliesto":"allElements","computed":"absoluteLengthOrAsSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height"},
  "line-height-step": {"syntax":"<length>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Fonts"],"initial":"0","appliesto":"blockContainers","computed":"absoluteLength","order":"perGrammar","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/line-height-step"},
  "list-style": {"syntax":"<'list-style-type'> || <'list-style-position'> || <'list-style-image'>","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":["list-style-type","list-style-position","list-style-image"],"appliesto":"listItems","computed":["list-style-image","list-style-position","list-style-type"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style"},
  "list-style-image": {"syntax":"<url> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"none","appliesto":"listItems","computed":"noneOrImageWithAbsoluteURI","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-image"},
  "list-style-position": {"syntax":"inside | outside","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"outside","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-position"},
  "list-style-type": {"syntax":"<counter-style> | <string> | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Lists and Counters"],"initial":"disc","appliesto":"listItems","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/list-style-type"},
  margin,
  "margin-block": {"syntax":"<'margin-left'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block"},
  "margin-block-end": {"syntax":"<'margin-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-end"},
  "margin-block-start": {"syntax":"<'margin-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-block-start"},
  "margin-bottom": {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-bottom"},
  "margin-inline": {"syntax":"<'margin-left'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline"},
  "margin-inline-end": {"syntax":"<'margin-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"},
  "margin-inline-start": {"syntax":"<'margin-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"dependsOnLayoutModel","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsMargin","computed":"lengthAbsolutePercentageAsSpecifiedOtherwiseAuto","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"},
  "margin-left": {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-left"},
  "margin-right": {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-right"},
  "margin-top": {"syntax":"<length> | <percentage> | auto","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-top"},
  "margin-trim": {"syntax":"none | in-flow | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"none","appliesto":"blockContainersAndMultiColumnContainers","computed":"asSpecified","order":"perGrammar","alsoAppliesTo":["::first-letter","::first-line"],"status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/margin-trim"},
  mask,
  "mask-border": {"syntax":"<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>","media":"visual","inherited":false,"animationType":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"percentages":["mask-border-slice","mask-border-width"],"groups":["CSS Masking"],"initial":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"appliesto":"allElementsSVGContainerElements","computed":["mask-border-mode","mask-border-outset","mask-border-repeat","mask-border-slice","mask-border-source","mask-border-width"],"order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border"},
  "mask-border-mode": {"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"alpha","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"},
  "mask-border-outset": {"syntax":"[ <length> | <number> ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"},
  "mask-border-repeat": {"syntax":"[ stretch | repeat | round | space ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"stretch","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"},
  "mask-border-slice": {"syntax":"<number-percentage>{1,4} fill?","media":"visual","inherited":false,"animationType":"discrete","percentages":"referToSizeOfMaskBorderImage","groups":["CSS Masking"],"initial":"0","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"},
  "mask-border-source": {"syntax":"none | <image>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-source"},
  "mask-border-width": {"syntax":"[ <length-percentage> | <number> | auto ]{1,4}","media":"visual","inherited":false,"animationType":"discrete","percentages":"relativeToMaskBorderImageArea","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-border-width"},
  "mask-clip": {"syntax":"[ <geometry-box> | no-clip ]#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-clip"},
  "mask-composite": {"syntax":"<compositing-operator>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"add","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-composite"},
  "mask-image": {"syntax":"<mask-reference>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"none","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedURLsAbsolute","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-image"},
  "mask-mode": {"syntax":"<masking-mode>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"match-source","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-mode"},
  "mask-origin": {"syntax":"<geometry-box>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"border-box","appliesto":"allElementsSVGContainerElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-origin"},
  "mask-position": {"syntax":"<position>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToSizeOfMaskPaintingArea","groups":["CSS Masking"],"initial":"center","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoKeywordsForOriginAndOffsets","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-position"},
  "mask-repeat": {"syntax":"<repeat-style>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"no-repeat","appliesto":"allElementsSVGContainerElements","computed":"consistsOfTwoDimensionKeywords","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-repeat"},
  "mask-size": {"syntax":"<bg-size>#","media":"visual","inherited":false,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"no","groups":["CSS Masking"],"initial":"auto","appliesto":"allElementsSVGContainerElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-size"},
  "mask-type": {"syntax":"luminance | alpha","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Masking"],"initial":"luminance","appliesto":"maskElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mask-type"},
  "masonry-auto-flow": {"syntax":"[ pack | next ] || [ definite-first | ordered ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Grid Layout"],"initial":"pack","appliesto":"gridContainersWithMasonryLayout","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"},
  "math-style": {"syntax":"normal | compact","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["MathML"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/math-style"},
  "max-block-size": {"syntax":"<'max-width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-block-size"},
  "max-height": {"syntax":"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentagesNone","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-height"},
  "max-inline-size": {"syntax":"<'max-width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMaxWidthAndMaxHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-inline-size"},
  "max-lines": {"syntax":"none | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Overflow"],"initial":"none","appliesto":"blockContainersExceptMultiColumnContainers","computed":"asSpecified","order":"perGrammar","status":"experimental"},
  "max-width": {"syntax":"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"none","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedAbsoluteLengthOrNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/max-width"},
  "min-block-size": {"syntax":"<'min-width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"blockSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-block-size"},
  "min-height": {"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"regardingHeightOfGeneratedBoxContainingBlockPercentages0","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableColumns","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-height"},
  "min-inline-size": {"syntax":"<'min-width'>","media":"visual","inherited":false,"animationType":"lpc","percentages":"inlineSizeOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"sameAsWidthAndHeight","computed":"sameAsMinWidthAndMinHeight","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-inline-size"},
  "min-width": {"syntax":"auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"auto","appliesto":"allElementsButNonReplacedAndTableRows","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/min-width"},
  "mix-blend-mode": {"syntax":"<blend-mode>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Compositing and Blending"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"},
  "object-fit": {"syntax":"fill | contain | cover | none | scale-down","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Images"],"initial":"fill","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-fit"},
  "object-position": {"syntax":"<position>","media":"visual","inherited":true,"animationType":"repeatableListOfSimpleListOfLpc","percentages":"referToWidthAndHeightOfElement","groups":["CSS Images"],"initial":"50% 50%","appliesto":"replacedElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/object-position"},
  offset,
  "offset-anchor": {"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"relativeToWidthAndHeight","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard"},
  "offset-distance": {"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToTotalPathLength","groups":["CSS Motion Path"],"initial":"0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-distance"},
  "offset-path": {"syntax":"none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"none","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-path"},
  "offset-position": {"syntax":"auto | <position>","media":"visual","inherited":false,"animationType":"position","percentages":"referToSizeOfContainingBlock","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"perGrammar","status":"experimental"},
  "offset-rotate": {"syntax":"[ auto | reverse ] || <angle>","media":"visual","inherited":false,"animationType":"angleOrBasicShapeOrPath","percentages":"no","groups":["CSS Motion Path"],"initial":"auto","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/offset-rotate"},
  opacity,
  order,
  orphans,
  outline,
  "outline-color": {"syntax":"<color> | invert","media":["visual","interactive"],"inherited":false,"animationType":"color","percentages":"no","groups":["CSS Basic User Interface"],"initial":"invertOrCurrentColor","appliesto":"allElements","computed":"invertForTranslucentColorRGBAOtherwiseRGB","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-color"},
  "outline-offset": {"syntax":"<length>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"0","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-offset"},
  "outline-style": {"syntax":"auto | <'border-style'>","media":["visual","interactive"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-style"},
  "outline-width": {"syntax":"<line-width>","media":["visual","interactive"],"inherited":false,"animationType":"length","percentages":"no","groups":["CSS Basic User Interface"],"initial":"medium","appliesto":"allElements","computed":"absoluteLength0ForNone","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/outline-width"},
  overflow,
  "overflow-anchor": {"syntax":"auto | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Anchoring"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard"},
  "overflow-block": {"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},
  "overflow-clip-box": {"syntax":"padding-box | content-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Mozilla Extensions"],"initial":"padding-box","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"},
  "overflow-inline": {"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"perGrammar","status":"standard"},
  "overflow-wrap": {"syntax":"normal | break-word | anywhere","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},
  "overflow-x": {"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-x"},
  "overflow-y": {"syntax":"visible | hidden | clip | scroll | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"visible","appliesto":"blockContainersFlexContainersGridContainers","computed":"asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-y"},
  "overscroll-behavior": {"syntax":"[ contain | none | auto ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"},
  "overscroll-behavior-block": {"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"},
  "overscroll-behavior-inline": {"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"},
  "overscroll-behavior-x": {"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"},
  "overscroll-behavior-y": {"syntax":"contain | none | auto","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Model"],"initial":"auto","appliesto":"nonReplacedBlockAndInlineBlockElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"},
  padding,
  "padding-block": {"syntax":"<'padding-left'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block"},
  "padding-block-end": {"syntax":"<'padding-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-end"},
  "padding-block-start": {"syntax":"<'padding-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-block-start"},
  "padding-bottom": {"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-bottom"},
  "padding-inline": {"syntax":"<'padding-left'>{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline"},
  "padding-inline-end": {"syntax":"<'padding-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"},
  "padding-inline-start": {"syntax":"<'padding-left'>","media":"visual","inherited":false,"animationType":"length","percentages":"logicalWidthOfContainingBlock","groups":["CSS Logical Properties"],"initial":"0","appliesto":"allElements","computed":"asLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"},
  "padding-left": {"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-left"},
  "padding-right": {"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-right"},
  "padding-top": {"syntax":"<length> | <percentage>","media":"visual","inherited":false,"animationType":"length","percentages":"referToWidthOfContainingBlock","groups":["CSS Box Model"],"initial":"0","appliesto":"allElementsExceptInternalTableDisplayTypes","computed":"percentageAsSpecifiedOrAbsoluteLength","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/padding-top"},
  "page-break-after": {"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-after"},
  "page-break-before": {"syntax":"auto | always | avoid | left | right | recto | verso","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-before"},
  "page-break-inside": {"syntax":"auto | avoid","media":["visual","paged"],"inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Pages"],"initial":"auto","appliesto":"blockElementsInNormalFlow","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/page-break-inside"},
  "paint-order": {"syntax":"normal | [ fill || stroke || markers ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/paint-order"},
  perspective,
  "perspective-origin": {"syntax":"<position>","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50%","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/perspective-origin"},
  "place-content": {"syntax":"<'align-content'> <'justify-content'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multilineFlexContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-content"},
  "place-items": {"syntax":"<'align-items'> <'justify-items'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-items","justify-items"],"appliesto":"allElements","computed":["align-items","justify-items"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-items"},
  "place-self": {"syntax":"<'align-self'> <'justify-self'>?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Box Alignment"],"initial":["align-self","justify-self"],"appliesto":"blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems","computed":["align-self","justify-self"],"order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/place-self"},
  "pointer-events": {"syntax":"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["Pointer Events"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/pointer-events"},
  position: position$1,
  quotes,
  resize,
  right,
  rotate,
  "row-gap": {"syntax":"normal | <length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToDimensionOfContentArea","groups":["CSS Box Alignment"],"initial":"normal","appliesto":"multiColumnElementsFlexContainersGridContainers","computed":"asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/row-gap"},
  "ruby-align": {"syntax":"start | center | space-between | space-around","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"space-around","appliesto":"rubyBasesAnnotationsBaseAnnotationContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-align"},
  "ruby-merge": {"syntax":"separate | collapse | auto","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"separate","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental"},
  "ruby-position": {"syntax":"over | under | inter-character","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Ruby"],"initial":"over","appliesto":"rubyAnnotationsContainers","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/ruby-position"},
  scale,
  "scrollbar-color": {"syntax":"auto | dark | light | <color>{2}","media":"visual","inherited":true,"animationType":"color","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"},
  "scrollbar-gutter": {"syntax":"auto | [ stable | always ] && both? && force?","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Overflow"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"},
  "scrollbar-width": {"syntax":"auto | thin | none","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scrollbars"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"},
  "scroll-behavior": {"syntax":"auto | smooth","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSSOM View"],"initial":"auto","appliesto":"scrollingBoxes","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"},
  "scroll-margin": {"syntax":"<length>{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin"},
  "scroll-margin-block": {"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"},
  "scroll-margin-block-start": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"},
  "scroll-margin-block-end": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"},
  "scroll-margin-bottom": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"},
  "scroll-margin-inline": {"syntax":"<length>{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"},
  "scroll-margin-inline-start": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"},
  "scroll-margin-inline-end": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"},
  "scroll-margin-left": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"},
  "scroll-margin-right": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"},
  "scroll-margin-top": {"syntax":"<length>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"no","groups":["CSS Scroll Snap"],"initial":"0","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"},
  "scroll-padding": {"syntax":"[ auto | <length-percentage> ]{1,4}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding"},
  "scroll-padding-block": {"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"},
  "scroll-padding-block-start": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"},
  "scroll-padding-block-end": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"},
  "scroll-padding-bottom": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"},
  "scroll-padding-inline": {"syntax":"[ auto | <length-percentage> ]{1,2}","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"},
  "scroll-padding-inline-start": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"},
  "scroll-padding-inline-end": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"},
  "scroll-padding-left": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"},
  "scroll-padding-right": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"},
  "scroll-padding-top": {"syntax":"auto | <length-percentage>","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"relativeToTheScrollContainersScrollport","groups":["CSS Scroll Snap"],"initial":"auto","appliesto":"scrollContainers","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"},
  "scroll-snap-align": {"syntax":"[ none | start | end | center ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"},
  "scroll-snap-coordinate": {"syntax":"none | <position>#","media":"interactive","inherited":false,"animationType":"position","percentages":"referToBorderBox","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"},
  "scroll-snap-destination": {"syntax":"<position>","media":"interactive","inherited":false,"animationType":"position","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"0px 0px","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"},
  "scroll-snap-points-x": {"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"},
  "scroll-snap-points-y": {"syntax":"none | repeat( <length-percentage> )","media":"interactive","inherited":false,"animationType":"discrete","percentages":"relativeToScrollContainerPaddingBoxAxis","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"},
  "scroll-snap-stop": {"syntax":"normal | always","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"},
  "scroll-snap-type": {"syntax":"none | [ x | y | block | inline | both ] [ mandatory | proximity ]?","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"},
  "scroll-snap-type-x": {"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"},
  "scroll-snap-type-y": {"syntax":"none | mandatory | proximity","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Scroll Snap"],"initial":"none","appliesto":"scrollContainers","computed":"asSpecified","order":"uniqueOrder","status":"obsolete","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"},
  "shape-image-threshold": {"syntax":"<alpha-value>","media":"visual","inherited":false,"animationType":"number","percentages":"no","groups":["CSS Shapes"],"initial":"0.0","appliesto":"floats","computed":"specifiedValueNumberClipped0To1","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"},
  "shape-margin": {"syntax":"<length-percentage>","media":"visual","inherited":false,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Shapes"],"initial":"0","appliesto":"floats","computed":"asSpecifiedRelativeToAbsoluteLengths","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-margin"},
  "shape-outside": {"syntax":"none | <shape-box> || <basic-shape> | <image>","media":"visual","inherited":false,"animationType":"basicShapeOtherwiseNo","percentages":"no","groups":["CSS Shapes"],"initial":"none","appliesto":"floats","computed":"asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/shape-outside"},
  "tab-size": {"syntax":"<integer> | <length>","media":"visual","inherited":true,"animationType":"length","percentages":"no","groups":["CSS Text"],"initial":"8","appliesto":"blockContainers","computed":"specifiedIntegerOrAbsoluteLength","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/tab-size"},
  "table-layout": {"syntax":"auto | fixed","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Table"],"initial":"auto","appliesto":"tableElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/table-layout"},
  "text-align": {"syntax":"start | end | left | right | center | justify | match-parent","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"startOrNamelessValueIfLTRRightIfRTL","appliesto":"blockContainers","computed":"asSpecifiedExceptMatchParent","order":"orderOfAppearance","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align"},
  "text-align-last": {"syntax":"auto | start | end | left | right | center | justify","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"blockContainers","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-align-last"},
  "text-combine-upright": {"syntax":"none | all | [ digits <integer>? ]","media":"visual","inherited":true,"animationType":"notAnimatable","percentages":"no","groups":["CSS Writing Modes"],"initial":"none","appliesto":"nonReplacedInlineElements","computed":"keywordPlusIntegerIfDigits","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"},
  "text-decoration": {"syntax":"<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>","media":"visual","inherited":false,"animationType":["text-decoration-color","text-decoration-style","text-decoration-line","text-decoration-thickness"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-decoration-color","text-decoration-style","text-decoration-line"],"appliesto":"allElements","computed":["text-decoration-line","text-decoration-style","text-decoration-color","text-decoration-thickness"],"order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration"},
  "text-decoration-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"},
  "text-decoration-line": {"syntax":"none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"},
  "text-decoration-skip": {"syntax":"none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"objects","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"},
  "text-decoration-skip-ink": {"syntax":"auto | all | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"},
  "text-decoration-style": {"syntax":"solid | double | dotted | dashed | wavy","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"solid","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"},
  "text-decoration-thickness": {"syntax":"auto | from-font | <length> | <percentage> ","media":"visual","inherited":false,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"},
  "text-emphasis": {"syntax":"<'text-emphasis-style'> || <'text-emphasis-color'>","media":"visual","inherited":false,"animationType":["text-emphasis-color","text-emphasis-style"],"percentages":"no","groups":["CSS Text Decoration"],"initial":["text-emphasis-style","text-emphasis-color"],"appliesto":"allElements","computed":["text-emphasis-style","text-emphasis-color"],"order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis"},
  "text-emphasis-color": {"syntax":"<color>","media":"visual","inherited":false,"animationType":"color","percentages":"no","groups":["CSS Text Decoration"],"initial":"currentcolor","appliesto":"allElements","computed":"computedColor","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"},
  "text-emphasis-position": {"syntax":"[ over | under ] && [ right | left ]","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"over right","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"},
  "text-emphasis-style": {"syntax":"none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"},
  "text-indent": {"syntax":"<length-percentage> && hanging? && each-line?","media":"visual","inherited":true,"animationType":"lpc","percentages":"referToWidthOfContainingBlock","groups":["CSS Text"],"initial":"0","appliesto":"blockContainers","computed":"percentageOrAbsoluteLengthPlusKeywords","order":"lengthOrPercentageBeforeKeywords","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-indent"},
  "text-justify": {"syntax":"auto | inter-character | inter-word | none","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"auto","appliesto":"inlineLevelAndTableCellElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-justify"},
  "text-orientation": {"syntax":"mixed | upright | sideways","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"mixed","appliesto":"allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-orientation"},
  "text-overflow": {"syntax":"[ clip | ellipsis | <string> ]{1,2}","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"clip","appliesto":"blockContainerElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-overflow"},
  "text-rendering": {"syntax":"auto | optimizeSpeed | optimizeLegibility | geometricPrecision","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Miscellaneous"],"initial":"auto","appliesto":"textElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-rendering"},
  "text-shadow": {"syntax":"none | <shadow-t>#","media":"visual","inherited":true,"animationType":"shadowList","percentages":"no","groups":["CSS Text Decoration"],"initial":"none","appliesto":"allElements","computed":"colorPlusThreeAbsoluteLengths","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-shadow"},
  "text-size-adjust": {"syntax":"none | auto | <percentage>","media":"visual","inherited":true,"animationType":"discrete","percentages":"referToSizeOfFont","groups":["CSS Text"],"initial":"autoForSmartphoneBrowsersSupportingInflation","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"experimental","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"},
  "text-transform": {"syntax":"none | capitalize | uppercase | lowercase | full-width | full-size-kana","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"none","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-transform"},
  "text-underline-offset": {"syntax":"auto | <length> | <percentage> ","media":"visual","inherited":true,"animationType":"byComputedValueType","percentages":"referToElementFontSize","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"},
  "text-underline-position": {"syntax":"auto | from-font | [ under || [ left | right ] ]","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text Decoration"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"orderOfAppearance","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/text-underline-position"},
  top,
  "touch-action": {"syntax":"auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["Pointer Events"],"initial":"auto","appliesto":"allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/touch-action"},
  transform,
  "transform-box": {"syntax":"content-box | border-box | fill-box | stroke-box | view-box","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"view-box","appliesto":"transformableElements","computed":"asSpecified","order":"perGrammar","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-box"},
  "transform-origin": {"syntax":"[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?","media":"visual","inherited":false,"animationType":"simpleListOfLpc","percentages":"referToSizeOfBoundingBox","groups":["CSS Transforms"],"initial":"50% 50% 0","appliesto":"transformableElements","computed":"forLengthAbsoluteValueOtherwisePercentage","order":"oneOrTwoValuesLengthAbsoluteKeywordsPercentages","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-origin"},
  "transform-style": {"syntax":"flat | preserve-3d","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transforms"],"initial":"flat","appliesto":"transformableElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transform-style"},
  transition,
  "transition-delay": {"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-delay"},
  "transition-duration": {"syntax":"<time>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"0s","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-duration"},
  "transition-property": {"syntax":"none | <single-transition-property>#","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"all","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-property"},
  "transition-timing-function": {"syntax":"<timing-function>#","media":"interactive","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Transitions"],"initial":"ease","appliesto":"allElementsAndPseudos","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"},
  translate,
  "unicode-bidi": {"syntax":"normal | embed | isolate | bidi-override | isolate-override | plaintext","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"normal","appliesto":"allElementsSomeValuesNoEffectOnNonInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"},
  "user-select": {"syntax":"auto | text | none | contain | all","media":"visual","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Basic User Interface"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"nonstandard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/user-select"},
  "vertical-align": {"syntax":"baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>","media":"visual","inherited":false,"animationType":"length","percentages":"referToLineHeight","groups":["CSS Table"],"initial":"baseline","appliesto":"inlineLevelAndTableCellElements","computed":"absoluteLengthOrKeyword","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/vertical-align"},
  visibility,
  "white-space": {"syntax":"normal | pre | nowrap | pre-wrap | pre-line | break-spaces","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/white-space"},
  widows,
  width,
  "will-change": {"syntax":"auto | <animateable-feature>#","media":"all","inherited":false,"animationType":"discrete","percentages":"no","groups":["CSS Will Change"],"initial":"auto","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/will-change"},
  "word-break": {"syntax":"normal | break-all | keep-all | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-break"},
  "word-spacing": {"syntax":"normal | <length-percentage>","media":"visual","inherited":true,"animationType":"length","percentages":"referToWidthOfAffectedGlyph","groups":["CSS Text"],"initial":"normal","appliesto":"allElements","computed":"optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal","order":"uniqueOrder","alsoAppliesTo":["::first-letter","::first-line","::placeholder"],"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/word-spacing"},
  "word-wrap": {"syntax":"normal | break-word","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Text"],"initial":"normal","appliesto":"nonReplacedInlineElements","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"},
  "writing-mode": {"syntax":"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr","media":"visual","inherited":true,"animationType":"discrete","percentages":"no","groups":["CSS Writing Modes"],"initial":"horizontal-tb","appliesto":"allElementsExceptTableRowColumnGroupsTableRowsColumns","computed":"asSpecified","order":"uniqueOrder","status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/writing-mode"},
  "z-index": {"syntax":"auto | <integer>","media":"visual","inherited":false,"animationType":"integer","percentages":"no","groups":["CSS Positioning"],"initial":"auto","appliesto":"positionedElements","computed":"asSpecified","order":"uniqueOrder","stacking":true,"status":"standard","mdn_url":"https://developer.mozilla.org/docs/Web/CSS/z-index"},
  zoom,
};

const attachment = {"syntax":"scroll | fixed | local"};
const box = {"syntax":"border-box | padding-box | content-box"};
const color$1 = {"syntax":"<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"};
const combinator = {"syntax":"'>' | '+' | '~' | [ '||' ]"};
const gradient = {"syntax":"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"};
const hue = {"syntax":"<number> | <angle>"};
const image = {"syntax":"<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"};
const nth$1 = {"syntax":"<an-plus-b> | even | odd"};
const position = {"syntax":"[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"};
const quote = {"syntax":"open-quote | close-quote | no-open-quote | no-close-quote"};
const shadow = {"syntax":"inset? && <length>{2,4} && <color>?"};
const shape = {"syntax":"rect(<top>, <right>, <bottom>, <left>)"};
const size = {"syntax":"closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"};
const symbol = {"syntax":"<string> | <image> | <custom-ident>"};
const target = {"syntax":"<target-counter()> | <target-counters()> | <target-text()>"};
const require$$2$1 = {
  "absolute-size": {"syntax":"xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"},
  "alpha-value": {"syntax":"<number> | <percentage>"},
  "angle-percentage": {"syntax":"<angle> | <percentage>"},
  "angular-color-hint": {"syntax":"<angle-percentage>"},
  "angular-color-stop": {"syntax":"<color> && <color-stop-angle>?"},
  "angular-color-stop-list": {"syntax":"[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"},
  "animateable-feature": {"syntax":"scroll-position | contents | <custom-ident>"},
  attachment,
  "attr()": {"syntax":"attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"},
  "attr-matcher": {"syntax":"[ '~' | '|' | '^' | '$' | '*' ]? '='"},
  "attr-modifier": {"syntax":"i | s"},
  "attribute-selector": {"syntax":"'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"},
  "auto-repeat": {"syntax":"repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},
  "auto-track-list": {"syntax":"[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"},
  "baseline-position": {"syntax":"[ first | last ]? baseline"},
  "basic-shape": {"syntax":"<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"},
  "bg-image": {"syntax":"none | <image>"},
  "bg-layer": {"syntax":"<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},
  "bg-position": {"syntax":"[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"},
  "bg-size": {"syntax":"[ <length-percentage> | auto ]{1,2} | cover | contain"},
  "blur()": {"syntax":"blur( <length> )"},
  "blend-mode": {"syntax":"normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"},
  box,
  "brightness()": {"syntax":"brightness( <number-percentage> )"},
  "calc()": {"syntax":"calc( <calc-sum> )"},
  "calc-sum": {"syntax":"<calc-product> [ [ '+' | '-' ] <calc-product> ]*"},
  "calc-product": {"syntax":"<calc-value> [ '*' <calc-value> | '/' <number> ]*"},
  "calc-value": {"syntax":"<number> | <dimension> | <percentage> | ( <calc-sum> )"},
  "cf-final-image": {"syntax":"<image> | <color>"},
  "cf-mixing-image": {"syntax":"<percentage>? && <image>"},
  "circle()": {"syntax":"circle( [ <shape-radius> ]? [ at <position> ]? )"},
  "clamp()": {"syntax":"clamp( <calc-sum>#{3} )"},
  "class-selector": {"syntax":"'.' <ident-token>"},
  "clip-source": {"syntax":"<url>"},
  color: color$1,
  "color-stop": {"syntax":"<color-stop-length> | <color-stop-angle>"},
  "color-stop-angle": {"syntax":"<angle-percentage>{1,2}"},
  "color-stop-length": {"syntax":"<length-percentage>{1,2}"},
  "color-stop-list": {"syntax":"[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"},
  combinator,
  "common-lig-values": {"syntax":"[ common-ligatures | no-common-ligatures ]"},
  "compat-auto": {"syntax":"searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"},
  "composite-style": {"syntax":"clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"},
  "compositing-operator": {"syntax":"add | subtract | intersect | exclude"},
  "compound-selector": {"syntax":"[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"},
  "compound-selector-list": {"syntax":"<compound-selector>#"},
  "complex-selector": {"syntax":"<compound-selector> [ <combinator>? <compound-selector> ]*"},
  "complex-selector-list": {"syntax":"<complex-selector>#"},
  "conic-gradient()": {"syntax":"conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"},
  "contextual-alt-values": {"syntax":"[ contextual | no-contextual ]"},
  "content-distribution": {"syntax":"space-between | space-around | space-evenly | stretch"},
  "content-list": {"syntax":"[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"},
  "content-position": {"syntax":"center | start | end | flex-start | flex-end"},
  "content-replacement": {"syntax":"<image>"},
  "contrast()": {"syntax":"contrast( [ <number-percentage> ] )"},
  "counter()": {"syntax":"counter( <custom-ident>, <counter-style>? )"},
  "counter-style": {"syntax":"<counter-style-name> | symbols()"},
  "counter-style-name": {"syntax":"<custom-ident>"},
  "counters()": {"syntax":"counters( <custom-ident>, <string>, <counter-style>? )"},
  "cross-fade()": {"syntax":"cross-fade( <cf-mixing-image> , <cf-final-image>? )"},
  "cubic-bezier-timing-function": {"syntax":"ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"},
  "deprecated-system-color": {"syntax":"ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"},
  "discretionary-lig-values": {"syntax":"[ discretionary-ligatures | no-discretionary-ligatures ]"},
  "display-box": {"syntax":"contents | none"},
  "display-inside": {"syntax":"flow | flow-root | table | flex | grid | ruby"},
  "display-internal": {"syntax":"table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"},
  "display-legacy": {"syntax":"inline-block | inline-list-item | inline-table | inline-flex | inline-grid"},
  "display-listitem": {"syntax":"<display-outside>? && [ flow | flow-root ]? && list-item"},
  "display-outside": {"syntax":"block | inline | run-in"},
  "drop-shadow()": {"syntax":"drop-shadow( <length>{2,3} <color>? )"},
  "east-asian-variant-values": {"syntax":"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"},
  "east-asian-width-values": {"syntax":"[ full-width | proportional-width ]"},
  "element()": {"syntax":"element( <id-selector> )"},
  "ellipse()": {"syntax":"ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"},
  "ending-shape": {"syntax":"circle | ellipse"},
  "env()": {"syntax":"env( <custom-ident> , <declaration-value>? )"},
  "explicit-track-list": {"syntax":"[ <line-names>? <track-size> ]+ <line-names>?"},
  "family-name": {"syntax":"<string> | <custom-ident>+"},
  "feature-tag-value": {"syntax":"<string> [ <integer> | on | off ]?"},
  "feature-type": {"syntax":"@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"},
  "feature-value-block": {"syntax":"<feature-type> '{' <feature-value-declaration-list> '}'"},
  "feature-value-block-list": {"syntax":"<feature-value-block>+"},
  "feature-value-declaration": {"syntax":"<custom-ident>: <integer>+;"},
  "feature-value-declaration-list": {"syntax":"<feature-value-declaration>"},
  "feature-value-name": {"syntax":"<custom-ident>"},
  "fill-rule": {"syntax":"nonzero | evenodd"},
  "filter-function": {"syntax":"<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"},
  "filter-function-list": {"syntax":"[ <filter-function> | <url> ]+"},
  "final-bg-layer": {"syntax":"<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"},
  "fit-content()": {"syntax":"fit-content( [ <length> | <percentage> ] )"},
  "fixed-breadth": {"syntax":"<length-percentage>"},
  "fixed-repeat": {"syntax":"repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"},
  "fixed-size": {"syntax":"<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"},
  "font-stretch-absolute": {"syntax":"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"},
  "font-variant-css21": {"syntax":"[ normal | small-caps ]"},
  "font-weight-absolute": {"syntax":"normal | bold | <number [1,1000]>"},
  "frequency-percentage": {"syntax":"<frequency> | <percentage>"},
  "general-enclosed": {"syntax":"[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"},
  "generic-family": {"syntax":"serif | sans-serif | cursive | fantasy | monospace"},
  "generic-name": {"syntax":"serif | sans-serif | cursive | fantasy | monospace"},
  "geometry-box": {"syntax":"<shape-box> | fill-box | stroke-box | view-box"},
  gradient,
  "grayscale()": {"syntax":"grayscale( <number-percentage> )"},
  "grid-line": {"syntax":"auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"},
  "historical-lig-values": {"syntax":"[ historical-ligatures | no-historical-ligatures ]"},
  "hsl()": {"syntax":"hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"},
  "hsla()": {"syntax":"hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"},
  hue,
  "hue-rotate()": {"syntax":"hue-rotate( <angle> )"},
  "id-selector": {"syntax":"<hash-token>"},
  image,
  "image()": {"syntax":"image( <image-tags>? [ <image-src>? , <color>? ]! )"},
  "image-set()": {"syntax":"image-set( <image-set-option># )"},
  "image-set-option": {"syntax":"[ <image> | <string> ] <resolution>"},
  "image-src": {"syntax":"<url> | <string>"},
  "image-tags": {"syntax":"ltr | rtl"},
  "inflexible-breadth": {"syntax":"<length> | <percentage> | min-content | max-content | auto"},
  "inset()": {"syntax":"inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"},
  "invert()": {"syntax":"invert( <number-percentage> )"},
  "keyframes-name": {"syntax":"<custom-ident> | <string>"},
  "keyframe-block": {"syntax":"<keyframe-selector># {\n  <declaration-list>\n}"},
  "keyframe-block-list": {"syntax":"<keyframe-block>+"},
  "keyframe-selector": {"syntax":"from | to | <percentage>"},
  "leader()": {"syntax":"leader( <leader-type> )"},
  "leader-type": {"syntax":"dotted | solid | space | <string>"},
  "length-percentage": {"syntax":"<length> | <percentage>"},
  "line-names": {"syntax":"'[' <custom-ident>* ']'"},
  "line-name-list": {"syntax":"[ <line-names> | <name-repeat> ]+"},
  "line-style": {"syntax":"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"},
  "line-width": {"syntax":"<length> | thin | medium | thick"},
  "linear-color-hint": {"syntax":"<length-percentage>"},
  "linear-color-stop": {"syntax":"<color> <color-stop-length>?"},
  "linear-gradient()": {"syntax":"linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},
  "mask-layer": {"syntax":"<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"},
  "mask-position": {"syntax":"[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"},
  "mask-reference": {"syntax":"none | <image> | <mask-source>"},
  "mask-source": {"syntax":"<url>"},
  "masking-mode": {"syntax":"alpha | luminance | match-source"},
  "matrix()": {"syntax":"matrix( <number>#{6} )"},
  "matrix3d()": {"syntax":"matrix3d( <number>#{16} )"},
  "max()": {"syntax":"max( <calc-sum># )"},
  "media-and": {"syntax":"<media-in-parens> [ and <media-in-parens> ]+"},
  "media-condition": {"syntax":"<media-not> | <media-and> | <media-or> | <media-in-parens>"},
  "media-condition-without-or": {"syntax":"<media-not> | <media-and> | <media-in-parens>"},
  "media-feature": {"syntax":"( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"},
  "media-in-parens": {"syntax":"( <media-condition> ) | <media-feature> | <general-enclosed>"},
  "media-not": {"syntax":"not <media-in-parens>"},
  "media-or": {"syntax":"<media-in-parens> [ or <media-in-parens> ]+"},
  "media-query": {"syntax":"<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"},
  "media-query-list": {"syntax":"<media-query>#"},
  "media-type": {"syntax":"<ident>"},
  "mf-boolean": {"syntax":"<mf-name>"},
  "mf-name": {"syntax":"<ident>"},
  "mf-plain": {"syntax":"<mf-name> : <mf-value>"},
  "mf-range": {"syntax":"<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"},
  "mf-value": {"syntax":"<number> | <dimension> | <ident> | <ratio>"},
  "min()": {"syntax":"min( <calc-sum># )"},
  "minmax()": {"syntax":"minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"},
  "named-color": {"syntax":"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"},
  "namespace-prefix": {"syntax":"<ident>"},
  "ns-prefix": {"syntax":"[ <ident-token> | '*' ]? '|'"},
  "number-percentage": {"syntax":"<number> | <percentage>"},
  "numeric-figure-values": {"syntax":"[ lining-nums | oldstyle-nums ]"},
  "numeric-fraction-values": {"syntax":"[ diagonal-fractions | stacked-fractions ]"},
  "numeric-spacing-values": {"syntax":"[ proportional-nums | tabular-nums ]"},
  nth: nth$1,
  "opacity()": {"syntax":"opacity( [ <number-percentage> ] )"},
  "overflow-position": {"syntax":"unsafe | safe"},
  "outline-radius": {"syntax":"<length> | <percentage>"},
  "page-body": {"syntax":"<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"},
  "page-margin-box": {"syntax":"<page-margin-box-type> '{' <declaration-list> '}'"},
  "page-margin-box-type": {"syntax":"@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"},
  "page-selector-list": {"syntax":"[ <page-selector># ]?"},
  "page-selector": {"syntax":"<pseudo-page>+ | <ident> <pseudo-page>*"},
  "path()": {"syntax":"path( [ <fill-rule>, ]? <string> )"},
  "paint()": {"syntax":"paint( <ident>, <declaration-value>? )"},
  "perspective()": {"syntax":"perspective( <length> )"},
  "polygon()": {"syntax":"polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"},
  position,
  "pseudo-class-selector": {"syntax":"':' <ident-token> | ':' <function-token> <any-value> ')'"},
  "pseudo-element-selector": {"syntax":"':' <pseudo-class-selector>"},
  "pseudo-page": {"syntax":": [ left | right | first | blank ]"},
  quote,
  "radial-gradient()": {"syntax":"radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},
  "relative-selector": {"syntax":"<combinator>? <complex-selector>"},
  "relative-selector-list": {"syntax":"<relative-selector>#"},
  "relative-size": {"syntax":"larger | smaller"},
  "repeat-style": {"syntax":"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"},
  "repeating-linear-gradient()": {"syntax":"repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"},
  "repeating-radial-gradient()": {"syntax":"repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"},
  "rgb()": {"syntax":"rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"},
  "rgba()": {"syntax":"rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"},
  "rotate()": {"syntax":"rotate( [ <angle> | <zero> ] )"},
  "rotate3d()": {"syntax":"rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"},
  "rotateX()": {"syntax":"rotateX( [ <angle> | <zero> ] )"},
  "rotateY()": {"syntax":"rotateY( [ <angle> | <zero> ] )"},
  "rotateZ()": {"syntax":"rotateZ( [ <angle> | <zero> ] )"},
  "saturate()": {"syntax":"saturate( <number-percentage> )"},
  "scale()": {"syntax":"scale( <number> , <number>? )"},
  "scale3d()": {"syntax":"scale3d( <number> , <number> , <number> )"},
  "scaleX()": {"syntax":"scaleX( <number> )"},
  "scaleY()": {"syntax":"scaleY( <number> )"},
  "scaleZ()": {"syntax":"scaleZ( <number> )"},
  "self-position": {"syntax":"center | start | end | self-start | self-end | flex-start | flex-end"},
  "shape-radius": {"syntax":"<length-percentage> | closest-side | farthest-side"},
  "skew()": {"syntax":"skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"},
  "skewX()": {"syntax":"skewX( [ <angle> | <zero> ] )"},
  "skewY()": {"syntax":"skewY( [ <angle> | <zero> ] )"},
  "sepia()": {"syntax":"sepia( <number-percentage> )"},
  shadow,
  "shadow-t": {"syntax":"[ <length>{2,3} && <color>? ]"},
  shape,
  "shape-box": {"syntax":"<box> | margin-box"},
  "side-or-corner": {"syntax":"[ left | right ] || [ top | bottom ]"},
  "single-animation": {"syntax":"<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"},
  "single-animation-direction": {"syntax":"normal | reverse | alternate | alternate-reverse"},
  "single-animation-fill-mode": {"syntax":"none | forwards | backwards | both"},
  "single-animation-iteration-count": {"syntax":"infinite | <number>"},
  "single-animation-play-state": {"syntax":"running | paused"},
  "single-transition": {"syntax":"[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"},
  "single-transition-property": {"syntax":"all | <custom-ident>"},
  size,
  "step-position": {"syntax":"jump-start | jump-end | jump-none | jump-both | start | end"},
  "step-timing-function": {"syntax":"step-start | step-end | steps(<integer>[, <step-position>]?)"},
  "subclass-selector": {"syntax":"<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"},
  "supports-condition": {"syntax":"not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"},
  "supports-in-parens": {"syntax":"( <supports-condition> ) | <supports-feature> | <general-enclosed>"},
  "supports-feature": {"syntax":"<supports-decl> | <supports-selector-fn>"},
  "supports-decl": {"syntax":"( <declaration> )"},
  "supports-selector-fn": {"syntax":"selector( <complex-selector> )"},
  symbol,
  target,
  "target-counter()": {"syntax":"target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"},
  "target-counters()": {"syntax":"target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"},
  "target-text()": {"syntax":"target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"},
  "time-percentage": {"syntax":"<time> | <percentage>"},
  "timing-function": {"syntax":"linear | <cubic-bezier-timing-function> | <step-timing-function>"},
  "track-breadth": {"syntax":"<length-percentage> | <flex> | min-content | max-content | auto"},
  "track-list": {"syntax":"[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"},
  "track-repeat": {"syntax":"repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"},
  "track-size": {"syntax":"<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"},
  "transform-function": {"syntax":"<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"},
  "transform-list": {"syntax":"<transform-function>+"},
  "translate()": {"syntax":"translate( <length-percentage> , <length-percentage>? )"},
  "translate3d()": {"syntax":"translate3d( <length-percentage> , <length-percentage> , <length> )"},
  "translateX()": {"syntax":"translateX( <length-percentage> )"},
  "translateY()": {"syntax":"translateY( <length-percentage> )"},
  "translateZ()": {"syntax":"translateZ( <length> )"},
  "type-or-unit": {"syntax":"string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"},
  "type-selector": {"syntax":"<wq-name> | <ns-prefix>? '*'"},
  "var()": {"syntax":"var( <custom-property-name> , <declaration-value>? )"},
  "viewport-length": {"syntax":"auto | <length-percentage>"},
  "wq-name": {"syntax":"<ns-prefix>? <ident-token>"},
};

const atrules = {"charset":{"prelude":"<string>"},"font-face":{"descriptors":{"unicode-range":{"comment":"replaces <unicode-range>, an old production name","syntax":"<urange>#"}}}};
const properties = /* #__PURE__ */ JSON.parse("{\"-moz-background-clip\":{\"comment\":\"deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip\",\"syntax\":\"padding | border\"},\"-moz-border-radius-bottomleft\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius\",\"syntax\":\"<'border-bottom-left-radius'>\"},\"-moz-border-radius-bottomright\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius\",\"syntax\":\"<'border-bottom-right-radius'>\"},\"-moz-border-radius-topleft\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius\",\"syntax\":\"<'border-top-left-radius'>\"},\"-moz-border-radius-topright\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius\",\"syntax\":\"<'border-bottom-right-radius'>\"},\"-moz-control-character-visibility\":{\"comment\":\"firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588\",\"syntax\":\"visible | hidden\"},\"-moz-osx-font-smoothing\":{\"comment\":\"misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\",\"syntax\":\"auto | grayscale\"},\"-moz-user-select\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select\",\"syntax\":\"none | text | all | -moz-none\"},\"-ms-flex-align\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align\",\"syntax\":\"start | end | center | baseline | stretch\"},\"-ms-flex-item-align\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align\",\"syntax\":\"auto | start | end | center | baseline | stretch\"},\"-ms-flex-line-pack\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack\",\"syntax\":\"start | end | center | justify | distribute | stretch\"},\"-ms-flex-negative\":{\"comment\":\"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\"syntax\":\"<'flex-shrink'>\"},\"-ms-flex-pack\":{\"comment\":\"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack\",\"syntax\":\"start | end | center | justify | distribute\"},\"-ms-flex-order\":{\"comment\":\"misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx\",\"syntax\":\"<integer>\"},\"-ms-flex-positive\":{\"comment\":\"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\"syntax\":\"<'flex-grow'>\"},\"-ms-flex-preferred-size\":{\"comment\":\"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\"syntax\":\"<'flex-basis'>\"},\"-ms-interpolation-mode\":{\"comment\":\"https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx\",\"syntax\":\"nearest-neighbor | bicubic\"},\"-ms-grid-column-align\":{\"comment\":\"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx\",\"syntax\":\"start | end | center | stretch\"},\"-ms-grid-row-align\":{\"comment\":\"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx\",\"syntax\":\"start | end | center | stretch\"},\"-ms-hyphenate-limit-last\":{\"comment\":\"misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits\",\"syntax\":\"none | always | column | page | spread\"},\"-webkit-appearance\":{\"comment\":\"webkit specific keywords\",\"references\":[\"http://css-infos.net/property/-webkit-appearance\"],\"syntax\":\"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button\"},\"-webkit-background-clip\":{\"comment\":\"https://developer.mozilla.org/en/docs/Web/CSS/background-clip\",\"syntax\":\"[ <box> | border | padding | content | text ]#\"},\"-webkit-column-break-after\":{\"comment\":\"added, http://help.dottoro.com/lcrthhhv.php\",\"syntax\":\"always | auto | avoid\"},\"-webkit-column-break-before\":{\"comment\":\"added, http://help.dottoro.com/lcxquvkf.php\",\"syntax\":\"always | auto | avoid\"},\"-webkit-column-break-inside\":{\"comment\":\"added, http://help.dottoro.com/lclhnthl.php\",\"syntax\":\"always | auto | avoid\"},\"-webkit-font-smoothing\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\",\"syntax\":\"auto | none | antialiased | subpixel-antialiased\"},\"-webkit-mask-box-image\":{\"comment\":\"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image\",\"syntax\":\"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?\"},\"-webkit-print-color-adjust\":{\"comment\":\"missed\",\"references\":[\"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust\"],\"syntax\":\"economy | exact\"},\"-webkit-text-security\":{\"comment\":\"missed; http://help.dottoro.com/lcbkewgt.php\",\"syntax\":\"none | circle | disc | square\"},\"-webkit-user-drag\":{\"comment\":\"missed; http://help.dottoro.com/lcbixvwm.php\",\"syntax\":\"none | element | auto\"},\"-webkit-user-select\":{\"comment\":\"auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select\",\"syntax\":\"auto | none | text | all\"},\"alignment-baseline\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty\"],\"syntax\":\"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical\"},\"baseline-shift\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty\"],\"syntax\":\"baseline | sub | super | <svg-length>\"},\"behavior\":{\"comment\":\"added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx\",\"syntax\":\"<url>+\"},\"clip-rule\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty\"],\"syntax\":\"nonzero | evenodd\"},\"cue\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<'cue-before'> <'cue-after'>?\"},\"cue-after\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<url> <decibel>? | none\"},\"cue-before\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<url> <decibel>? | none\"},\"cursor\":{\"comment\":\"added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out\",\"references\":[\"https://www.sitepoint.com/css3-cursor-styles/\"],\"syntax\":\"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]\"},\"display\":{\"comment\":\"extended with -ms-flexbox\",\"syntax\":\"| <-non-standard-display>\"},\"position\":{\"comment\":\"extended with -webkit-sticky\",\"syntax\":\"| -webkit-sticky\"},\"dominant-baseline\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty\"],\"syntax\":\"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\"},\"image-rendering\":{\"comment\":\"extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality\",\"references\":[\"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering\",\"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty\"],\"syntax\":\"| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>\"},\"fill\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#FillProperty\"],\"syntax\":\"<paint>\"},\"fill-opacity\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#FillProperty\"],\"syntax\":\"<number-zero-one>\"},\"fill-rule\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#FillProperty\"],\"syntax\":\"nonzero | evenodd\"},\"filter\":{\"comment\":\"extend with IE legacy syntaxes\",\"syntax\":\"| <-ms-filter-function-list>\"},\"glyph-orientation-horizontal\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty\"],\"syntax\":\"<angle>\"},\"glyph-orientation-vertical\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty\"],\"syntax\":\"<angle>\"},\"kerning\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#KerningProperty\"],\"syntax\":\"auto | <svg-length>\"},\"letter-spacing\":{\"comment\":\"fix syntax <length> -> <length-percentage>\",\"references\":[\"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing\"],\"syntax\":\"normal | <length-percentage>\"},\"marker\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"marker-end\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"marker-mid\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"marker-start\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"],\"syntax\":\"none | <url>\"},\"max-width\":{\"comment\":\"fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width\",\"syntax\":\"none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>\"},\"width\":{\"comment\":\"per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)\",\"syntax\":\"| fit-content | -moz-fit-content | -webkit-fit-content\"},\"min-width\":{\"comment\":\"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width\",\"syntax\":\"auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>\"},\"overflow\":{\"comment\":\"extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\",\"syntax\":\"| <-non-standard-overflow>\"},\"pause\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<'pause-before'> <'pause-after'>?\"},\"pause-after\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"pause-before\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"rest\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<'rest-before'> <'rest-after'>?\"},\"rest-after\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"rest-before\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<time> | none | x-weak | weak | medium | strong | x-strong\"},\"shape-rendering\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert\"],\"syntax\":\"auto | optimizeSpeed | crispEdges | geometricPrecision\"},\"src\":{\"comment\":\"added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src\",\"syntax\":\"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#\"},\"speak\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"auto | none | normal\"},\"speak-as\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]\"},\"stroke\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<paint>\"},\"stroke-dasharray\":{\"comment\":\"added SVG property; a list of comma and/or white space separated <length>s and <percentage>s\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"none | [ <svg-length>+ ]#\"},\"stroke-dashoffset\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<svg-length>\"},\"stroke-linecap\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"butt | round | square\"},\"stroke-linejoin\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"miter | round | bevel\"},\"stroke-miterlimit\":{\"comment\":\"added SVG property (<miterlimit> = <number-one-or-greater>) \",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<number-one-or-greater>\"},\"stroke-opacity\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<number-zero-one>\"},\"stroke-width\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"],\"syntax\":\"<svg-length>\"},\"text-anchor\":{\"comment\":\"added SVG property\",\"references\":[\"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties\"],\"syntax\":\"start | middle | end\"},\"unicode-bidi\":{\"comment\":\"added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi\",\"syntax\":\"| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext\"},\"unicode-range\":{\"comment\":\"added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range\",\"syntax\":\"<urange>#\"},\"voice-balance\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<number> | left | center | right | leftwards | rightwards\"},\"voice-duration\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"auto | <time>\"},\"voice-family\":{\"comment\":\"<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve\"},\"voice-pitch\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\"},\"voice-range\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\"},\"voice-rate\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>\"},\"voice-stress\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"normal | strong | moderate | none | reduced\"},\"voice-volume\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#property-index\",\"syntax\":\"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]\"},\"writing-mode\":{\"comment\":\"extend with SVG keywords\",\"syntax\":\"| <svg-writing-mode>\"}}");
const syntaxes = /* #__PURE__ */ JSON.parse("{\"-legacy-gradient\":{\"comment\":\"added collection of legacy gradient syntaxes\",\"syntax\":\"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>\"},\"-legacy-linear-gradient\":{\"comment\":\"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\"syntax\":\"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )\"},\"-legacy-repeating-linear-gradient\":{\"comment\":\"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\"syntax\":\"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )\"},\"-legacy-linear-gradient-arguments\":{\"comment\":\"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\"syntax\":\"[ <angle> | <side-or-corner> ]? , <color-stop-list>\"},\"-legacy-radial-gradient\":{\"comment\":\"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\"syntax\":\"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )\"},\"-legacy-repeating-radial-gradient\":{\"comment\":\"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\"syntax\":\"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )\"},\"-legacy-radial-gradient-arguments\":{\"comment\":\"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\"syntax\":\"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>\"},\"-legacy-radial-gradient-size\":{\"comment\":\"before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize\",\"syntax\":\"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover\"},\"-legacy-radial-gradient-shape\":{\"comment\":\"define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape\",\"syntax\":\"circle | ellipse\"},\"-non-standard-font\":{\"comment\":\"non standard fonts\",\"references\":[\"https://webkit.org/blog/3709/using-the-system-font-in-web-content/\"],\"syntax\":\"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body\"},\"-non-standard-color\":{\"comment\":\"non standard colors\",\"references\":[\"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html\",\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions\"],\"syntax\":\"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text\"},\"-non-standard-image-rendering\":{\"comment\":\"non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html\",\"syntax\":\"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast\"},\"-non-standard-overflow\":{\"comment\":\"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\",\"syntax\":\"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable\"},\"-non-standard-width\":{\"comment\":\"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width\",\"syntax\":\"fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content\"},\"-webkit-gradient()\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )\",\"syntax\":\"-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )\"},\"-webkit-gradient-color-stop\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )\"},\"-webkit-gradient-point\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]\"},\"-webkit-gradient-radius\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"<length> | <percentage>\"},\"-webkit-gradient-type\":{\"comment\":\"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\"syntax\":\"linear | radial\"},\"-webkit-mask-box-repeat\":{\"comment\":\"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image\",\"syntax\":\"repeat | stretch | round\"},\"-webkit-mask-clip-style\":{\"comment\":\"missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working\",\"syntax\":\"border | border-box | padding | padding-box | content | content-box | text\"},\"-ms-filter-function-list\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"<-ms-filter-function>+\"},\"-ms-filter-function\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"<-ms-filter-function-progid> | <-ms-filter-function-legacy>\"},\"-ms-filter-function-progid\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]\"},\"-ms-filter-function-legacy\":{\"comment\":\"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\"syntax\":\"<ident-token> | <function-token> <any-value>? )\"},\"-ms-filter\":{\"syntax\":\"<string>\"},\"age\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#voice-family\",\"syntax\":\"child | young | old\"},\"attr-name\":{\"syntax\":\"<wq-name>\"},\"attr-fallback\":{\"syntax\":\"<any-value>\"},\"border-radius\":{\"comment\":\"missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius\",\"syntax\":\"<length-percentage>{1,2}\"},\"bottom\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"content-list\":{\"comment\":\"missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)\",\"syntax\":\"[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+\"},\"element()\":{\"comment\":\"https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation\",\"syntax\":\"element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )\"},\"generic-voice\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#voice-family\",\"syntax\":\"[ <age>? <gender> <integer>? ]\"},\"gender\":{\"comment\":\"https://www.w3.org/TR/css3-speech/#voice-family\",\"syntax\":\"male | female | neutral\"},\"generic-family\":{\"comment\":\"added -apple-system\",\"references\":[\"https://webkit.org/blog/3709/using-the-system-font-in-web-content/\"],\"syntax\":\"| -apple-system\"},\"gradient\":{\"comment\":\"added legacy syntaxes support\",\"syntax\":\"| <-legacy-gradient>\"},\"left\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"mask-image\":{\"comment\":\"missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image\",\"syntax\":\"<mask-reference>#\"},\"name-repeat\":{\"comment\":\"missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat\",\"syntax\":\"repeat( [ <positive-integer> | auto-fill ], <line-names>+)\"},\"named-color\":{\"comment\":\"added non standard color names\",\"syntax\":\"| <-non-standard-color>\"},\"paint\":{\"comment\":\"used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint\",\"syntax\":\"none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke\"},\"page-size\":{\"comment\":\"https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size\",\"syntax\":\"A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger\"},\"ratio\":{\"comment\":\"missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio\",\"syntax\":\"<integer> / <integer>\"},\"right\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"shape\":{\"comment\":\"missed spaces in function body and add backwards compatible syntax\",\"syntax\":\"rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )\"},\"svg-length\":{\"comment\":\"All coordinates and lengths in SVG can be specified with or without a unit identifier\",\"references\":[\"https://www.w3.org/TR/SVG11/coords.html#Units\"],\"syntax\":\"<percentage> | <length> | <number>\"},\"svg-writing-mode\":{\"comment\":\"SVG specific keywords (deprecated for CSS)\",\"references\":[\"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode\",\"https://www.w3.org/TR/SVG/text.html#WritingModeProperty\"],\"syntax\":\"lr-tb | rl-tb | tb-rl | lr | rl | tb\"},\"top\":{\"comment\":\"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\"syntax\":\"<length> | auto\"},\"track-group\":{\"comment\":\"used by old grid-columns and grid-rows syntax v0\",\"syntax\":\"'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>\"},\"track-list-v0\":{\"comment\":\"used by old grid-columns and grid-rows syntax v0\",\"syntax\":\"[ <string>* <track-group> <string>* ]+ | none\"},\"track-minmax\":{\"comment\":\"used by old grid-columns and grid-rows syntax v0\",\"syntax\":\"minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content\"},\"x\":{\"comment\":\"missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor\",\"syntax\":\"<number>\"},\"y\":{\"comment\":\"missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor\",\"syntax\":\"<number>\"},\"declaration\":{\"comment\":\"missed, restored by https://drafts.csswg.org/css-syntax\",\"syntax\":\"<ident-token> : <declaration-value>? [ '!' important ]?\"},\"declaration-list\":{\"comment\":\"missed, restored by https://drafts.csswg.org/css-syntax\",\"syntax\":\"[ <declaration>? ';' ]* <declaration>?\"},\"url\":{\"comment\":\"https://drafts.csswg.org/css-values-4/#urls\",\"syntax\":\"url( <string> <url-modifier>* ) | <url-token>\"},\"url-modifier\":{\"comment\":\"https://drafts.csswg.org/css-values-4/#typedef-url-modifier\",\"syntax\":\"<ident> | <function-token> <any-value> )\"},\"number-zero-one\":{\"syntax\":\"<number [0,1]>\"},\"number-one-or-greater\":{\"syntax\":\"<number [1,âˆ]>\"},\"positive-integer\":{\"syntax\":\"<integer [0,âˆ]>\"},\"-non-standard-display\":{\"syntax\":\"-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box\"}}");
const require$$3 = {
  atrules,
  properties,
  syntaxes,
};

var data;
var hasRequiredData;

function requireData () {
	if (hasRequiredData) return data;
	hasRequiredData = 1;
	const mdnAtrules = require$$0;
	const mdnProperties = require$$1;
	const mdnSyntaxes = require$$2$1;
	const patch = require$$3;
	const extendSyntax = /^\s*\|\s*/;

	function preprocessAtrules(dict) {
	    const result = Object.create(null);

	    for (const atruleName in dict) {
	        const atrule = dict[atruleName];
	        let descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (const descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function patchDictionary(dict, patchDict) {
	    const result = {};

	    // copy all syntaxes for an original dict
	    for (const key in dict) {
	        result[key] = dict[key].syntax || dict[key];
	    }

	    // apply a patch
	    for (const key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = extendSyntax.test(patchDict[key].syntax)
	                    ? result[key] + ' ' + patchDict[key].syntax.trim()
	                    : patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
	            }
	        }
	    }

	    return result;
	}

	function unpackSyntaxes(dict) {
	    const result = {};

	    for (const key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    return result;
	}

	function patchAtrules(dict, patchDict) {
	    const result = {};

	    // copy all syntaxes for an original dict
	    for (const key in dict) {
	        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;

	        result[key] = {
	            prelude: key in patchDict && 'prelude' in patchDict[key]
	                ? patchDict[key].prelude
	                : dict[key].prelude || null,
	            descriptors: dict[key].descriptors
	                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})
	                : patchDescriptors && unpackSyntaxes(patchDescriptors)
	        };
	    }

	    // apply a patch
	    for (const key in patchDict) {
	        if (!hasOwnProperty.call(dict, key)) {
	            result[key] = {
	                prelude: patchDict[key].prelude || null,
	                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
	            };
	        }
	    }

	    return result;
	}

	data = {
	    types: patchDictionary(mdnSyntaxes, patch.syntaxes),
	    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
	    properties: patchDictionary(mdnProperties, patch.properties)
	};
	return data;
}

var AnPlusB;
var hasRequiredAnPlusB;

function requireAnPlusB () {
	if (hasRequiredAnPlusB) return AnPlusB;
	hasRequiredAnPlusB = 1;
	var cmpChar = requireTokenizer$1().cmpChar;
	var isDigit = requireTokenizer$1().isDigit;
	var TYPE = requireTokenizer$1().TYPE;

	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var IDENT = TYPE.Ident;
	var NUMBER = TYPE.Number;
	var DIMENSION = TYPE.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function checkInteger(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN || code === HYPHENMINUS) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE || type === COMMENT) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER) {
	        if (this.scanner.isDelim(PLUSSIGN, offset) ||
	            this.scanner.isDelim(HYPHENMINUS, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE || type === COMMENT);

	            if (type !== NUMBER) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS ? '-' + this.consume(NUMBER) : this.consume(NUMBER);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN);
	            b = this.consume(NUMBER);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

	                    b = '-' + this.consume(NUMBER);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS);
	                    checkInteger.call(this, 3, DISALLOW_SIGN);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT || (this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN);

	                    b = '-' + this.consume(NUMBER);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS);
	                    checkInteger.call(this, 2, DISALLOW_SIGN);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN || code === HYPHENMINUS;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN);
	                    b = '-' + this.consume(NUMBER);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};
	return AnPlusB;
}

var Raw$1;
var hasRequiredRaw$1;

function requireRaw$1 () {
	if (hasRequiredRaw$1) return Raw$1;
	hasRequiredRaw$1 = 1;
	var tokenizer = requireTokenizer$1();
	var TYPE = tokenizer.TYPE;

	var WhiteSpace = TYPE.WhiteSpace;
	var Semicolon = TYPE.Semicolon;
	var LeftCurlyBracket = TYPE.LeftCurlyBracket;
	var Delim = TYPE.Delim;
	var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	Raw$1 = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};
	return Raw$1;
}

var Atrule$2;
var hasRequiredAtrule$3;

function requireAtrule$3 () {
	if (hasRequiredAtrule$3) return Atrule$2;
	hasRequiredAtrule$3 = 1;
	var TYPE = requireTokenizer$1().TYPE;
	var rawMode = requireRaw$1().mode;

	var ATKEYWORD = TYPE.AtKeyword;
	var SEMICOLON = TYPE.Semicolon;
	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	Atrule$2 = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};
	return Atrule$2;
}

var AtrulePrelude;
var hasRequiredAtrulePrelude$1;

function requireAtrulePrelude$1 () {
	if (hasRequiredAtrulePrelude$1) return AtrulePrelude;
	hasRequiredAtrulePrelude$1 = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var SEMICOLON = TYPE.Semicolon;
	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

	AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET &&
	            this.scanner.tokenType !== SEMICOLON) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};
	return AtrulePrelude;
}

var AttributeSelector$1;
var hasRequiredAttributeSelector$1;

function requireAttributeSelector$1 () {
	if (hasRequiredAttributeSelector$1) return AttributeSelector$1;
	hasRequiredAttributeSelector$1 = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var STRING = TYPE.String;
	var COLON = TYPE.Colon;
	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE)) {
	        this.eat(IDENT);
	    }

	    if (this.scanner.isDelim(VERTICALLINE)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK &&          // *=
	        code !== VERTICALLINE         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	AttributeSelector$1 = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};
	return AttributeSelector$1;
}

var Block;
var hasRequiredBlock;

function requireBlock () {
	if (hasRequiredBlock) return Block;
	hasRequiredBlock = 1;
	var TYPE = requireTokenizer$1().TYPE;
	var rawMode = requireRaw$1().mode;

	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var SEMICOLON = TYPE.Semicolon;
	var ATKEYWORD = TYPE.AtKeyword;
	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON) {
	        this.scanner.next();
	    }

	    return node;
	}

	Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET:
	                    break scan;

	                case WHITESPACE:
	                case COMMENT:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};
	return Block;
}

var Brackets;
var hasRequiredBrackets;

function requireBrackets () {
	if (hasRequiredBrackets) return Brackets;
	hasRequiredBrackets = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

	Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};
	return Brackets;
}

var CDC_1;
var hasRequiredCDC;

function requireCDC () {
	if (hasRequiredCDC) return CDC_1;
	hasRequiredCDC = 1;
	var CDC = requireTokenizer$1().TYPE.CDC;

	CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};
	return CDC_1;
}

var CDO_1;
var hasRequiredCDO;

function requireCDO () {
	if (hasRequiredCDO) return CDO_1;
	hasRequiredCDO = 1;
	var CDO = requireTokenizer$1().TYPE.CDO;

	CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};
	return CDO_1;
}

var ClassSelector;
var hasRequiredClassSelector;

function requireClassSelector () {
	if (hasRequiredClassSelector) return ClassSelector;
	hasRequiredClassSelector = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};
	return ClassSelector;
}

var Combinator;
var hasRequiredCombinator;

function requireCombinator () {
	if (hasRequiredCombinator) return Combinator;
	hasRequiredCombinator = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN:
	            case PLUSSIGN:
	            case TILDE:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};
	return Combinator;
}

var Comment$1;
var hasRequiredComment$1;

function requireComment$1 () {
	if (hasRequiredComment$1) return Comment$1;
	hasRequiredComment$1 = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var COMMENT = TYPE.Comment;
	var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	Comment$1 = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};
	return Comment$1;
}

var Declaration$1;
var hasRequiredDeclaration$1;

function requireDeclaration$1 () {
	if (hasRequiredDeclaration$1) return Declaration$1;
	hasRequiredDeclaration$1 = 1;
	var isCustomProperty = requireNames().isCustomProperty;
	var TYPE = requireTokenizer$1().TYPE;
	var rawMode = requireRaw$1().mode;

	var IDENT = TYPE.Ident;
	var HASH = TYPE.Hash;
	var COLON = TYPE.Colon;
	var SEMICOLON = TYPE.Semicolon;
	var DELIM = TYPE.Delim;
	var WHITESPACE = TYPE.WhiteSpace;
	var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON &&
	        this.scanner.isDelim(EXCLAMATIONMARK) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	Declaration$1 = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty.call(this);
	        var customProperty = isCustomProperty(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON);

	        const valueStart = this.scanner.tokenIndex;

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (customProperty && value.type === 'Value' && value.children.isEmpty()) {
	            for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
	                if (this.scanner.lookupType(offset) === WHITESPACE) {
	                    value.children.appendData({
	                        type: 'WhiteSpace',
	                        loc: null,
	                        value: ' '
	                    });
	                    break;
	                }
	            }
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK:
	            case DOLLARSIGN:
	            case PLUSSIGN:
	            case NUMBERSIGN:
	            case AMPERSAND:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH) {
	        this.eat(HASH);
	    } else {
	        this.eat(IDENT);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}
	return Declaration$1;
}

var DeclarationList;
var hasRequiredDeclarationList;

function requireDeclarationList () {
	if (hasRequiredDeclarationList) return DeclarationList;
	hasRequiredDeclarationList = 1;
	var TYPE = requireTokenizer$1().TYPE;
	var rawMode = requireRaw$1().mode;

	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var SEMICOLON = TYPE.Semicolon;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.semicolonIncluded, true);
	}

	DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE:
	                case COMMENT:
	                case SEMICOLON:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};
	return DeclarationList;
}

var Dimension$1;
var hasRequiredDimension$1;

function requireDimension$1 () {
	if (hasRequiredDimension$1) return Dimension$1;
	hasRequiredDimension$1 = 1;
	var consumeNumber = requireUtils$2().consumeNumber;
	var TYPE = requireTokenizer$1().TYPE;

	var DIMENSION = TYPE.Dimension;

	Dimension$1 = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber(this.scanner.source, start);

	        this.eat(DIMENSION);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};
	return Dimension$1;
}

var _Function;
var hasRequired_Function;

function require_Function () {
	if (hasRequired_Function) return _Function;
	hasRequired_Function = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

	// <function-token> <sequence> )
	_Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};
	return _Function;
}

var Hash;
var hasRequiredHash;

function requireHash () {
	if (hasRequiredHash) return Hash;
	hasRequiredHash = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var HASH = TYPE.Hash;

	// '#' ident
	Hash = {
	    name: 'Hash',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH);

	        return {
	            type: 'Hash',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};
	return Hash;
}

var Identifier;
var hasRequiredIdentifier;

function requireIdentifier () {
	if (hasRequiredIdentifier) return Identifier;
	hasRequiredIdentifier = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;

	Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};
	return Identifier;
}

var IdSelector;
var hasRequiredIdSelector;

function requireIdSelector () {
	if (hasRequiredIdSelector) return IdSelector;
	hasRequiredIdSelector = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var HASH = TYPE.Hash;

	// <hash-token>
	IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};
	return IdSelector;
}

var MediaFeature;
var hasRequiredMediaFeature;

function requireMediaFeature () {
	if (hasRequiredMediaFeature) return MediaFeature;
	hasRequiredMediaFeature = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var NUMBER = TYPE.Number;
	var DIMENSION = TYPE.Dimension;
	var LEFTPARENTHESIS = TYPE.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE.RightParenthesis;
	var COLON = TYPE.Colon;
	var DELIM = TYPE.Delim;

	MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS);
	        this.scanner.skipSC();

	        name = this.consume(IDENT);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
	            this.eat(COLON);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER:
	                    if (this.lookupNonWSType(1) === DELIM) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION:
	                    value = this.Dimension();
	                    break;

	                case IDENT:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};
	return MediaFeature;
}

var MediaQuery;
var hasRequiredMediaQuery;

function requireMediaQuery () {
	if (hasRequiredMediaQuery) return MediaQuery;
	hasRequiredMediaQuery = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var IDENT = TYPE.Ident;
	var LEFTPARENTHESIS = TYPE.LeftParenthesis;

	MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};
	return MediaQuery;
}

var MediaQueryList;
var hasRequiredMediaQueryList;

function requireMediaQueryList () {
	if (hasRequiredMediaQueryList) return MediaQueryList;
	hasRequiredMediaQueryList = 1;
	var COMMA = requireTokenizer$1().TYPE.Comma;

	MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};
	return MediaQueryList;
}

var Nth;
var hasRequiredNth$1;

function requireNth$1 () {
	if (hasRequiredNth$1) return Nth;
	hasRequiredNth$1 = 1;
	Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};
	return Nth;
}

var _Number$1;
var hasRequired_Number$1;

function require_Number$1 () {
	if (hasRequired_Number$1) return _Number$1;
	hasRequired_Number$1 = 1;
	var NUMBER = requireTokenizer$1().TYPE.Number;

	_Number$1 = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};
	return _Number$1;
}

var Operator;
var hasRequiredOperator;

function requireOperator () {
	if (hasRequiredOperator) return Operator;
	hasRequiredOperator = 1;
	// '/' | '*' | ',' | ':' | '+' | '-'
	Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};
	return Operator;
}

var Parentheses;
var hasRequiredParentheses;

function requireParentheses () {
	if (hasRequiredParentheses) return Parentheses;
	hasRequiredParentheses = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var LEFTPARENTHESIS = TYPE.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

	Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};
	return Parentheses;
}

var Percentage$1;
var hasRequiredPercentage$1;

function requirePercentage$1 () {
	if (hasRequiredPercentage$1) return Percentage$1;
	hasRequiredPercentage$1 = 1;
	var consumeNumber = requireUtils$2().consumeNumber;
	var TYPE = requireTokenizer$1().TYPE;

	var PERCENTAGE = TYPE.Percentage;

	Percentage$1 = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber(this.scanner.source, start);

	        this.eat(PERCENTAGE);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};
	return Percentage$1;
}

var PseudoClassSelector;
var hasRequiredPseudoClassSelector;

function requirePseudoClassSelector () {
	if (hasRequiredPseudoClassSelector) return PseudoClassSelector;
	hasRequiredPseudoClassSelector = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var FUNCTION = TYPE.Function;
	var COLON = TYPE.Colon;
	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON);

	        if (this.scanner.tokenType === FUNCTION) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS);
	        } else {
	            name = this.consume(IDENT);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};
	return PseudoClassSelector;
}

var PseudoElementSelector;
var hasRequiredPseudoElementSelector;

function requirePseudoElementSelector () {
	if (hasRequiredPseudoElementSelector) return PseudoElementSelector;
	hasRequiredPseudoElementSelector = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var FUNCTION = TYPE.Function;
	var COLON = TYPE.Colon;
	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON);
	        this.eat(COLON);

	        if (this.scanner.tokenType === FUNCTION) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS);
	        } else {
	            name = this.consume(IDENT);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};
	return PseudoElementSelector;
}

var Ratio;
var hasRequiredRatio;

function requireRatio () {
	if (hasRequiredRatio) return Ratio;
	hasRequiredRatio = 1;
	var isDigit = requireTokenizer$1().isDigit;
	var TYPE = requireTokenizer$1().TYPE;

	var NUMBER = TYPE.Number;
	var DELIM = TYPE.Delim;
	var SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit(code) && code !== FULLSTOP) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM);
	        right = consumeNumber.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};
	return Ratio;
}

var Rule$1;
var hasRequiredRule$1;

function requireRule$1 () {
	if (hasRequiredRule$1) return Rule$1;
	hasRequiredRule$1 = 1;
	var TYPE = requireTokenizer$1().TYPE;
	var rawMode = requireRaw$1().mode;

	var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET) {
	        this.error();
	    }

	    return prelude;
	}

	Rule$1 = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw);
	        } else {
	            prelude = consumeRaw.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};
	return Rule$1;
}

var Selector;
var hasRequiredSelector$1;

function requireSelector$1 () {
	if (hasRequiredSelector$1) return Selector;
	hasRequiredSelector$1 = 1;
	Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};
	return Selector;
}

var SelectorList;
var hasRequiredSelectorList$1;

function requireSelectorList$1 () {
	if (hasRequiredSelectorList$1) return SelectorList;
	hasRequiredSelectorList$1 = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var COMMA = TYPE.Comma;

	SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};
	return SelectorList;
}

var _String$1;
var hasRequired_String$1;

function require_String$1 () {
	if (hasRequired_String$1) return _String$1;
	hasRequired_String$1 = 1;
	var STRING = requireTokenizer$1().TYPE.String;

	_String$1 = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};
	return _String$1;
}

var StyleSheet;
var hasRequiredStyleSheet;

function requireStyleSheet () {
	if (hasRequiredStyleSheet) return StyleSheet;
	hasRequiredStyleSheet = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var ATKEYWORD = TYPE.AtKeyword;
	var CDO = TYPE.CDO;
	var CDC = TYPE.CDC;
	var EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw(startToken) {
	    return this.Raw(startToken, null, false);
	}

	StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE:
	                    this.scanner.next();
	                    continue;

	                case COMMENT:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // Â§2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};
	return StyleSheet;
}

var TypeSelector$1;
var hasRequiredTypeSelector$1;

function requireTypeSelector$1 () {
	if (hasRequiredTypeSelector$1) return TypeSelector$1;
	hasRequiredTypeSelector$1 = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var ASTERISK = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT &&
	        this.scanner.isDelim(ASTERISK) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	TypeSelector$1 = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};
	return TypeSelector$1;
}

var UnicodeRange;
var hasRequiredUnicodeRange;

function requireUnicodeRange () {
	if (hasRequiredUnicodeRange) return UnicodeRange;
	hasRequiredUnicodeRange = 1;
	var isHexDigit = requireTokenizer$1().isHexDigit;
	var cmpChar = requireTokenizer$1().cmpChar;
	var TYPE = requireTokenizer$1().TYPE;
	var NAME = requireTokenizer$1().NAME;

	var IDENT = TYPE.Ident;
	var NUMBER = TYPE.Number;
	var DIMENSION = TYPE.Dimension;
	var PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }	    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER) {
	        startsWith.call(this, PLUSSIGN);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION ||
	            this.scanner.tokenType === NUMBER) {
	            startsWith.call(this, HYPHENMINUS);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION) {
	        startsWith.call(this, PLUSSIGN);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar(this.scanner.source, start, U)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};
	return UnicodeRange;
}

var Url$1;
var hasRequiredUrl$1;

function requireUrl$1 () {
	if (hasRequiredUrl$1) return Url$1;
	hasRequiredUrl$1 = 1;
	var isWhiteSpace = requireTokenizer$1().isWhiteSpace;
	var cmpStr = requireTokenizer$1().cmpStr;
	var TYPE = requireTokenizer$1().TYPE;

	var FUNCTION = TYPE.Function;
	var URL = TYPE.Url;
	var RIGHTPARENTHESIS = TYPE.RightParenthesis;

	// <url-token> | <function-token> <string> )
	Url$1 = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL);
	                break;

	            case FUNCTION:
	                if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};
	return Url$1;
}

var Value$1;
var hasRequiredValue$2;

function requireValue$2 () {
	if (hasRequiredValue$2) return Value$1;
	hasRequiredValue$2 = 1;
	Value$1 = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};
	return Value$1;
}

var WhiteSpace$1;
var hasRequiredWhiteSpace$1;

function requireWhiteSpace$1 () {
	if (hasRequiredWhiteSpace$1) return WhiteSpace$1;
	hasRequiredWhiteSpace$1 = 1;
	var WHITESPACE = requireTokenizer$1().TYPE.WhiteSpace;
	var SPACE = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE);
	        return SPACE;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};
	return WhiteSpace$1;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	node = {
	    AnPlusB: requireAnPlusB(),
	    Atrule: requireAtrule$3(),
	    AtrulePrelude: requireAtrulePrelude$1(),
	    AttributeSelector: requireAttributeSelector$1(),
	    Block: requireBlock(),
	    Brackets: requireBrackets(),
	    CDC: requireCDC(),
	    CDO: requireCDO(),
	    ClassSelector: requireClassSelector(),
	    Combinator: requireCombinator(),
	    Comment: requireComment$1(),
	    Declaration: requireDeclaration$1(),
	    DeclarationList: requireDeclarationList(),
	    Dimension: requireDimension$1(),
	    Function: require_Function(),
	    Hash: requireHash(),
	    Identifier: requireIdentifier(),
	    IdSelector: requireIdSelector(),
	    MediaFeature: requireMediaFeature(),
	    MediaQuery: requireMediaQuery(),
	    MediaQueryList: requireMediaQueryList(),
	    Nth: requireNth$1(),
	    Number: require_Number$1(),
	    Operator: requireOperator(),
	    Parentheses: requireParentheses(),
	    Percentage: requirePercentage$1(),
	    PseudoClassSelector: requirePseudoClassSelector(),
	    PseudoElementSelector: requirePseudoElementSelector(),
	    Ratio: requireRatio(),
	    Raw: requireRaw$1(),
	    Rule: requireRule$1(),
	    Selector: requireSelector$1(),
	    SelectorList: requireSelectorList$1(),
	    String: require_String$1(),
	    StyleSheet: requireStyleSheet(),
	    TypeSelector: requireTypeSelector$1(),
	    UnicodeRange: requireUnicodeRange(),
	    Url: requireUrl$1(),
	    Value: requireValue$2(),
	    WhiteSpace: requireWhiteSpace$1()
	};
	return node;
}

var lexer;
var hasRequiredLexer;

function requireLexer () {
	if (hasRequiredLexer) return lexer;
	hasRequiredLexer = 1;
	var data = requireData();

	lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: requireNode()
	};
	return lexer;
}

var _default;
var hasRequired_default;

function require_default () {
	if (hasRequired_default) return _default;
	hasRequired_default = 1;
	var cmpChar = requireTokenizer$1().cmpChar;
	var cmpStr = requireTokenizer$1().cmpStr;
	var TYPE = requireTokenizer$1().TYPE;

	var IDENT = TYPE.Ident;
	var STRING = TYPE.String;
	var NUMBER = TYPE.Number;
	var FUNCTION = TYPE.Function;
	var URL = TYPE.Url;
	var HASH = TYPE.Hash;
	var DIMENSION = TYPE.Dimension;
	var PERCENTAGE = TYPE.Percentage;
	var LEFTPARENTHESIS = TYPE.LeftParenthesis;
	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
	var COMMA = TYPE.Comma;
	var DELIM = TYPE.Delim;
	var NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)
	var U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	_default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH:
	            return this.Hash();

	        case COMMA:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING:
	            return this.String();

	        case DIMENSION:
	            return this.Dimension();

	        case PERCENTAGE:
	            return this.Percentage();

	        case NUMBER:
	            return this.Number();

	        case FUNCTION:
	            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL:
	            return this.Url();

	        case IDENT:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&
	                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS ||
	                code === ASTERISK ||
	                code === PLUSSIGN ||
	                code === HYPHENMINUS) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};
	return _default;
}

var atrulePrelude;
var hasRequiredAtrulePrelude;

function requireAtrulePrelude () {
	if (hasRequiredAtrulePrelude) return atrulePrelude;
	hasRequiredAtrulePrelude = 1;
	atrulePrelude = {
	    getNode: require_default()
	};
	return atrulePrelude;
}

var selector;
var hasRequiredSelector;

function requireSelector () {
	if (hasRequiredSelector) return selector;
	hasRequiredSelector = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var DELIM = TYPE.Delim;
	var IDENT = TYPE.Ident;
	var DIMENSION = TYPE.Dimension;
	var PERCENTAGE = TYPE.Percentage;
	var NUMBER = TYPE.Number;
	var HASH = TYPE.Hash;
	var COLON = TYPE.Colon;
	var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
	var NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET:
	            return this.AttributeSelector();

	        case HASH:
	            return this.IdSelector();

	        case COLON:
	            if (this.scanner.lookupType(1) === COLON) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT:
	            return this.TypeSelector();

	        case NUMBER:
	        case PERCENTAGE:
	            return this.Percentage();

	        case DIMENSION:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN:
	                case GREATERTHANSIGN:
	                case TILDE:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP:
	                    return this.ClassSelector();

	                case ASTERISK:
	                case VERTICALLINE:
	                    return this.TypeSelector();

	                case NUMBERSIGN:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	selector = {
	    getNode: getNode
	};
	return selector;
}

var expression;
var hasRequiredExpression;

function requireExpression () {
	if (hasRequiredExpression) return expression;
	hasRequiredExpression = 1;
	// legacy IE function
	// expression( <any-value> )
	expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};
	return expression;
}

var _var;
var hasRequired_var;

function require_var () {
	if (hasRequired_var) return _var;
	hasRequired_var = 1;
	var TYPE = requireTokenizer$1().TYPE;
	var rawMode = requireRaw$1().mode;

	var COMMA = TYPE.Comma;
	var WHITESPACE = TYPE.WhiteSpace;

	// var( <ident> , <value>? )
	_var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA) {
	        children.push(this.Operator());

	        const startIndex = this.scanner.tokenIndex;
	        const value = this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);

	        if (value.type === 'Value' && value.children.isEmpty()) {
	            for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
	                if (this.scanner.lookupType(offset) === WHITESPACE) {
	                    value.children.appendData({
	                        type: 'WhiteSpace',
	                        loc: null,
	                        value: ' '
	                    });
	                    break;
	                }
	            }
	        }

	        children.push(value);
	    }

	    return children;
	};
	return _var;
}

var value;
var hasRequiredValue$1;

function requireValue$1 () {
	if (hasRequiredValue$1) return value;
	hasRequiredValue$1 = 1;
	value = {
	    getNode: require_default(),
	    'expression': requireExpression(),
	    'var': require_var()
	};
	return value;
}

var scope;
var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	scope = {
	    AtrulePrelude: requireAtrulePrelude(),
	    Selector: requireSelector(),
	    Value: requireValue$1()
	};
	return scope;
}

var fontFace;
var hasRequiredFontFace;

function requireFontFace () {
	if (hasRequiredFontFace) return fontFace;
	hasRequiredFontFace = 1;
	fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};
	return fontFace;
}

var _import;
var hasRequired_import;

function require_import () {
	if (hasRequired_import) return _import;
	hasRequired_import = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var STRING = TYPE.String;
	var IDENT = TYPE.Ident;
	var URL = TYPE.Url;
	var FUNCTION = TYPE.Function;
	var LEFTPARENTHESIS = TYPE.LeftParenthesis;

	_import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING:
	                    children.push(this.String());
	                    break;

	                case URL:
	                case FUNCTION:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};
	return _import;
}

var media;
var hasRequiredMedia;

function requireMedia () {
	if (hasRequiredMedia) return media;
	hasRequiredMedia = 1;
	media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};
	return media;
}

var page$1;
var hasRequiredPage;

function requirePage () {
	if (hasRequiredPage) return page$1;
	hasRequiredPage = 1;
	page$1 = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};
	return page$1;
}

var supports;
var hasRequiredSupports;

function requireSupports () {
	if (hasRequiredSupports) return supports;
	hasRequiredSupports = 1;
	var TYPE = requireTokenizer$1().TYPE;

	var WHITESPACE = TYPE.WhiteSpace;
	var COMMENT = TYPE.Comment;
	var IDENT = TYPE.Ident;
	var FUNCTION = TYPE.Function;
	var COLON = TYPE.Colon;
	var LEFTPARENTHESIS = TYPE.LeftParenthesis;

	function consumeRaw() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT &&
	        this.lookupNonWSType(1) === COLON) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT:
	                this.scanner.next();
	                continue;

	            case FUNCTION:
	                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
	                break;

	            case IDENT:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};
	return supports;
}

var atrule;
var hasRequiredAtrule$2;

function requireAtrule$2 () {
	if (hasRequiredAtrule$2) return atrule;
	hasRequiredAtrule$2 = 1;
	atrule = {
	    'font-face': requireFontFace(),
	    'import': require_import(),
	    'media': requireMedia(),
	    'page': requirePage(),
	    'supports': requireSupports()
	};
	return atrule;
}

var dir;
var hasRequiredDir;

function requireDir () {
	if (hasRequiredDir) return dir;
	hasRequiredDir = 1;
	dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};
	return dir;
}

var has;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has;
	hasRequiredHas = 1;
	has = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};
	return has;
}

var lang;
var hasRequiredLang;

function requireLang () {
	if (hasRequiredLang) return lang;
	hasRequiredLang = 1;
	lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};
	return lang;
}

var selectorList;
var hasRequiredSelectorList;

function requireSelectorList () {
	if (hasRequiredSelectorList) return selectorList;
	hasRequiredSelectorList = 1;
	selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};
	return selectorList;
}

var matches;
var hasRequiredMatches;

function requireMatches () {
	if (hasRequiredMatches) return matches;
	hasRequiredMatches = 1;
	matches = requireSelectorList();
	return matches;
}

var not;
var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	not = requireSelectorList();
	return not;
}

var nthWithOfClause;
var hasRequiredNthWithOfClause;

function requireNthWithOfClause () {
	if (hasRequiredNthWithOfClause) return nthWithOfClause;
	hasRequiredNthWithOfClause = 1;
	var ALLOW_OF_CLAUSE = true;

	nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};
	return nthWithOfClause;
}

var nthChild;
var hasRequiredNthChild;

function requireNthChild () {
	if (hasRequiredNthChild) return nthChild;
	hasRequiredNthChild = 1;
	nthChild = requireNthWithOfClause();
	return nthChild;
}

var nthLastChild;
var hasRequiredNthLastChild;

function requireNthLastChild () {
	if (hasRequiredNthLastChild) return nthLastChild;
	hasRequiredNthLastChild = 1;
	nthLastChild = requireNthWithOfClause();
	return nthLastChild;
}

var nth;
var hasRequiredNth;

function requireNth () {
	if (hasRequiredNth) return nth;
	hasRequiredNth = 1;
	var DISALLOW_OF_CLAUSE = false;

	nth = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};
	return nth;
}

var nthLastOfType;
var hasRequiredNthLastOfType;

function requireNthLastOfType () {
	if (hasRequiredNthLastOfType) return nthLastOfType;
	hasRequiredNthLastOfType = 1;
	nthLastOfType = requireNth();
	return nthLastOfType;
}

var nthOfType;
var hasRequiredNthOfType;

function requireNthOfType () {
	if (hasRequiredNthOfType) return nthOfType;
	hasRequiredNthOfType = 1;
	nthOfType = requireNth();
	return nthOfType;
}

var slotted;
var hasRequiredSlotted;

function requireSlotted () {
	if (hasRequiredSlotted) return slotted;
	hasRequiredSlotted = 1;
	slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};
	return slotted;
}

var pseudo;
var hasRequiredPseudo;

function requirePseudo () {
	if (hasRequiredPseudo) return pseudo;
	hasRequiredPseudo = 1;
	pseudo = {
	    'dir': requireDir(),
	    'has': requireHas(),
	    'lang': requireLang(),
	    'matches': requireMatches(),
	    'not': requireNot(),
	    'nth-child': requireNthChild(),
	    'nth-last-child': requireNthLastChild(),
	    'nth-last-of-type': requireNthLastOfType(),
	    'nth-of-type': requireNthOfType(),
	    'slotted': requireSlotted()
	};
	return pseudo;
}

var parser$1;
var hasRequiredParser$1;

function requireParser$1 () {
	if (hasRequiredParser$1) return parser$1;
	hasRequiredParser$1 = 1;
	parser$1 = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: requireScope(),
	    atrule: requireAtrule$2(),
	    pseudo: requirePseudo(),
	    node: requireNode()
	};
	return parser$1;
}

var walker;
var hasRequiredWalker;

function requireWalker () {
	if (hasRequiredWalker) return walker;
	hasRequiredWalker = 1;
	walker = {
	    node: requireNode()
	};
	return walker;
}

const version$1 = "1.1.3";
const require$$4 = {
  version: version$1};

var hasRequiredSyntax;

function requireSyntax () {
	if (hasRequiredSyntax) return syntax.exports;
	hasRequiredSyntax = 1;
	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	syntax.exports = requireCreate().create(
	    merge(
	        requireLexer(),
	        requireParser$1(),
	        requireWalker()
	    )
	);
	syntax.exports.version = require$$4.version;
	return syntax.exports;
}

var lib$1;
var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	lib$1 = requireSyntax();
	return lib$1;
}

var cssTools = {};

var stable$1 = {exports: {}};

var stable = stable$1.exports;

var hasRequiredStable;

function requireStable () {
	if (hasRequiredStable) return stable$1.exports;
	hasRequiredStable = 1;
	(function (module, exports) {
		//! stable.js 0.1.8, https://github.com/Two-Screen/stable
		//! Â© 2018 Angry Bytes and contributors. MIT licensed.

		(function (global, factory) {
		  module.exports = factory() ;
		}(stable, (function () {
		  // A stable array sort, because `Array#sort()` is not guaranteed stable.
		  // This is an implementation of merge sort, without recursion.

		  var stable = function (arr, comp) {
		    return exec(arr.slice(), comp)
		  };

		  stable.inplace = function (arr, comp) {
		    var result = exec(arr, comp);

		    // This simply copies back if the result isn't in the original array,
		    // which happens on an odd number of passes.
		    if (result !== arr) {
		      pass(result, null, arr.length, arr);
		    }

		    return arr
		  };

		  // Execute the sort using the input array and a second buffer as work space.
		  // Returns one of those two, containing the final result.
		  function exec(arr, comp) {
		    if (typeof(comp) !== 'function') {
		      comp = function (a, b) {
		        return String(a).localeCompare(b)
		      };
		    }

		    // Short-circuit when there's nothing to sort.
		    var len = arr.length;
		    if (len <= 1) {
		      return arr
		    }

		    // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
		    // Chunks are the size of the left or right hand in merge sort.
		    // Stop when the left-hand covers all of the array.
		    var buffer = new Array(len);
		    for (var chk = 1; chk < len; chk *= 2) {
		      pass(arr, comp, chk, buffer);

		      var tmp = arr;
		      arr = buffer;
		      buffer = tmp;
		    }

		    return arr
		  }

		  // Run a single pass with the given chunk size.
		  var pass = function (arr, comp, chk, result) {
		    var len = arr.length;
		    var i = 0;
		    // Step size / double chunk size.
		    var dbl = chk * 2;
		    // Bounds of the left and right chunks.
		    var l, r, e;
		    // Iterators over the left and right chunk.
		    var li, ri;

		    // Iterate over pairs of chunks.
		    for (l = 0; l < len; l += dbl) {
		      r = l + chk;
		      e = r + chk;
		      if (r > len) r = len;
		      if (e > len) e = len;

		      // Iterate both chunks in parallel.
		      li = l;
		      ri = r;
		      while (true) {
		        // Compare the chunks.
		        if (li < r && ri < e) {
		          // This works for a regular `sort()` compatible comparator,
		          // but also for a simple comparator like: `a > b`
		          if (comp(arr[li], arr[ri]) <= 0) {
		            result[i++] = arr[li++];
		          }
		          else {
		            result[i++] = arr[ri++];
		          }
		        }
		        // Nothing to compare, just flush what's left.
		        else if (li < r) {
		          result[i++] = arr[li++];
		        }
		        else if (ri < e) {
		          result[i++] = arr[ri++];
		        }
		        // Both iterators are at the chunk ends.
		        else {
		          break
		        }
		      }
		    }
		  };

		  return stable;

		}))); 
	} (stable$1));
	return stable$1.exports;
}

var specificity;
var hasRequiredSpecificity;

function requireSpecificity () {
	if (hasRequiredSpecificity) return specificity;
	hasRequiredSpecificity = 1;
	specificity = function specificity(simpleSelector) {
	    var A = 0;
	    var B = 0;
	    var C = 0;

	    simpleSelector.children.each(function walk(node) {
	        switch (node.type) {
	            case 'SelectorList':
	            case 'Selector':
	                node.children.each(walk);
	                break;

	            case 'IdSelector':
	                A++;
	                break;

	            case 'ClassSelector':
	            case 'AttributeSelector':
	                B++;
	                break;

	            case 'PseudoClassSelector':
	                switch (node.name.toLowerCase()) {
	                    case 'not':
	                        node.children.each(walk);
	                        break;

	                    case 'before':
	                    case 'after':
	                    case 'first-line':
	                    case 'first-letter':
	                        C++;
	                        break;

	                    // TODO: support for :nth-*(.. of <SelectorList>), :matches(), :has()
	                    default:
	                        B++;
	                }
	                break;

	            case 'PseudoElementSelector':
	                C++;
	                break;

	            case 'TypeSelector':
	                // ignore universal selector
	                if (node.name.charAt(node.name.length - 1) !== '*') {
	                    C++;
	                }
	                break;

	        }
	    });

	    return [A, B, C];
	};
	return specificity;
}

var hasRequiredCssTools;

function requireCssTools () {
	if (hasRequiredCssTools) return cssTools;
	hasRequiredCssTools = 1;

	var csstree = requireLib$1(),
	  List = csstree.List,
	  stable = requireStable(),
	  specificity = requireSpecificity();

	/**
	 * Flatten a CSS AST to a selectors list.
	 *
	 * @param {import('css-tree').CssNode} cssAst css-tree AST to flatten
	 * @return {Array} selectors
	 */
	function flattenToSelectors(cssAst) {
	  var selectors = [];

	  csstree.walk(cssAst, {
	    visit: 'Rule',
	    enter: function (node) {
	      if (node.type !== 'Rule') {
	        return;
	      }

	      var atrule = this.atrule;
	      var rule = node;

	      node.prelude.children.each(function (selectorNode, selectorItem) {
	        var selector = {
	          item: selectorItem,
	          atrule: atrule,
	          rule: rule,
	          pseudos: /** @type {{item: any; list: any[]}[]} */ ([]),
	        };

	        selectorNode.children.each(function (
	          selectorChildNode,
	          selectorChildItem,
	          selectorChildList
	        ) {
	          if (
	            selectorChildNode.type === 'PseudoClassSelector' ||
	            selectorChildNode.type === 'PseudoElementSelector'
	          ) {
	            selector.pseudos.push({
	              item: selectorChildItem,
	              list: selectorChildList,
	            });
	          }
	        });

	        selectors.push(selector);
	      });
	    },
	  });

	  return selectors;
	}

	/**
	 * Filter selectors by Media Query.
	 *
	 * @param {Array} selectors to filter
	 * @param {Array} useMqs Array with strings of media queries that should pass (<name> <expression>)
	 * @return {Array} Filtered selectors that match the passed media queries
	 */
	function filterByMqs(selectors, useMqs) {
	  return selectors.filter(function (selector) {
	    if (selector.atrule === null) {
	      return ~useMqs.indexOf('');
	    }

	    var mqName = selector.atrule.name;
	    var mqStr = mqName;
	    if (
	      selector.atrule.expression &&
	      selector.atrule.expression.children.first().type === 'MediaQueryList'
	    ) {
	      var mqExpr = csstree.generate(selector.atrule.expression);
	      mqStr = [mqName, mqExpr].join(' ');
	    }

	    return ~useMqs.indexOf(mqStr);
	  });
	}

	/**
	 * Filter selectors by the pseudo-elements and/or -classes they contain.
	 *
	 * @param {Array} selectors to filter
	 * @param {Array} usePseudos Array with strings of single or sequence of pseudo-elements and/or -classes that should pass
	 * @return {Array} Filtered selectors that match the passed pseudo-elements and/or -classes
	 */
	function filterByPseudos(selectors, usePseudos) {
	  return selectors.filter(function (selector) {
	    var pseudoSelectorsStr = csstree.generate({
	      type: 'Selector',
	      children: new List().fromArray(
	        selector.pseudos.map(function (pseudo) {
	          return pseudo.item.data;
	        })
	      ),
	    });
	    return ~usePseudos.indexOf(pseudoSelectorsStr);
	  });
	}

	/**
	 * Remove pseudo-elements and/or -classes from the selectors for proper matching.
	 *
	 * @param {Array} selectors to clean
	 * @return {void}
	 */
	function cleanPseudos(selectors) {
	  selectors.forEach(function (selector) {
	    selector.pseudos.forEach(function (pseudo) {
	      pseudo.list.remove(pseudo.item);
	    });
	  });
	}

	/**
	 * Compares two selector specificities.
	 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
	 *
	 * @param {Array} aSpecificity Specificity of selector A
	 * @param {Array} bSpecificity Specificity of selector B
	 * @return {number} Score of selector specificity A compared to selector specificity B
	 */
	function compareSpecificity(aSpecificity, bSpecificity) {
	  for (var i = 0; i < 4; i += 1) {
	    if (aSpecificity[i] < bSpecificity[i]) {
	      return -1;
	    } else if (aSpecificity[i] > bSpecificity[i]) {
	      return 1;
	    }
	  }

	  return 0;
	}

	/**
	 * Compare two simple selectors.
	 *
	 * @param {Object} aSimpleSelectorNode Simple selector A
	 * @param {Object} bSimpleSelectorNode Simple selector B
	 * @return {number} Score of selector A compared to selector B
	 */
	function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
	  var aSpecificity = specificity(aSimpleSelectorNode),
	    bSpecificity = specificity(bSimpleSelectorNode);
	  return compareSpecificity(aSpecificity, bSpecificity);
	}

	function _bySelectorSpecificity(selectorA, selectorB) {
	  return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
	}

	/**
	 * Sort selectors stably by their specificity.
	 *
	 * @param {Array} selectors to be sorted
	 * @return {Array} Stable sorted selectors
	 */
	function sortSelectors(selectors) {
	  return stable(selectors, _bySelectorSpecificity);
	}

	/**
	 * Convert a css-tree AST style declaration to CSSStyleDeclaration property.
	 *
	 * @param {import('css-tree').CssNode} declaration css-tree style declaration
	 * @return {Object} CSSStyleDeclaration property
	 */
	function csstreeToStyleDeclaration(declaration) {
	  var propertyName = declaration.property,
	    propertyValue = csstree.generate(declaration.value),
	    propertyPriority = declaration.important ? 'important' : '';
	  return {
	    name: propertyName,
	    value: propertyValue,
	    priority: propertyPriority,
	  };
	}

	/**
	 * Gets the CSS string of a style element
	 *
	 * @param {Object} elem style element
	 * @return {string} CSS string or empty array if no styles are set
	 */
	function getCssStr(elem) {
	  if (
	    elem.children.length > 0 &&
	    (elem.children[0].type === 'text' || elem.children[0].type === 'cdata')
	  ) {
	    return elem.children[0].value;
	  }
	  return '';
	}

	/**
	 * Sets the CSS string of a style element
	 *
	 * @param {Object} elem style element
	 * @param {string} css string to be set
	 * @return {string} reference to field with CSS
	 */
	function setCssStr(elem, css) {
	  if (elem.children.length === 0) {
	    elem.children.push({
	      type: 'text',
	      value: '',
	    });
	  }

	  if (elem.children[0].type !== 'text' && elem.children[0].type !== 'cdata') {
	    return css;
	  }

	  elem.children[0].value = css;

	  return css;
	}

	cssTools.flattenToSelectors = flattenToSelectors;

	cssTools.filterByMqs = filterByMqs;
	cssTools.filterByPseudos = filterByPseudos;
	cssTools.cleanPseudos = cleanPseudos;

	cssTools.compareSpecificity = compareSpecificity;
	cssTools.compareSimpleSelectorNode = compareSimpleSelectorNode;

	cssTools.sortSelectors = sortSelectors;

	cssTools.csstreeToStyleDeclaration = csstreeToStyleDeclaration;

	cssTools.getCssStr = getCssStr;
	cssTools.setCssStr = setCssStr;
	return cssTools;
}

var cssStyleDeclaration;
var hasRequiredCssStyleDeclaration;

function requireCssStyleDeclaration () {
	if (hasRequiredCssStyleDeclaration) return cssStyleDeclaration;
	hasRequiredCssStyleDeclaration = 1;

	var csstree = requireLib$1(),
	  csstools = requireCssTools();

	var CSSStyleDeclaration = function (node) {
	  this.parentNode = node;

	  this.properties = new Map();
	  this.hasSynced = false;

	  this.styleValue = null;

	  this.parseError = false;
	  const value = node.attributes.style;
	  if (value != null) {
	    this.addStyleValueHandler();
	    this.setStyleValue(value);
	  }
	};

	// attr.style.value

	CSSStyleDeclaration.prototype.addStyleValueHandler = function () {
	  Object.defineProperty(this.parentNode.attributes, 'style', {
	    get: this.getStyleValue.bind(this),
	    set: this.setStyleValue.bind(this),
	    enumerable: true,
	    configurable: true,
	  });
	};

	CSSStyleDeclaration.prototype.getStyleValue = function () {
	  return this.getCssText();
	};

	CSSStyleDeclaration.prototype.setStyleValue = function (newValue) {
	  this.properties.clear(); // reset all existing properties
	  this.styleValue = newValue;
	  this.hasSynced = false; // raw css changed
	};

	CSSStyleDeclaration.prototype._loadCssText = function () {
	  if (this.hasSynced) {
	    return;
	  }
	  this.hasSynced = true; // must be set here to prevent loop in setProperty(...)

	  if (!this.styleValue || this.styleValue.length === 0) {
	    return;
	  }
	  var inlineCssStr = this.styleValue;

	  var declarations = {};
	  try {
	    declarations = csstree.parse(inlineCssStr, {
	      context: 'declarationList',
	      parseValue: false,
	    });
	  } catch (parseError) {
	    this.parseError = parseError;
	    return;
	  }
	  this.parseError = false;

	  var self = this;
	  declarations.children.each(function (declaration) {
	    try {
	      var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
	      self.setProperty(
	        styleDeclaration.name,
	        styleDeclaration.value,
	        styleDeclaration.priority
	      );
	    } catch (styleError) {
	      if (styleError.message !== 'Unknown node type: undefined') {
	        self.parseError = styleError;
	      }
	    }
	  });
	};

	// only reads from properties

	/**
	 * Get the textual representation of the declaration block (equivalent to .cssText attribute).
	 *
	 * @return {string} Textual representation of the declaration block (empty string for no properties)
	 */
	CSSStyleDeclaration.prototype.getCssText = function () {
	  var properties = this.getProperties();

	  if (this.parseError) {
	    // in case of a parse error, pass through original styles
	    return this.styleValue;
	  }

	  var cssText = [];
	  properties.forEach(function (property, propertyName) {
	    var strImportant = property.priority === 'important' ? '!important' : '';
	    cssText.push(
	      propertyName.trim() + ':' + property.value.trim() + strImportant
	    );
	  });
	  return cssText.join(';');
	};

	CSSStyleDeclaration.prototype._handleParseError = function () {
	  if (this.parseError) {
	    console.warn(
	      "Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr('style').value. Error details: " +
	        this.parseError
	    );
	  }
	};

	CSSStyleDeclaration.prototype._getProperty = function (propertyName) {
	  if (typeof propertyName === 'undefined') {
	    throw Error('1 argument required, but only 0 present.');
	  }

	  var properties = this.getProperties();
	  this._handleParseError();

	  var property = properties.get(propertyName.trim());
	  return property;
	};

	/**
	 * Return the optional priority, "important".
	 *
	 * @param {string} propertyName representing the property name to be checked.
	 * @return {string} priority that represents the priority (e.g. "important") if one exists. If none exists, returns the empty string.
	 */
	CSSStyleDeclaration.prototype.getPropertyPriority = function (propertyName) {
	  var property = this._getProperty(propertyName);
	  return property ? property.priority : '';
	};

	/**
	 * Return the property value given a property name.
	 *
	 * @param {string} propertyName representing the property name to be checked.
	 * @return {string} value containing the value of the property. If not set, returns the empty string.
	 */
	CSSStyleDeclaration.prototype.getPropertyValue = function (propertyName) {
	  var property = this._getProperty(propertyName);
	  return property ? property.value : null;
	};

	/**
	 * Return a property name.
	 *
	 * @param {number} index of the node to be fetched. The index is zero-based.
	 * @return {string} propertyName that is the name of the CSS property at the specified index.
	 */
	CSSStyleDeclaration.prototype.item = function (index) {
	  if (typeof index === 'undefined') {
	    throw Error('1 argument required, but only 0 present.');
	  }

	  var properties = this.getProperties();
	  this._handleParseError();

	  return Array.from(properties.keys())[index];
	};

	/**
	 * Return all properties of the node.
	 *
	 * @return {Map} properties that is a Map with propertyName as key and property (propertyValue + propertyPriority) as value.
	 */
	CSSStyleDeclaration.prototype.getProperties = function () {
	  this._loadCssText();
	  return this.properties;
	};

	// writes to properties

	/**
	 * Remove a property from the CSS declaration block.
	 *
	 * @param {string} propertyName representing the property name to be removed.
	 * @return {string} oldValue equal to the value of the CSS property before it was removed.
	 */
	CSSStyleDeclaration.prototype.removeProperty = function (propertyName) {
	  if (typeof propertyName === 'undefined') {
	    throw Error('1 argument required, but only 0 present.');
	  }

	  this.addStyleValueHandler();

	  var properties = this.getProperties();
	  this._handleParseError();

	  var oldValue = this.getPropertyValue(propertyName);
	  properties.delete(propertyName.trim());
	  return oldValue;
	};

	/**
	 * Modify an existing CSS property or creates a new CSS property in the declaration block.
	 *
	 * @param {string} propertyName representing the CSS property name to be modified.
	 * @param {string} value containing the new property value. If not specified, treated as the empty string. value must not contain "!important" -- that should be set using the priority parameter.
	 * @param {string} priority allowing the "important" CSS priority to be set. If not specified, treated as the empty string.
	 * @return {{value: string, priority: string}}
	 */
	CSSStyleDeclaration.prototype.setProperty = function (
	  propertyName,
	  value,
	  priority
	) {
	  if (typeof propertyName === 'undefined') {
	    throw Error('propertyName argument required, but only not present.');
	  }

	  this.addStyleValueHandler();

	  var properties = this.getProperties();
	  this._handleParseError();

	  var property = {
	    value: value.trim(),
	    priority: priority.trim(),
	  };
	  properties.set(propertyName.trim(), property);

	  return property;
	};

	cssStyleDeclaration = CSSStyleDeclaration;
	return cssStyleDeclaration;
}

var jsAPI;
var hasRequiredJsAPI;

function requireJsAPI () {
	if (hasRequiredJsAPI) return jsAPI;
	hasRequiredJsAPI = 1;

	const { selectAll, selectOne, is } = requireLib$2();
	const svgoCssSelectAdapter = requireCssSelectAdapter();
	const CSSClassList = requireCssClassList();
	const CSSStyleDeclaration = requireCssStyleDeclaration();

	/**
	 * @type {(name: string) => { prefix: string, local: string }}
	 */
	const parseName = (name) => {
	  if (name == null) {
	    return {
	      prefix: '',
	      local: '',
	    };
	  }
	  if (name === 'xmlns') {
	    return {
	      prefix: 'xmlns',
	      local: '',
	    };
	  }
	  const chunks = name.split(':');
	  if (chunks.length === 1) {
	    return {
	      prefix: '',
	      local: chunks[0],
	    };
	  }
	  return {
	    prefix: chunks[0],
	    local: chunks[1],
	  };
	};

	var cssSelectOpts = {
	  xmlMode: true,
	  adapter: svgoCssSelectAdapter,
	};

	const attrsHandler = {
	  get: (attributes, name) => {
	    // eslint-disable-next-line no-prototype-builtins
	    if (attributes.hasOwnProperty(name)) {
	      return {
	        name,
	        get value() {
	          return attributes[name];
	        },
	        set value(value) {
	          attributes[name] = value;
	        },
	      };
	    }
	  },
	  set: (attributes, name, attr) => {
	    attributes[name] = attr.value;
	    return true;
	  },
	};

	var JSAPI = function (data, parentNode) {
	  Object.assign(this, data);
	  if (this.type === 'element') {
	    if (this.attributes == null) {
	      this.attributes = {};
	    }
	    if (this.children == null) {
	      this.children = [];
	    }
	    Object.defineProperty(this, 'class', {
	      writable: true,
	      configurable: true,
	      value: new CSSClassList(this),
	    });
	    Object.defineProperty(this, 'style', {
	      writable: true,
	      configurable: true,
	      value: new CSSStyleDeclaration(this),
	    });
	    Object.defineProperty(this, 'parentNode', {
	      writable: true,
	      value: parentNode,
	    });

	    // temporary attrs polyfill
	    // TODO remove after migration
	    const element = this;
	    Object.defineProperty(this, 'attrs', {
	      configurable: true,
	      get() {
	        return new Proxy(element.attributes, attrsHandler);
	      },
	      set(value) {
	        const newAttributes = {};
	        for (const attr of Object.values(value)) {
	          newAttributes[attr.name] = attr.value;
	        }
	        element.attributes = newAttributes;
	      },
	    });
	  }
	};
	jsAPI = JSAPI;

	/**
	 * Perform a deep clone of this node.
	 *
	 * @return {Object} element
	 */
	JSAPI.prototype.clone = function () {
	  const { children, ...nodeData } = this;
	  // Deep-clone node data.
	  const clonedNode = new JSAPI(JSON.parse(JSON.stringify(nodeData)), null);
	  if (children) {
	    clonedNode.children = children.map((child) => {
	      const clonedChild = child.clone();
	      clonedChild.parentNode = clonedNode;
	      return clonedChild;
	    });
	  }
	  return clonedNode;
	};

	/**
	 * Determine if item is an element
	 * (any, with a specific name or in a names array).
	 *
	 * @param {String|Array} [param] element name or names arrays
	 * @return {Boolean}
	 */
	JSAPI.prototype.isElem = function (param) {
	  if (this.type !== 'element') {
	    return false;
	  }
	  if (param == null) {
	    return true;
	  }
	  if (Array.isArray(param)) {
	    return param.includes(this.name);
	  }
	  return this.name === param;
	};

	/**
	 * Renames an element
	 *
	 * @param {String} name new element name
	 * @return {Object} element
	 */
	JSAPI.prototype.renameElem = function (name) {
	  if (name && typeof name === 'string') this.name = name;

	  return this;
	};

	/**
	 * Determine if element is empty.
	 *
	 * @return {Boolean}
	 */
	JSAPI.prototype.isEmpty = function () {
	  return !this.children || !this.children.length;
	};

	/**
	 * Find the closest ancestor of the current element.
	 * @param elemName
	 *
	 * @return {?Object}
	 */
	JSAPI.prototype.closestElem = function (elemName) {
	  var elem = this;

	  while ((elem = elem.parentNode) && !elem.isElem(elemName));

	  return elem;
	};

	/**
	 * Changes children by removing elements and/or adding new elements.
	 *
	 * @param {Number} start Index at which to start changing the children.
	 * @param {Number} n Number of elements to remove.
	 * @param {Array|Object} [insertion] Elements to add to the children.
	 * @return {Array} Removed elements.
	 */
	JSAPI.prototype.spliceContent = function (start, n, insertion) {
	  if (arguments.length < 2) return [];

	  if (!Array.isArray(insertion))
	    insertion = Array.apply(null, arguments).slice(2);

	  insertion.forEach(function (inner) {
	    inner.parentNode = this;
	  }, this);

	  return this.children.splice.apply(
	    this.children,
	    [start, n].concat(insertion)
	  );
	};

	/**
	 * Determine if element has an attribute
	 * (any, or by name or by name + value).
	 *
	 * @param {String} [name] attribute name
	 * @param {String} [val] attribute value (will be toString()'ed)
	 * @return {Boolean}
	 */
	JSAPI.prototype.hasAttr = function (name, val) {
	  if (this.type !== 'element') {
	    return false;
	  }
	  if (Object.keys(this.attributes).length === 0) {
	    return false;
	  }
	  if (name == null) {
	    return true;
	  }
	  // eslint-disable-next-line no-prototype-builtins
	  if (this.attributes.hasOwnProperty(name) === false) {
	    return false;
	  }
	  if (val !== undefined) {
	    return this.attributes[name] === val.toString();
	  }
	  return true;
	};

	/**
	 * Determine if element has an attribute by local name
	 * (any, or by name or by name + value).
	 *
	 * @param {String} [localName] local attribute name
	 * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)
	 * @return {Boolean}
	 */
	JSAPI.prototype.hasAttrLocal = function (localName, val) {
	  if (!this.attrs || !Object.keys(this.attrs).length) return false;

	  if (!arguments.length) return !!this.attrs;

	  var callback;

	  switch (val != null && val.constructor && val.constructor.name) {
	    case 'Number': // same as String
	    case 'String':
	      callback = stringValueTest;
	      break;
	    case 'RegExp':
	      callback = regexpValueTest;
	      break;
	    case 'Function':
	      callback = funcValueTest;
	      break;
	    default:
	      callback = nameTest;
	  }
	  return this.someAttr(callback);

	  function nameTest(attr) {
	    const { local } = parseName(attr.name);
	    return local === localName;
	  }

	  function stringValueTest(attr) {
	    const { local } = parseName(attr.name);
	    return local === localName && val == attr.value;
	  }

	  function regexpValueTest(attr) {
	    const { local } = parseName(attr.name);
	    return local === localName && val.test(attr.value);
	  }

	  function funcValueTest(attr) {
	    const { local } = parseName(attr.name);
	    return local === localName && val(attr.value);
	  }
	};

	/**
	 * Get a specific attribute from an element
	 * (by name or name + value).
	 *
	 * @param {String} name attribute name
	 * @param {String} [val] attribute value (will be toString()'ed)
	 * @return {Object|Undefined}
	 */
	JSAPI.prototype.attr = function (name, val) {
	  if (this.hasAttr(name, val)) {
	    return this.attrs[name];
	  }
	};

	/**
	 * Get computed attribute value from an element
	 *
	 * @param {String} name attribute name
	 * @return {Object|Undefined}
	 */
	JSAPI.prototype.computedAttr = function (name, val) {
	  if (!arguments.length) return;

	  for (
	    var elem = this;
	    elem && (!elem.hasAttr(name) || !elem.attributes[name]);
	    elem = elem.parentNode
	  );

	  if (val != null) {
	    return elem ? elem.hasAttr(name, val) : false;
	  } else if (elem && elem.hasAttr(name)) {
	    return elem.attributes[name];
	  }
	};

	/**
	 * Remove a specific attribute.
	 *
	 * @param {String|Array} name attribute name
	 * @param {String} [val] attribute value
	 * @return {Boolean}
	 */
	JSAPI.prototype.removeAttr = function (name, val) {
	  if (this.type !== 'element') {
	    return false;
	  }
	  if (arguments.length === 0) {
	    return false;
	  }
	  if (Array.isArray(name)) {
	    for (const nameItem of name) {
	      this.removeAttr(nameItem, val);
	    }
	    return false;
	  }
	  if (this.hasAttr(name, val) === false) {
	    return false;
	  }
	  delete this.attributes[name];
	  return true;
	};

	/**
	 * Add attribute.
	 *
	 * @param {Object} [attr={}] attribute object
	 * @return {Object|Boolean} created attribute or false if no attr was passed in
	 */
	JSAPI.prototype.addAttr = function (attr) {
	  attr = attr || {};

	  if (attr.name === undefined) return false;

	  this.attributes[attr.name] = attr.value;

	  if (attr.name === 'class') {
	    // newly added class attribute
	    this.class.addClassValueHandler();
	  }

	  if (attr.name === 'style') {
	    // newly added style attribute
	    this.style.addStyleValueHandler();
	  }

	  return this.attrs[attr.name];
	};

	/**
	 * Iterates over all attributes.
	 *
	 * @param {Function} callback callback
	 * @param {Object} [context] callback context
	 * @return {Boolean} false if there are no any attributes
	 */
	JSAPI.prototype.eachAttr = function (callback, context) {
	  if (this.type !== 'element') {
	    return false;
	  }
	  if (callback == null) {
	    return false;
	  }
	  for (const attr of Object.values(this.attrs)) {
	    callback.call(context, attr);
	  }
	  return true;
	};

	/**
	 * Tests whether some attribute passes the test.
	 *
	 * @param {Function} callback callback
	 * @param {Object} [context] callback context
	 * @return {Boolean} false if there are no any attributes
	 */
	JSAPI.prototype.someAttr = function (callback, context) {
	  if (this.type !== 'element') {
	    return false;
	  }

	  for (const attr of Object.values(this.attrs)) {
	    if (callback.call(context, attr)) return true;
	  }

	  return false;
	};

	/**
	 * Evaluate a string of CSS selectors against the element and returns matched elements.
	 *
	 * @param {String} selectors CSS selector(s) string
	 * @return {Array} null if no elements matched
	 */
	JSAPI.prototype.querySelectorAll = function (selectors) {
	  var matchedEls = selectAll(selectors, this, cssSelectOpts);

	  return matchedEls.length > 0 ? matchedEls : null;
	};

	/**
	 * Evaluate a string of CSS selectors against the element and returns only the first matched element.
	 *
	 * @param {String} selectors CSS selector(s) string
	 * @return {Array} null if no element matched
	 */
	JSAPI.prototype.querySelector = function (selectors) {
	  return selectOne(selectors, this, cssSelectOpts);
	};

	/**
	 * Test if a selector matches a given element.
	 *
	 * @param {String} selector CSS selector string
	 * @return {Boolean} true if element would be selected by selector string, false if it does not
	 */
	JSAPI.prototype.matches = function (selector) {
	  return is(this, selector, cssSelectOpts);
	};
	return jsAPI;
}

var hasRequiredMergeStyles;

function requireMergeStyles () {
	if (hasRequiredMergeStyles) return mergeStyles;
	hasRequiredMergeStyles = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 */

	const { visitSkip, detachNodeFromParent } = requireXast();
	const JSAPI = requireJsAPI();

	mergeStyles.name = 'mergeStyles';
	mergeStyles.type = 'visitor';
	mergeStyles.active = true;
	mergeStyles.description = 'merge multiple style elements into one';

	/**
	 * Merge multiple style elements into one.
	 *
	 * @author strarsis <strarsis@gmail.com>
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	mergeStyles.fn = () => {
	  /**
	   * @type {null | XastElement}
	   */
	  let firstStyleElement = null;
	  let collectedStyles = '';
	  let styleContentType = 'text';

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // skip <foreignObject> content
	        if (node.name === 'foreignObject') {
	          return visitSkip;
	        }

	        // collect style elements
	        if (node.name !== 'style') {
	          return;
	        }

	        // skip <style> with invalid type attribute
	        if (
	          node.attributes.type != null &&
	          node.attributes.type !== '' &&
	          node.attributes.type !== 'text/css'
	        ) {
	          return;
	        }

	        // extract style element content
	        let css = '';
	        for (const child of node.children) {
	          if (child.type === 'text') {
	            css += child.value;
	          }
	          if (child.type === 'cdata') {
	            styleContentType = 'cdata';
	            css += child.value;
	          }
	        }

	        // remove empty style elements
	        if (css.trim().length === 0) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // collect css and wrap with media query if present in attribute
	        if (node.attributes.media == null) {
	          collectedStyles += css;
	        } else {
	          collectedStyles += `@media ${node.attributes.media}{${css}}`;
	          delete node.attributes.media;
	        }

	        // combine collected styles in the first style element
	        if (firstStyleElement == null) {
	          firstStyleElement = node;
	        } else {
	          detachNodeFromParent(node, parentNode);
	          firstStyleElement.children = [
	            new JSAPI(
	              { type: styleContentType, value: collectedStyles },
	              firstStyleElement
	            ),
	          ];
	        }
	      },
	    },
	  };
	};
	return mergeStyles;
}

var inlineStyles = {};

var hasRequiredInlineStyles;

function requireInlineStyles () {
	if (hasRequiredInlineStyles) return inlineStyles;
	hasRequiredInlineStyles = 1;

	/**
	 * @typedef {import('../lib/types').Specificity} Specificity
	 * @typedef {import('../lib/types').XastElement} XastElement
	 * @typedef {import('../lib/types').XastParent} XastParent
	 */

	const csstree = requireLib$1();
	// @ts-ignore not defined in @types/csso
	const specificity = requireSpecificity();
	const stable = requireStable();
	const {
	  visitSkip,
	  querySelectorAll,
	  detachNodeFromParent,
	} = requireXast();

	inlineStyles.type = 'visitor';
	inlineStyles.name = 'inlineStyles';
	inlineStyles.active = true;
	inlineStyles.description = 'inline styles (additional options)';

	/**
	 * Compares two selector specificities.
	 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
	 *
	 * @type {(a: Specificity, b: Specificity) => number}
	 */
	const compareSpecificity = (a, b) => {
	  for (var i = 0; i < 4; i += 1) {
	    if (a[i] < b[i]) {
	      return -1;
	    } else if (a[i] > b[i]) {
	      return 1;
	    }
	  }
	  return 0;
	};

	/**
	 * Moves + merges styles from style elements to element styles
	 *
	 * Options
	 *   onlyMatchedOnce (default: true)
	 *     inline only selectors that match once
	 *
	 *   removeMatchedSelectors (default: true)
	 *     clean up matched selectors,
	 *     leave selectors that hadn't matched
	 *
	 *   useMqs (default: ['', 'screen'])
	 *     what media queries to be used
	 *     empty string element for styles outside media queries
	 *
	 *   usePseudos (default: [''])
	 *     what pseudo-classes/-elements to be used
	 *     empty string element for all non-pseudo-classes and/or -elements
	 *
	 * @author strarsis <strarsis@gmail.com>
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   onlyMatchedOnce?: boolean,
	 *   removeMatchedSelectors?: boolean,
	 *   useMqs?: Array<string>,
	 *   usePseudos?: Array<string>
	 * }>}
	 */
	inlineStyles.fn = (root, params) => {
	  const {
	    onlyMatchedOnce = true,
	    removeMatchedSelectors = true,
	    useMqs = ['', 'screen'],
	    usePseudos = [''],
	  } = params;

	  /**
	   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}
	   */
	  const styles = [];
	  /**
	   * @type {Array<{
	   *   node: csstree.Selector,
	   *   item: csstree.ListItem<csstree.CssNode>,
	   *   rule: csstree.Rule,
	   *   matchedElements?: Array<XastElement>
	   * }>}
	   */
	  let selectors = [];

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // skip <foreignObject /> content
	        if (node.name === 'foreignObject') {
	          return visitSkip;
	        }
	        // collect only non-empty <style /> elements
	        if (node.name !== 'style' || node.children.length === 0) {
	          return;
	        }
	        // values other than the empty string or text/css are not used
	        if (
	          node.attributes.type != null &&
	          node.attributes.type !== '' &&
	          node.attributes.type !== 'text/css'
	        ) {
	          return;
	        }
	        // parse css in style element
	        let cssText = '';
	        for (const child of node.children) {
	          if (child.type === 'text' || child.type === 'cdata') {
	            cssText += child.value;
	          }
	        }
	        /**
	         * @type {null | csstree.CssNode}
	         */
	        let cssAst = null;
	        try {
	          cssAst = csstree.parse(cssText, {
	            parseValue: false,
	            parseCustomProperty: false,
	          });
	        } catch {
	          return;
	        }
	        if (cssAst.type === 'StyleSheet') {
	          styles.push({ node, parentNode, cssAst });
	        }

	        // collect selectors
	        csstree.walk(cssAst, {
	          visit: 'Selector',
	          enter(node, item) {
	            const atrule = this.atrule;
	            const rule = this.rule;
	            if (rule == null) {
	              return;
	            }

	            // skip media queries not included into useMqs param
	            let mq = '';
	            if (atrule != null) {
	              mq = atrule.name;
	              if (atrule.prelude != null) {
	                mq += ` ${csstree.generate(atrule.prelude)}`;
	              }
	            }
	            if (useMqs.includes(mq) === false) {
	              return;
	            }

	            /**
	             * @type {Array<{
	             *   item: csstree.ListItem<csstree.CssNode>,
	             *   list: csstree.List<csstree.CssNode>
	             * }>}
	             */
	            const pseudos = [];
	            if (node.type === 'Selector') {
	              node.children.each((childNode, childItem, childList) => {
	                if (
	                  childNode.type === 'PseudoClassSelector' ||
	                  childNode.type === 'PseudoElementSelector'
	                ) {
	                  pseudos.push({ item: childItem, list: childList });
	                }
	              });
	            }

	            // skip pseudo classes and pseudo elements not includes into usePseudos param
	            const pseudoSelectors = csstree.generate({
	              type: 'Selector',
	              children: new csstree.List().fromArray(
	                pseudos.map((pseudo) => pseudo.item.data)
	              ),
	            });
	            if (usePseudos.includes(pseudoSelectors) === false) {
	              return;
	            }

	            // remove pseudo classes and elements to allow querySelector match elements
	            // TODO this is not very accurate since some pseudo classes like first-child
	            // are used for selection
	            for (const pseudo of pseudos) {
	              pseudo.list.remove(pseudo.item);
	            }

	            selectors.push({ node, item, rule });
	          },
	        });
	      },
	    },

	    root: {
	      exit: () => {
	        if (styles.length === 0) {
	          return;
	        }
	        // stable sort selectors
	        const sortedSelectors = stable(selectors, (a, b) => {
	          const aSpecificity = specificity(a.item.data);
	          const bSpecificity = specificity(b.item.data);
	          return compareSpecificity(aSpecificity, bSpecificity);
	        }).reverse();

	        for (const selector of sortedSelectors) {
	          // match selectors
	          const selectorText = csstree.generate(selector.item.data);
	          /**
	           * @type {Array<XastElement>}
	           */
	          const matchedElements = [];
	          try {
	            for (const node of querySelectorAll(root, selectorText)) {
	              if (node.type === 'element') {
	                matchedElements.push(node);
	              }
	            }
	          } catch (selectError) {
	            continue;
	          }
	          // nothing selected
	          if (matchedElements.length === 0) {
	            continue;
	          }

	          // apply styles to matched elements
	          // skip selectors that match more than once if option onlyMatchedOnce is enabled
	          if (onlyMatchedOnce && matchedElements.length > 1) {
	            continue;
	          }

	          // apply <style/> to matched elements
	          for (const selectedEl of matchedElements) {
	            const styleDeclarationList = csstree.parse(
	              selectedEl.attributes.style == null
	                ? ''
	                : selectedEl.attributes.style,
	              {
	                context: 'declarationList',
	                parseValue: false,
	              }
	            );
	            if (styleDeclarationList.type !== 'DeclarationList') {
	              continue;
	            }
	            const styleDeclarationItems = new Map();
	            csstree.walk(styleDeclarationList, {
	              visit: 'Declaration',
	              enter(node, item) {
	                styleDeclarationItems.set(node.property, item);
	              },
	            });
	            // merge declarations
	            csstree.walk(selector.rule, {
	              visit: 'Declaration',
	              enter(ruleDeclaration) {
	                // existing inline styles have higher priority
	                // no inline styles, external styles,                                    external styles used
	                // inline styles,    external styles same   priority as inline styles,   inline   styles used
	                // inline styles,    external styles higher priority than inline styles, external styles used
	                const matchedItem = styleDeclarationItems.get(
	                  ruleDeclaration.property
	                );
	                const ruleDeclarationItem =
	                  styleDeclarationList.children.createItem(ruleDeclaration);
	                if (matchedItem == null) {
	                  styleDeclarationList.children.append(ruleDeclarationItem);
	                } else if (
	                  matchedItem.data.important !== true &&
	                  ruleDeclaration.important === true
	                ) {
	                  styleDeclarationList.children.replace(
	                    matchedItem,
	                    ruleDeclarationItem
	                  );
	                  styleDeclarationItems.set(
	                    ruleDeclaration.property,
	                    ruleDeclarationItem
	                  );
	                }
	              },
	            });
	            selectedEl.attributes.style =
	              csstree.generate(styleDeclarationList);
	          }

	          if (
	            removeMatchedSelectors &&
	            matchedElements.length !== 0 &&
	            selector.rule.prelude.type === 'SelectorList'
	          ) {
	            // clean up matching simple selectors if option removeMatchedSelectors is enabled
	            selector.rule.prelude.children.remove(selector.item);
	          }
	          selector.matchedElements = matchedElements;
	        }

	        // no further processing required
	        if (removeMatchedSelectors === false) {
	          return;
	        }

	        // clean up matched class + ID attribute values
	        for (const selector of sortedSelectors) {
	          if (selector.matchedElements == null) {
	            continue;
	          }

	          if (onlyMatchedOnce && selector.matchedElements.length > 1) {
	            // skip selectors that match more than once if option onlyMatchedOnce is enabled
	            continue;
	          }

	          for (const selectedEl of selector.matchedElements) {
	            // class
	            const classList = new Set(
	              selectedEl.attributes.class == null
	                ? null
	                : selectedEl.attributes.class.split(' ')
	            );
	            const firstSubSelector = selector.node.children.first();
	            if (
	              firstSubSelector != null &&
	              firstSubSelector.type === 'ClassSelector'
	            ) {
	              classList.delete(firstSubSelector.name);
	            }
	            if (classList.size === 0) {
	              delete selectedEl.attributes.class;
	            } else {
	              selectedEl.attributes.class = Array.from(classList).join(' ');
	            }

	            // ID
	            if (
	              firstSubSelector != null &&
	              firstSubSelector.type === 'IdSelector'
	            ) {
	              if (selectedEl.attributes.id === firstSubSelector.name) {
	                delete selectedEl.attributes.id;
	              }
	            }
	          }
	        }

	        for (const style of styles) {
	          csstree.walk(style.cssAst, {
	            visit: 'Rule',
	            enter: function (node, item, list) {
	              // clean up <style/> rulesets without any css selectors left
	              if (
	                node.type === 'Rule' &&
	                node.prelude.type === 'SelectorList' &&
	                node.prelude.children.isEmpty()
	              ) {
	                list.remove(item);
	              }
	            },
	          });

	          if (style.cssAst.children.isEmpty()) {
	            // remove emtpy style element
	            detachNodeFromParent(style.node, style.parentNode);
	          } else {
	            // update style element if any styles left
	            const firstChild = style.node.children[0];
	            if (firstChild.type === 'text' || firstChild.type === 'cdata') {
	              firstChild.value = csstree.generate(style.cssAst);
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return inlineStyles;
}

var minifyStyles = {};

var usage;
var hasRequiredUsage;

function requireUsage () {
	if (hasRequiredUsage) return usage;
	hasRequiredUsage = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function buildMap(list, caseInsensitive) {
	    var map = Object.create(null);

	    if (!Array.isArray(list)) {
	        return null;
	    }

	    for (var i = 0; i < list.length; i++) {
	        var name = list[i];

	        if (caseInsensitive) {
	            name = name.toLowerCase();
	        }

	        map[name] = true;
	    }

	    return map;
	}

	function buildList(data) {
	    if (!data) {
	        return null;
	    }

	    var tags = buildMap(data.tags, true);
	    var ids = buildMap(data.ids);
	    var classes = buildMap(data.classes);

	    if (tags === null &&
	        ids === null &&
	        classes === null) {
	        return null;
	    }

	    return {
	        tags: tags,
	        ids: ids,
	        classes: classes
	    };
	}

	function buildIndex(data) {
	    var scopes = false;

	    if (data.scopes && Array.isArray(data.scopes)) {
	        scopes = Object.create(null);

	        for (var i = 0; i < data.scopes.length; i++) {
	            var list = data.scopes[i];

	            if (!list || !Array.isArray(list)) {
	                throw new Error('Wrong usage format');
	            }

	            for (var j = 0; j < list.length; j++) {
	                var name = list[j];

	                if (hasOwnProperty.call(scopes, name)) {
	                    throw new Error('Class can\'t be used for several scopes: ' + name);
	                }

	                scopes[name] = i + 1;
	            }
	        }
	    }

	    return {
	        whitelist: buildList(data),
	        blacklist: buildList(data.blacklist),
	        scopes: scopes
	    };
	}

	usage = {
	    buildIndex: buildIndex
	};
	return usage;
}

var utils$1;
var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	utils$1 = {
	    hasNoChildren: function(node) {
	        return !node || !node.children || node.children.isEmpty();
	    },
	    isNodeChildrenList: function(node, list) {
	        return node !== null && node.children === list;
	    }
	};
	return utils$1;
}

var Atrule$1;
var hasRequiredAtrule$1;

function requireAtrule$1 () {
	if (hasRequiredAtrule$1) return Atrule$1;
	hasRequiredAtrule$1 = 1;
	var resolveKeyword = requireLib$1().keyword;
	var { hasNoChildren } = requireUtils$1();

	Atrule$1 = function cleanAtrule(node, item, list) {
	    if (node.block) {
	        // otherwise removed at-rule don't prevent @import for removal
	        if (this.stylesheet !== null) {
	            this.stylesheet.firstAtrulesAllowed = false;
	        }

	        if (hasNoChildren(node.block)) {
	            list.remove(item);
	            return;
	        }
	    }

	    switch (node.name) {
	        case 'charset':
	            if (hasNoChildren(node.prelude)) {
	                list.remove(item);
	                return;
	            }

	            // if there is any rule before @charset -> remove it
	            if (item.prev) {
	                list.remove(item);
	                return;
	            }

	            break;

	        case 'import':
	            if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
	                list.remove(item);
	                return;
	            }

	            // if there are some rules that not an @import or @charset before @import
	            // remove it
	            list.prevUntil(item.prev, function(rule) {
	                if (rule.type === 'Atrule') {
	                    if (rule.name === 'import' || rule.name === 'charset') {
	                        return;
	                    }
	                }

	                this.root.firstAtrulesAllowed = false;
	                list.remove(item);
	                return true;
	            }, this);

	            break;

	        default:
	            var name = resolveKeyword(node.name).basename;
	            if (name === 'keyframes' ||
	                name === 'media' ||
	                name === 'supports') {

	                // drop at-rule with no prelude
	                if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
	                    list.remove(item);
	                }
	            }
	    }
	};
	return Atrule$1;
}

var Comment;
var hasRequiredComment;

function requireComment () {
	if (hasRequiredComment) return Comment;
	hasRequiredComment = 1;
	Comment = function cleanComment(data, item, list) {
	    list.remove(item);
	};
	return Comment;
}

var Declaration;
var hasRequiredDeclaration;

function requireDeclaration () {
	if (hasRequiredDeclaration) return Declaration;
	hasRequiredDeclaration = 1;
	var property = requireLib$1().property;

	Declaration = function cleanDeclartion(node, item, list) {
	    if (node.value.children && node.value.children.isEmpty()) {
	        list.remove(item);
	        return;
	    }

	    if (property(node.property).custom) {
	        if (/\S/.test(node.value.value)) {
	            node.value.value = node.value.value.trim();
	        }
	    }
	};
	return Declaration;
}

var Raw;
var hasRequiredRaw;

function requireRaw () {
	if (hasRequiredRaw) return Raw;
	hasRequiredRaw = 1;
	var { isNodeChildrenList } = requireUtils$1();

	Raw = function cleanRaw(node, item, list) {
	    // raw in stylesheet or block children
	    if (isNodeChildrenList(this.stylesheet, list) ||
	        isNodeChildrenList(this.block, list)) {
	        list.remove(item);
	    }
	};
	return Raw;
}

var Rule;
var hasRequiredRule;

function requireRule () {
	if (hasRequiredRule) return Rule;
	hasRequiredRule = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var walk = requireLib$1().walk;
	var { hasNoChildren } = requireUtils$1();

	function cleanUnused(selectorList, usageData) {
	    selectorList.children.each(function(selector, item, list) {
	        var shouldRemove = false;

	        walk(selector, function(node) {
	            // ignore nodes in nested selectors
	            if (this.selector === null || this.selector === selectorList) {
	                switch (node.type) {
	                    case 'SelectorList':
	                        // TODO: remove toLowerCase when pseudo selectors will be normalized
	                        // ignore selectors inside :not()
	                        if (this.function === null || this.function.name.toLowerCase() !== 'not') {
	                            if (cleanUnused(node, usageData)) {
	                                shouldRemove = true;
	                            }
	                        }
	                        break;

	                    case 'ClassSelector':
	                        if (usageData.whitelist !== null &&
	                            usageData.whitelist.classes !== null &&
	                            !hasOwnProperty.call(usageData.whitelist.classes, node.name)) {
	                            shouldRemove = true;
	                        }
	                        if (usageData.blacklist !== null &&
	                            usageData.blacklist.classes !== null &&
	                            hasOwnProperty.call(usageData.blacklist.classes, node.name)) {
	                            shouldRemove = true;
	                        }
	                        break;

	                    case 'IdSelector':
	                        if (usageData.whitelist !== null &&
	                            usageData.whitelist.ids !== null &&
	                            !hasOwnProperty.call(usageData.whitelist.ids, node.name)) {
	                            shouldRemove = true;
	                        }
	                        if (usageData.blacklist !== null &&
	                            usageData.blacklist.ids !== null &&
	                            hasOwnProperty.call(usageData.blacklist.ids, node.name)) {
	                            shouldRemove = true;
	                        }
	                        break;

	                    case 'TypeSelector':
	                        // TODO: remove toLowerCase when type selectors will be normalized
	                        // ignore universal selectors
	                        if (node.name.charAt(node.name.length - 1) !== '*') {
	                            if (usageData.whitelist !== null &&
	                                usageData.whitelist.tags !== null &&
	                                !hasOwnProperty.call(usageData.whitelist.tags, node.name.toLowerCase())) {
	                                shouldRemove = true;
	                            }
	                            if (usageData.blacklist !== null &&
	                                usageData.blacklist.tags !== null &&
	                                hasOwnProperty.call(usageData.blacklist.tags, node.name.toLowerCase())) {
	                                shouldRemove = true;
	                            }
	                        }
	                        break;
	                }
	            }
	        });

	        if (shouldRemove) {
	            list.remove(item);
	        }
	    });

	    return selectorList.children.isEmpty();
	}

	Rule = function cleanRule(node, item, list, options) {
	    if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
	        list.remove(item);
	        return;
	    }

	    var usageData = options.usage;

	    if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
	        cleanUnused(node.prelude, usageData);

	        if (hasNoChildren(node.prelude)) {
	            list.remove(item);
	            return;
	        }
	    }
	};
	return Rule;
}

var TypeSelector;
var hasRequiredTypeSelector;

function requireTypeSelector () {
	if (hasRequiredTypeSelector) return TypeSelector;
	hasRequiredTypeSelector = 1;
	// remove useless universal selector
	TypeSelector = function cleanTypeSelector(node, item, list) {
	    var name = item.data.name;

	    // check it's a non-namespaced universal selector
	    if (name !== '*') {
	        return;
	    }

	    // remove when universal selector before other selectors
	    var nextType = item.next && item.next.data.type;
	    if (nextType === 'IdSelector' ||
	        nextType === 'ClassSelector' ||
	        nextType === 'AttributeSelector' ||
	        nextType === 'PseudoClassSelector' ||
	        nextType === 'PseudoElementSelector') {
	        list.remove(item);
	    }
	};
	return TypeSelector;
}

var WhiteSpace;
var hasRequiredWhiteSpace;

function requireWhiteSpace () {
	if (hasRequiredWhiteSpace) return WhiteSpace;
	hasRequiredWhiteSpace = 1;
	var { isNodeChildrenList } = requireUtils$1();

	function isSafeOperator(node) {
	    return node.type === 'Operator' && node.value !== '+' && node.value !== '-';
	}

	WhiteSpace = function cleanWhitespace(node, item, list) {
	    // remove when first or last item in sequence
	    if (item.next === null || item.prev === null) {
	        list.remove(item);
	        return;
	    }

	    // white space in stylesheet or block children
	    if (isNodeChildrenList(this.stylesheet, list) ||
	        isNodeChildrenList(this.block, list)) {
	        list.remove(item);
	        return;
	    }

	    if (item.next.data.type === 'WhiteSpace') {
	        list.remove(item);
	        return;
	    }

	    if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
	        list.remove(item);
	        return;
	    }
	};
	return WhiteSpace;
}

var clean;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean;
	hasRequiredClean = 1;
	var walk = requireLib$1().walk;
	var handlers = {
	    Atrule: requireAtrule$1(),
	    Comment: requireComment(),
	    Declaration: requireDeclaration(),
	    Raw: requireRaw(),
	    Rule: requireRule(),
	    TypeSelector: requireTypeSelector(),
	    WhiteSpace: requireWhiteSpace()
	};

	clean = function(ast, options) {
	    walk(ast, {
	        leave: function(node, item, list) {
	            if (handlers.hasOwnProperty(node.type)) {
	                handlers[node.type].call(this, node, item, list, options);
	            }
	        }
	    });
	};
	return clean;
}

var keyframes;
var hasRequiredKeyframes;

function requireKeyframes () {
	if (hasRequiredKeyframes) return keyframes;
	hasRequiredKeyframes = 1;
	keyframes = function(node) {
	    node.block.children.each(function(rule) {
	        rule.prelude.children.each(function(simpleselector) {
	            simpleselector.children.each(function(data, item) {
	                if (data.type === 'Percentage' && data.value === '100') {
	                    item.data = {
	                        type: 'TypeSelector',
	                        loc: data.loc,
	                        name: 'to'
	                    };
	                } else if (data.type === 'TypeSelector' && data.name === 'from') {
	                    item.data = {
	                        type: 'Percentage',
	                        loc: data.loc,
	                        value: '0'
	                    };
	                }
	            });
	        });
	    });
	};
	return keyframes;
}

var Atrule;
var hasRequiredAtrule;

function requireAtrule () {
	if (hasRequiredAtrule) return Atrule;
	hasRequiredAtrule = 1;
	var resolveKeyword = requireLib$1().keyword;
	var compressKeyframes = requireKeyframes();

	Atrule = function(node) {
	    // compress @keyframe selectors
	    if (resolveKeyword(node.name).basename === 'keyframes') {
	        compressKeyframes(node);
	    }
	};
	return Atrule;
}

var AttributeSelector;
var hasRequiredAttributeSelector;

function requireAttributeSelector () {
	if (hasRequiredAttributeSelector) return AttributeSelector;
	hasRequiredAttributeSelector = 1;
	// Can unquote attribute detection
	// Adopted implementation of Mathias Bynens
	// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
	var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
	var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

	function canUnquote(value) {
	    if (value === '' || value === '-') {
	        return;
	    }

	    // Escapes are valid, so replace them with a valid non-empty string
	    value = value.replace(escapesRx, 'a');

	    return !blockUnquoteRx.test(value);
	}

	AttributeSelector = function(node) {
	    var attrValue = node.value;

	    if (!attrValue || attrValue.type !== 'String') {
	        return;
	    }

	    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
	    if (canUnquote(unquotedValue)) {
	        node.value = {
	            type: 'Identifier',
	            loc: attrValue.loc,
	            name: unquotedValue
	        };
	    }
	};
	return AttributeSelector;
}

var font;
var hasRequiredFont;

function requireFont () {
	if (hasRequiredFont) return font;
	hasRequiredFont = 1;
	font = function compressFont(node) {
	    var list = node.children;

	    list.eachRight(function(node, item) {
	        if (node.type === 'Identifier') {
	            if (node.name === 'bold') {
	                item.data = {
	                    type: 'Number',
	                    loc: node.loc,
	                    value: '700'
	                };
	            } else if (node.name === 'normal') {
	                var prev = item.prev;

	                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
	                    this.remove(prev);
	                }

	                this.remove(item);
	            } else if (node.name === 'medium') {
	                var next = item.next;

	                if (!next || next.data.type !== 'Operator') {
	                    this.remove(item);
	                }
	            }
	        }
	    });

	    // remove redundant spaces
	    list.each(function(node, item) {
	        if (node.type === 'WhiteSpace') {
	            if (!item.prev || !item.next || item.next.data.type === 'WhiteSpace') {
	                this.remove(item);
	            }
	        }
	    });

	    if (list.isEmpty()) {
	        list.insert(list.createItem({
	            type: 'Identifier',
	            name: 'normal'
	        }));
	    }
	};
	return font;
}

var fontWeight;
var hasRequiredFontWeight;

function requireFontWeight () {
	if (hasRequiredFontWeight) return fontWeight;
	hasRequiredFontWeight = 1;
	fontWeight = function compressFontWeight(node) {
	    var value = node.children.head.data;

	    if (value.type === 'Identifier') {
	        switch (value.name) {
	            case 'normal':
	                node.children.head.data = {
	                    type: 'Number',
	                    loc: value.loc,
	                    value: '400'
	                };
	                break;
	            case 'bold':
	                node.children.head.data = {
	                    type: 'Number',
	                    loc: value.loc,
	                    value: '700'
	                };
	                break;
	        }
	    }
	};
	return fontWeight;
}

var background;
var hasRequiredBackground;

function requireBackground () {
	if (hasRequiredBackground) return background;
	hasRequiredBackground = 1;
	var List = requireLib$1().List;

	background = function compressBackground(node) {
	    function lastType() {
	        if (buffer.length) {
	            return buffer[buffer.length - 1].type;
	        }
	    }

	    function flush() {
	        if (lastType() === 'WhiteSpace') {
	            buffer.pop();
	        }

	        if (!buffer.length) {
	            buffer.unshift(
	                {
	                    type: 'Number',
	                    loc: null,
	                    value: '0'
	                },
	                {
	                    type: 'WhiteSpace',
	                    value: ' '
	                },
	                {
	                    type: 'Number',
	                    loc: null,
	                    value: '0'
	                }
	            );
	        }

	        newValue.push.apply(newValue, buffer);

	        buffer = [];
	    }

	    var newValue = [];
	    var buffer = [];

	    node.children.each(function(node) {
	        if (node.type === 'Operator' && node.value === ',') {
	            flush();
	            newValue.push(node);
	            return;
	        }

	        // remove defaults
	        if (node.type === 'Identifier') {
	            if (node.name === 'transparent' ||
	                node.name === 'none' ||
	                node.name === 'repeat' ||
	                node.name === 'scroll') {
	                return;
	            }
	        }

	        // don't add redundant spaces
	        if (node.type === 'WhiteSpace' && (!buffer.length || lastType() === 'WhiteSpace')) {
	            return;
	        }

	        buffer.push(node);
	    });

	    flush();
	    node.children = new List().fromArray(newValue);
	};
	return background;
}

var border;
var hasRequiredBorder;

function requireBorder () {
	if (hasRequiredBorder) return border;
	hasRequiredBorder = 1;
	function removeItemAndRedundantWhiteSpace(list, item) {
	    var prev = item.prev;
	    var next = item.next;

	    if (next !== null) {
	        if (next.data.type === 'WhiteSpace' && (prev === null || prev.data.type === 'WhiteSpace')) {
	            list.remove(next);
	        }
	    } else if (prev !== null && prev.data.type === 'WhiteSpace') {
	        list.remove(prev);
	    }

	    list.remove(item);
	}

	border = function compressBorder(node) {
	    node.children.each(function(node, item, list) {
	        if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
	            if (list.head === list.tail) {
	                // replace `none` for zero when `none` is a single term
	                item.data = {
	                    type: 'Number',
	                    loc: node.loc,
	                    value: '0'
	                };
	            } else {
	                removeItemAndRedundantWhiteSpace(list, item);
	            }
	        }
	    });
	};
	return border;
}

var Value;
var hasRequiredValue;

function requireValue () {
	if (hasRequiredValue) return Value;
	hasRequiredValue = 1;
	var resolveName = requireLib$1().property;
	var handlers = {
	    'font': requireFont(),
	    'font-weight': requireFontWeight(),
	    'background': requireBackground(),
	    'border': requireBorder(),
	    'outline': requireBorder()
	};

	Value = function compressValue(node) {
	    if (!this.declaration) {
	        return;
	    }

	    var property = resolveName(this.declaration.property);

	    if (handlers.hasOwnProperty(property.basename)) {
	        handlers[property.basename](node);
	    }
	};
	return Value;
}

var _Number = {exports: {}};

var hasRequired_Number;

function require_Number () {
	if (hasRequired_Number) return _Number.exports;
	hasRequired_Number = 1;
	var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
	var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
	var unsafeToRemovePlusSignAfter = {
	    Dimension: true,
	    Hash: true,
	    Identifier: true,
	    Number: true,
	    Raw: true,
	    UnicodeRange: true
	};

	function packNumber(value, item) {
	    // omit plus sign only if no prev or prev is safe type
	    var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type)
	        ? KEEP_PLUSSIGN
	        : OMIT_PLUSSIGN;

	    // 100 -> '100'
	    // 00100 -> '100'
	    // +100 -> '100' (only when safe, e.g. omitting plus sign for 1px+1px leads to single dimension instead of two)
	    // -100 -> '-100'
	    // 0.123 -> '.123'
	    // 0.12300 -> '.123'
	    // 0.0 -> ''
	    // 0 -> ''
	    // -0 -> '-'
	    value = String(value).replace(regexp, '$1$2$3');

	    if (value === '' || value === '-') {
	        value = '0';
	    }

	    return value;
	}

	_Number.exports = function(node, item) {
	    node.value = packNumber(node.value, item);
	};
	_Number.exports.pack = packNumber;
	return _Number.exports;
}

var Dimension;
var hasRequiredDimension;

function requireDimension () {
	if (hasRequiredDimension) return Dimension;
	hasRequiredDimension = 1;
	var packNumber = require_Number().pack;
	var MATH_FUNCTIONS = {
	    'calc': true,
	    'min': true,
	    'max': true,
	    'clamp': true
	};
	var LENGTH_UNIT = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	Dimension = function compressDimension(node, item) {
	    var value = packNumber(node.value, item);

	    node.value = value;

	    if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
	        var unit = node.unit.toLowerCase();

	        // only length values can be compressed
	        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
	            return;
	        }

	        // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
	        // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
	        if (this.declaration.property === '-ms-flex' ||
	            this.declaration.property === 'flex') {
	            return;
	        }

	        // issue #222: don't remove units inside calc
	        if (this.function && MATH_FUNCTIONS.hasOwnProperty(this.function.name)) {
	            return;
	        }

	        item.data = {
	            type: 'Number',
	            loc: node.loc,
	            value: value
	        };
	    }
	};
	return Dimension;
}

var Percentage;
var hasRequiredPercentage;

function requirePercentage () {
	if (hasRequiredPercentage) return Percentage;
	hasRequiredPercentage = 1;
	var lexer = requireLib$1().lexer;
	var packNumber = require_Number().pack;
	var blacklist = new Set([
	    // see https://github.com/jakubpawlowicz/clean-css/issues/957
	    'width',
	    'min-width',
	    'max-width',
	    'height',
	    'min-height',
	    'max-height',

	    // issue #410: Donâ€™t remove units in flex-basis value for (-ms-)flex shorthand
	    // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
	    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
	    'flex',
	    '-ms-flex'
	]);

	Percentage = function compressPercentage(node, item) {
	    node.value = packNumber(node.value, item);

	    if (node.value === '0' && this.declaration && !blacklist.has(this.declaration.property)) {
	        // try to convert a number
	        item.data = {
	            type: 'Number',
	            loc: node.loc,
	            value: node.value
	        };

	        // that's ok only when new value matches on length
	        if (!lexer.matchDeclaration(this.declaration).isType(item.data, 'length')) {
	            // otherwise rollback changes
	            item.data = node;
	        }
	    }
	};
	return Percentage;
}

var _String;
var hasRequired_String;

function require_String () {
	if (hasRequired_String) return _String;
	hasRequired_String = 1;
	_String = function(node) {
	    var value = node.value;

	    // remove escaped newlines, i.e.
	    // .a { content: "foo\
	    // bar"}
	    // ->
	    // .a { content: "foobar" }
	    value = value.replace(/\\(\r\n|\r|\n|\f)/g, '');

	    node.value = value;
	};
	return _String;
}

var Url;
var hasRequiredUrl;

function requireUrl () {
	if (hasRequiredUrl) return Url;
	hasRequiredUrl = 1;
	var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
	var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
	var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
	var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

	Url = function(node) {
	    var value = node.value;

	    if (value.type !== 'String') {
	        return;
	    }

	    var quote = value.value[0];
	    var url = value.value.substr(1, value.value.length - 2);

	    // convert `\\` to `/`
	    url = url.replace(/\\\\/g, '/');

	    // remove quotes when safe
	    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
	    if (SAFE_URL.test(url)) {
	        node.value = {
	            type: 'Raw',
	            loc: node.value.loc,
	            value: url
	        };
	    } else {
	        // use double quotes if string has no double quotes
	        // otherwise use original quotes
	        // TODO: make better quote type selection
	        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
	    }
	};
	return Url;
}

var color;
var hasRequiredColor;

function requireColor () {
	if (hasRequiredColor) return color;
	hasRequiredColor = 1;
	var lexer = requireLib$1().lexer;
	var packNumber = require_Number().pack;

	// http://www.w3.org/TR/css3-color/#svg-color
	var NAME_TO_HEX = {
	    'aliceblue': 'f0f8ff',
	    'antiquewhite': 'faebd7',
	    'aqua': '0ff',
	    'aquamarine': '7fffd4',
	    'azure': 'f0ffff',
	    'beige': 'f5f5dc',
	    'bisque': 'ffe4c4',
	    'black': '000',
	    'blanchedalmond': 'ffebcd',
	    'blue': '00f',
	    'blueviolet': '8a2be2',
	    'brown': 'a52a2a',
	    'burlywood': 'deb887',
	    'cadetblue': '5f9ea0',
	    'chartreuse': '7fff00',
	    'chocolate': 'd2691e',
	    'coral': 'ff7f50',
	    'cornflowerblue': '6495ed',
	    'cornsilk': 'fff8dc',
	    'crimson': 'dc143c',
	    'cyan': '0ff',
	    'darkblue': '00008b',
	    'darkcyan': '008b8b',
	    'darkgoldenrod': 'b8860b',
	    'darkgray': 'a9a9a9',
	    'darkgrey': 'a9a9a9',
	    'darkgreen': '006400',
	    'darkkhaki': 'bdb76b',
	    'darkmagenta': '8b008b',
	    'darkolivegreen': '556b2f',
	    'darkorange': 'ff8c00',
	    'darkorchid': '9932cc',
	    'darkred': '8b0000',
	    'darksalmon': 'e9967a',
	    'darkseagreen': '8fbc8f',
	    'darkslateblue': '483d8b',
	    'darkslategray': '2f4f4f',
	    'darkslategrey': '2f4f4f',
	    'darkturquoise': '00ced1',
	    'darkviolet': '9400d3',
	    'deeppink': 'ff1493',
	    'deepskyblue': '00bfff',
	    'dimgray': '696969',
	    'dimgrey': '696969',
	    'dodgerblue': '1e90ff',
	    'firebrick': 'b22222',
	    'floralwhite': 'fffaf0',
	    'forestgreen': '228b22',
	    'fuchsia': 'f0f',
	    'gainsboro': 'dcdcdc',
	    'ghostwhite': 'f8f8ff',
	    'gold': 'ffd700',
	    'goldenrod': 'daa520',
	    'gray': '808080',
	    'grey': '808080',
	    'green': '008000',
	    'greenyellow': 'adff2f',
	    'honeydew': 'f0fff0',
	    'hotpink': 'ff69b4',
	    'indianred': 'cd5c5c',
	    'indigo': '4b0082',
	    'ivory': 'fffff0',
	    'khaki': 'f0e68c',
	    'lavender': 'e6e6fa',
	    'lavenderblush': 'fff0f5',
	    'lawngreen': '7cfc00',
	    'lemonchiffon': 'fffacd',
	    'lightblue': 'add8e6',
	    'lightcoral': 'f08080',
	    'lightcyan': 'e0ffff',
	    'lightgoldenrodyellow': 'fafad2',
	    'lightgray': 'd3d3d3',
	    'lightgrey': 'd3d3d3',
	    'lightgreen': '90ee90',
	    'lightpink': 'ffb6c1',
	    'lightsalmon': 'ffa07a',
	    'lightseagreen': '20b2aa',
	    'lightskyblue': '87cefa',
	    'lightslategray': '789',
	    'lightslategrey': '789',
	    'lightsteelblue': 'b0c4de',
	    'lightyellow': 'ffffe0',
	    'lime': '0f0',
	    'limegreen': '32cd32',
	    'linen': 'faf0e6',
	    'magenta': 'f0f',
	    'maroon': '800000',
	    'mediumaquamarine': '66cdaa',
	    'mediumblue': '0000cd',
	    'mediumorchid': 'ba55d3',
	    'mediumpurple': '9370db',
	    'mediumseagreen': '3cb371',
	    'mediumslateblue': '7b68ee',
	    'mediumspringgreen': '00fa9a',
	    'mediumturquoise': '48d1cc',
	    'mediumvioletred': 'c71585',
	    'midnightblue': '191970',
	    'mintcream': 'f5fffa',
	    'mistyrose': 'ffe4e1',
	    'moccasin': 'ffe4b5',
	    'navajowhite': 'ffdead',
	    'navy': '000080',
	    'oldlace': 'fdf5e6',
	    'olive': '808000',
	    'olivedrab': '6b8e23',
	    'orange': 'ffa500',
	    'orangered': 'ff4500',
	    'orchid': 'da70d6',
	    'palegoldenrod': 'eee8aa',
	    'palegreen': '98fb98',
	    'paleturquoise': 'afeeee',
	    'palevioletred': 'db7093',
	    'papayawhip': 'ffefd5',
	    'peachpuff': 'ffdab9',
	    'peru': 'cd853f',
	    'pink': 'ffc0cb',
	    'plum': 'dda0dd',
	    'powderblue': 'b0e0e6',
	    'purple': '800080',
	    'rebeccapurple': '639',
	    'red': 'f00',
	    'rosybrown': 'bc8f8f',
	    'royalblue': '4169e1',
	    'saddlebrown': '8b4513',
	    'salmon': 'fa8072',
	    'sandybrown': 'f4a460',
	    'seagreen': '2e8b57',
	    'seashell': 'fff5ee',
	    'sienna': 'a0522d',
	    'silver': 'c0c0c0',
	    'skyblue': '87ceeb',
	    'slateblue': '6a5acd',
	    'slategray': '708090',
	    'slategrey': '708090',
	    'snow': 'fffafa',
	    'springgreen': '00ff7f',
	    'steelblue': '4682b4',
	    'tan': 'd2b48c',
	    'teal': '008080',
	    'thistle': 'd8bfd8',
	    'tomato': 'ff6347',
	    'turquoise': '40e0d0',
	    'violet': 'ee82ee',
	    'wheat': 'f5deb3',
	    'white': 'fff',
	    'whitesmoke': 'f5f5f5',
	    'yellow': 'ff0',
	    'yellowgreen': '9acd32'
	};

	var HEX_TO_NAME = {
	    '800000': 'maroon',
	    '800080': 'purple',
	    '808000': 'olive',
	    '808080': 'gray',
	    '00ffff': 'cyan',
	    'f0ffff': 'azure',
	    'f5f5dc': 'beige',
	    'ffe4c4': 'bisque',
	    '000000': 'black',
	    '0000ff': 'blue',
	    'a52a2a': 'brown',
	    'ff7f50': 'coral',
	    'ffd700': 'gold',
	    '008000': 'green',
	    '4b0082': 'indigo',
	    'fffff0': 'ivory',
	    'f0e68c': 'khaki',
	    '00ff00': 'lime',
	    'faf0e6': 'linen',
	    '000080': 'navy',
	    'ffa500': 'orange',
	    'da70d6': 'orchid',
	    'cd853f': 'peru',
	    'ffc0cb': 'pink',
	    'dda0dd': 'plum',
	    'f00': 'red',
	    'ff0000': 'red',
	    'fa8072': 'salmon',
	    'a0522d': 'sienna',
	    'c0c0c0': 'silver',
	    'fffafa': 'snow',
	    'd2b48c': 'tan',
	    '008080': 'teal',
	    'ff6347': 'tomato',
	    'ee82ee': 'violet',
	    'f5deb3': 'wheat',
	    'ffffff': 'white',
	    'ffff00': 'yellow'
	};

	function hueToRgb(p, q, t) {
	    if (t < 0) {
	        t += 1;
	    }
	    if (t > 1) {
	        t -= 1;
	    }
	    if (t < 1 / 6) {
	        return p + (q - p) * 6 * t;
	    }
	    if (t < 1 / 2) {
	        return q;
	    }
	    if (t < 2 / 3) {
	        return p + (q - p) * (2 / 3 - t) * 6;
	    }
	    return p;
	}

	function hslToRgb(h, s, l, a) {
	    var r;
	    var g;
	    var b;

	    if (s === 0) {
	        r = g = b = l; // achromatic
	    } else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;

	        r = hueToRgb(p, q, h + 1 / 3);
	        g = hueToRgb(p, q, h);
	        b = hueToRgb(p, q, h - 1 / 3);
	    }

	    return [
	        Math.round(r * 255),
	        Math.round(g * 255),
	        Math.round(b * 255),
	        a
	    ];
	}

	function toHex(value) {
	    value = value.toString(16);
	    return value.length === 1 ? '0' + value : value;
	}

	function parseFunctionArgs(functionArgs, count, rgb) {
	    var cursor = functionArgs.head;
	    var args = [];
	    var wasValue = false;

	    while (cursor !== null) {
	        var node = cursor.data;
	        var type = node.type;

	        switch (type) {
	            case 'Number':
	            case 'Percentage':
	                if (wasValue) {
	                    return;
	                }

	                wasValue = true;
	                args.push({
	                    type: type,
	                    value: Number(node.value)
	                });
	                break;

	            case 'Operator':
	                if (node.value === ',') {
	                    if (!wasValue) {
	                        return;
	                    }
	                    wasValue = false;
	                } else if (wasValue || node.value !== '+') {
	                    return;
	                }
	                break;

	            default:
	                // something we couldn't understand
	                return;
	        }

	        cursor = cursor.next;
	    }

	    if (args.length !== count) {
	        // invalid arguments count
	        // TODO: remove those tokens
	        return;
	    }

	    if (args.length === 4) {
	        if (args[3].type !== 'Number') {
	            // 4th argument should be a number
	            // TODO: remove those tokens
	            return;
	        }

	        args[3].type = 'Alpha';
	    }

	    if (rgb) {
	        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
	            // invalid color, numbers and percentage shouldn't be mixed
	            // TODO: remove those tokens
	            return;
	        }
	    } else {
	        if (args[0].type !== 'Number' ||
	            args[1].type !== 'Percentage' ||
	            args[2].type !== 'Percentage') {
	            // invalid color, for hsl values should be: number, percentage, percentage
	            // TODO: remove those tokens
	            return;
	        }

	        args[0].type = 'Angle';
	    }

	    return args.map(function(arg) {
	        var value = Math.max(0, arg.value);

	        switch (arg.type) {
	            case 'Number':
	                // fit value to [0..255] range
	                value = Math.min(value, 255);
	                break;

	            case 'Percentage':
	                // convert 0..100% to value in [0..255] range
	                value = Math.min(value, 100) / 100;

	                if (!rgb) {
	                    return value;
	                }

	                value = 255 * value;
	                break;

	            case 'Angle':
	                // fit value to (-360..360) range
	                return (((value % 360) + 360) % 360) / 360;

	            case 'Alpha':
	                // fit value to [0..1] range
	                return Math.min(value, 1);
	        }

	        return Math.round(value);
	    });
	}

	function compressFunction(node, item, list) {
	    var functionName = node.name;
	    var args;

	    if (functionName === 'rgba' || functionName === 'hsla') {
	        args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

	        if (!args) {
	            // something went wrong
	            return;
	        }

	        if (functionName === 'hsla') {
	            args = hslToRgb.apply(null, args);
	            node.name = 'rgba';
	        }

	        if (args[3] === 0) {
	            // try to replace `rgba(x, x, x, 0)` to `transparent`
	            // always replace `rgba(0, 0, 0, 0)` to `transparent`
	            // otherwise avoid replacement in gradients since it may break color transition
	            // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
	            var scopeFunctionName = this.function && this.function.name;
	            if ((args[0] === 0 && args[1] === 0 && args[2] === 0) ||
	                !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {

	                item.data = {
	                    type: 'Identifier',
	                    loc: node.loc,
	                    name: 'transparent'
	                };

	                return;
	            }
	        }

	        if (args[3] !== 1) {
	            // replace argument values for normalized/interpolated
	            node.children.each(function(node, item, list) {
	                if (node.type === 'Operator') {
	                    if (node.value !== ',') {
	                        list.remove(item);
	                    }
	                    return;
	                }

	                item.data = {
	                    type: 'Number',
	                    loc: node.loc,
	                    value: packNumber(args.shift(), null)
	                };
	            });

	            return;
	        }

	        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
	        functionName = 'rgb';
	    }

	    if (functionName === 'hsl') {
	        args = args || parseFunctionArgs(node.children, 3, false);

	        if (!args) {
	            // something went wrong
	            return;
	        }

	        // convert to rgb
	        args = hslToRgb.apply(null, args);
	        functionName = 'rgb';
	    }

	    if (functionName === 'rgb') {
	        args = args || parseFunctionArgs(node.children, 3, true);

	        if (!args) {
	            // something went wrong
	            return;
	        }

	        // check if color is not at the end and not followed by space
	        var next = item.next;
	        if (next && next.data.type !== 'WhiteSpace') {
	            list.insert(list.createItem({
	                type: 'WhiteSpace',
	                value: ' '
	            }), next);
	        }

	        item.data = {
	            type: 'Hash',
	            loc: node.loc,
	            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
	        };

	        compressHex(item.data, item);
	    }
	}

	function compressIdent(node, item) {
	    if (this.declaration === null) {
	        return;
	    }

	    var color = node.name.toLowerCase();

	    if (NAME_TO_HEX.hasOwnProperty(color) &&
	        lexer.matchDeclaration(this.declaration).isType(node, 'color')) {
	        var hex = NAME_TO_HEX[color];

	        if (hex.length + 1 <= color.length) {
	            // replace for shorter hex value
	            item.data = {
	                type: 'Hash',
	                loc: node.loc,
	                value: hex
	            };
	        } else {
	            // special case for consistent colors
	            if (color === 'grey') {
	                color = 'gray';
	            }

	            // just replace value for lower cased name
	            node.name = color;
	        }
	    }
	}

	function compressHex(node, item) {
	    var color = node.value.toLowerCase();

	    // #112233 -> #123
	    if (color.length === 6 &&
	        color[0] === color[1] &&
	        color[2] === color[3] &&
	        color[4] === color[5]) {
	        color = color[0] + color[2] + color[4];
	    }

	    if (HEX_TO_NAME[color]) {
	        item.data = {
	            type: 'Identifier',
	            loc: node.loc,
	            name: HEX_TO_NAME[color]
	        };
	    } else {
	        node.value = color;
	    }
	}

	color = {
	    compressFunction: compressFunction,
	    compressIdent: compressIdent,
	    compressHex: compressHex
	};
	return color;
}

var replace;
var hasRequiredReplace;

function requireReplace () {
	if (hasRequiredReplace) return replace;
	hasRequiredReplace = 1;
	var walk = requireLib$1().walk;
	var handlers = {
	    Atrule: requireAtrule(),
	    AttributeSelector: requireAttributeSelector(),
	    Value: requireValue(),
	    Dimension: requireDimension(),
	    Percentage: requirePercentage(),
	    Number: require_Number(),
	    String: require_String(),
	    Url: requireUrl(),
	    Hash: requireColor().compressHex,
	    Identifier: requireColor().compressIdent,
	    Function: requireColor().compressFunction
	};

	replace = function(ast) {
	    walk(ast, {
	        leave: function(node, item, list) {
	            if (handlers.hasOwnProperty(node.type)) {
	                handlers[node.type].call(this, node, item, list);
	            }
	        }
	    });
	};
	return replace;
}

var createDeclarationIndexer;
var hasRequiredCreateDeclarationIndexer;

function requireCreateDeclarationIndexer () {
	if (hasRequiredCreateDeclarationIndexer) return createDeclarationIndexer;
	hasRequiredCreateDeclarationIndexer = 1;
	var generate = requireLib$1().generate;

	function Index() {
	    this.seed = 0;
	    this.map = Object.create(null);
	}

	Index.prototype.resolve = function(str) {
	    var index = this.map[str];

	    if (!index) {
	        index = ++this.seed;
	        this.map[str] = index;
	    }

	    return index;
	};

	createDeclarationIndexer = function createDeclarationIndexer() {
	    var ids = new Index();

	    return function markDeclaration(node) {
	        var id = generate(node);

	        node.id = ids.resolve(id);
	        node.length = id.length;
	        node.fingerprint = null;

	        return node;
	    };
	};
	return createDeclarationIndexer;
}

var processSelector;
var hasRequiredProcessSelector;

function requireProcessSelector () {
	if (hasRequiredProcessSelector) return processSelector;
	hasRequiredProcessSelector = 1;
	var generate = requireLib$1().generate;
	var specificity = requireSpecificity();

	var nonFreezePseudoElements = {
	    'first-letter': true,
	    'first-line': true,
	    'after': true,
	    'before': true
	};
	var nonFreezePseudoClasses = {
	    'link': true,
	    'visited': true,
	    'hover': true,
	    'active': true,
	    'first-letter': true,
	    'first-line': true,
	    'after': true,
	    'before': true
	};

	processSelector = function freeze(node, usageData) {
	    var pseudos = Object.create(null);
	    var hasPseudo = false;

	    node.prelude.children.each(function(simpleSelector) {
	        var tagName = '*';
	        var scope = 0;

	        simpleSelector.children.each(function(node) {
	            switch (node.type) {
	                case 'ClassSelector':
	                    if (usageData && usageData.scopes) {
	                        var classScope = usageData.scopes[node.name] || 0;

	                        if (scope !== 0 && classScope !== scope) {
	                            throw new Error('Selector can\'t has classes from different scopes: ' + generate(simpleSelector));
	                        }

	                        scope = classScope;
	                    }
	                    break;

	                case 'PseudoClassSelector':
	                    var name = node.name.toLowerCase();

	                    if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
	                        pseudos[':' + name] = true;
	                        hasPseudo = true;
	                    }
	                    break;

	                case 'PseudoElementSelector':
	                    var name = node.name.toLowerCase();

	                    if (!nonFreezePseudoElements.hasOwnProperty(name)) {
	                        pseudos['::' + name] = true;
	                        hasPseudo = true;
	                    }
	                    break;

	                case 'TypeSelector':
	                    tagName = node.name.toLowerCase();
	                    break;

	                case 'AttributeSelector':
	                    if (node.flags) {
	                        pseudos['[' + node.flags.toLowerCase() + ']'] = true;
	                        hasPseudo = true;
	                    }
	                    break;

	                case 'WhiteSpace':
	                case 'Combinator':
	                    tagName = '*';
	                    break;
	            }
	        });

	        simpleSelector.compareMarker = specificity(simpleSelector).toString();
	        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
	        simpleSelector.id = generate(simpleSelector);

	        if (scope) {
	            simpleSelector.compareMarker += ':' + scope;
	        }

	        if (tagName !== '*') {
	            simpleSelector.compareMarker += ',' + tagName;
	        }
	    });

	    // add property to all rule nodes to avoid multiple hidden class
	    node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(',');
	};
	return processSelector;
}

var prepare;
var hasRequiredPrepare;

function requirePrepare () {
	if (hasRequiredPrepare) return prepare;
	hasRequiredPrepare = 1;
	var resolveKeyword = requireLib$1().keyword;
	var walk = requireLib$1().walk;
	var generate = requireLib$1().generate;
	var createDeclarationIndexer = requireCreateDeclarationIndexer();
	var processSelector = requireProcessSelector();

	prepare = function prepare(ast, options) {
	    var markDeclaration = createDeclarationIndexer();

	    walk(ast, {
	        visit: 'Rule',
	        enter: function processRule(node) {
	            node.block.children.each(markDeclaration);
	            processSelector(node, options.usage);
	        }
	    });

	    walk(ast, {
	        visit: 'Atrule',
	        enter: function(node) {
	            if (node.prelude) {
	                node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
	                node.prelude.id = generate(node.prelude);
	            }

	            // compare keyframe selectors by its values
	            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
	            if (resolveKeyword(node.name).basename === 'keyframes') {
	                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
	                                                       TODO: need to be checked */
	                node.block.children.each(function(rule) {
	                    rule.prelude.children.each(function(simpleselector) {
	                        simpleselector.compareMarker = simpleselector.id;
	                    });
	                });
	            }
	        }
	    });

	    return {
	        declaration: markDeclaration
	    };
	};
	return prepare;
}

var _1MergeAtrule;
var hasRequired_1MergeAtrule;

function require_1MergeAtrule () {
	if (hasRequired_1MergeAtrule) return _1MergeAtrule;
	hasRequired_1MergeAtrule = 1;
	var List = requireLib$1().List;
	var resolveKeyword = requireLib$1().keyword;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var walk = requireLib$1().walk;

	function addRuleToMap(map, item, list, single) {
	    var node = item.data;
	    var name = resolveKeyword(node.name).basename;
	    var id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

	    if (!hasOwnProperty.call(map, name)) {
	        map[name] = Object.create(null);
	    }

	    if (single) {
	        delete map[name][id];
	    }

	    if (!hasOwnProperty.call(map[name], id)) {
	        map[name][id] = new List();
	    }

	    map[name][id].append(list.remove(item));
	}

	function relocateAtrules(ast, options) {
	    var collected = Object.create(null);
	    var topInjectPoint = null;

	    ast.children.each(function(node, item, list) {
	        if (node.type === 'Atrule') {
	            var name = resolveKeyword(node.name).basename;

	            switch (name) {
	                case 'keyframes':
	                    addRuleToMap(collected, item, list, true);
	                    return;

	                case 'media':
	                    if (options.forceMediaMerge) {
	                        addRuleToMap(collected, item, list, false);
	                        return;
	                    }
	                    break;
	            }

	            if (topInjectPoint === null &&
	                name !== 'charset' &&
	                name !== 'import') {
	                topInjectPoint = item;
	            }
	        } else {
	            if (topInjectPoint === null) {
	                topInjectPoint = item;
	            }
	        }
	    });

	    for (var atrule in collected) {
	        for (var id in collected[atrule]) {
	            ast.children.insertList(
	                collected[atrule][id],
	                atrule === 'media' ? null : topInjectPoint
	            );
	        }
	    }
	}
	function isMediaRule(node) {
	    return node.type === 'Atrule' && node.name === 'media';
	}

	function processAtrule(node, item, list) {
	    if (!isMediaRule(node)) {
	        return;
	    }

	    var prev = item.prev && item.prev.data;

	    if (!prev || !isMediaRule(prev)) {
	        return;
	    }

	    // merge @media with same query
	    if (node.prelude &&
	        prev.prelude &&
	        node.prelude.id === prev.prelude.id) {
	        prev.block.children.appendList(node.block.children);
	        list.remove(item);

	        // TODO: use it when we can refer to several points in source
	        // prev.loc = {
	        //     primary: prev.loc,
	        //     merged: node.loc
	        // };
	    }
	}

	_1MergeAtrule = function rejoinAtrule(ast, options) {
	    relocateAtrules(ast, options);

	    walk(ast, {
	        visit: 'Atrule',
	        reverse: true,
	        enter: processAtrule
	    });
	};
	return _1MergeAtrule;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function isEqualSelectors(a, b) {
	    var cursor1 = a.head;
	    var cursor2 = b.head;

	    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
	        cursor1 = cursor1.next;
	        cursor2 = cursor2.next;
	    }

	    return cursor1 === null && cursor2 === null;
	}

	function isEqualDeclarations(a, b) {
	    var cursor1 = a.head;
	    var cursor2 = b.head;

	    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
	        cursor1 = cursor1.next;
	        cursor2 = cursor2.next;
	    }

	    return cursor1 === null && cursor2 === null;
	}

	function compareDeclarations(declarations1, declarations2) {
	    var result = {
	        eq: [],
	        ne1: [],
	        ne2: [],
	        ne2overrided: []
	    };

	    var fingerprints = Object.create(null);
	    var declarations2hash = Object.create(null);

	    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
	        declarations2hash[cursor.data.id] = true;
	    }

	    for (var cursor = declarations1.head; cursor; cursor = cursor.next)  {
	        var data = cursor.data;

	        if (data.fingerprint) {
	            fingerprints[data.fingerprint] = data.important;
	        }

	        if (declarations2hash[data.id]) {
	            declarations2hash[data.id] = false;
	            result.eq.push(data);
	        } else {
	            result.ne1.push(data);
	        }
	    }

	    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
	        var data = cursor.data;

	        if (declarations2hash[data.id]) {
	            // when declarations1 has an overriding declaration, this is not a difference
	            // unless no !important is used on prev and !important is used on the following
	            if (!hasOwnProperty.call(fingerprints, data.fingerprint) ||
	                (!fingerprints[data.fingerprint] && data.important)) {
	                result.ne2.push(data);
	            }

	            result.ne2overrided.push(data);
	        }
	    }

	    return result;
	}

	function addSelectors(dest, source) {
	    source.each(function(sourceData) {
	        var newStr = sourceData.id;
	        var cursor = dest.head;

	        while (cursor) {
	            var nextStr = cursor.data.id;

	            if (nextStr === newStr) {
	                return;
	            }

	            if (nextStr > newStr) {
	                break;
	            }

	            cursor = cursor.next;
	        }

	        dest.insert(dest.createItem(sourceData), cursor);
	    });

	    return dest;
	}

	// check if simpleselectors has no equal specificity and element selector
	function hasSimilarSelectors(selectors1, selectors2) {
	    var cursor1 = selectors1.head;

	    while (cursor1 !== null) {
	        var cursor2 = selectors2.head;

	        while (cursor2 !== null) {
	            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
	                return true;
	            }

	            cursor2 = cursor2.next;
	        }

	        cursor1 = cursor1.next;
	    }

	    return false;
	}

	// test node can't to be skipped
	function unsafeToSkipNode(node) {
	    switch (node.type) {
	        case 'Rule':
	            // unsafe skip ruleset with selector similarities
	            return hasSimilarSelectors(node.prelude.children, this);

	        case 'Atrule':
	            // can skip at-rules with blocks
	            if (node.block) {
	                // unsafe skip at-rule if block contains something unsafe to skip
	                return node.block.children.some(unsafeToSkipNode, this);
	            }
	            break;

	        case 'Declaration':
	            return false;
	    }

	    // unsafe by default
	    return true;
	}

	utils = {
	    isEqualSelectors: isEqualSelectors,
	    isEqualDeclarations: isEqualDeclarations,
	    compareDeclarations: compareDeclarations,
	    addSelectors: addSelectors,
	    hasSimilarSelectors: hasSimilarSelectors,
	    unsafeToSkipNode: unsafeToSkipNode
	};
	return utils;
}

var _2InitialMergeRuleset;
var hasRequired_2InitialMergeRuleset;

function require_2InitialMergeRuleset () {
	if (hasRequired_2InitialMergeRuleset) return _2InitialMergeRuleset;
	hasRequired_2InitialMergeRuleset = 1;
	var walk = requireLib$1().walk;
	var utils = requireUtils();

	function processRule(node, item, list) {
	    var selectors = node.prelude.children;
	    var declarations = node.block.children;

	    list.prevUntil(item.prev, function(prev) {
	        // skip non-ruleset node if safe
	        if (prev.type !== 'Rule') {
	            return utils.unsafeToSkipNode.call(selectors, prev);
	        }

	        var prevSelectors = prev.prelude.children;
	        var prevDeclarations = prev.block.children;

	        // try to join rulesets with equal pseudo signature
	        if (node.pseudoSignature === prev.pseudoSignature) {
	            // try to join by selectors
	            if (utils.isEqualSelectors(prevSelectors, selectors)) {
	                prevDeclarations.appendList(declarations);
	                list.remove(item);
	                return true;
	            }

	            // try to join by declarations
	            if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
	                utils.addSelectors(prevSelectors, selectors);
	                list.remove(item);
	                return true;
	            }
	        }

	        // go to prev ruleset if has no selector similarities
	        return utils.hasSimilarSelectors(selectors, prevSelectors);
	    });
	}

	// NOTE: direction should be left to right, since rulesets merge to left
	// ruleset. When direction right to left unmerged rulesets may prevent lookup
	// TODO: remove initial merge
	_2InitialMergeRuleset = function initialMergeRule(ast) {
	    walk(ast, {
	        visit: 'Rule',
	        enter: processRule
	    });
	};
	return _2InitialMergeRuleset;
}

var _3DisjoinRuleset;
var hasRequired_3DisjoinRuleset;

function require_3DisjoinRuleset () {
	if (hasRequired_3DisjoinRuleset) return _3DisjoinRuleset;
	hasRequired_3DisjoinRuleset = 1;
	var List = requireLib$1().List;
	var walk = requireLib$1().walk;

	function processRule(node, item, list) {
	    var selectors = node.prelude.children;

	    // generate new rule sets:
	    // .a, .b { color: red; }
	    // ->
	    // .a { color: red; }
	    // .b { color: red; }

	    // while there are more than 1 simple selector split for rulesets
	    while (selectors.head !== selectors.tail) {
	        var newSelectors = new List();
	        newSelectors.insert(selectors.remove(selectors.head));

	        list.insert(list.createItem({
	            type: 'Rule',
	            loc: node.loc,
	            prelude: {
	                type: 'SelectorList',
	                loc: node.prelude.loc,
	                children: newSelectors
	            },
	            block: {
	                type: 'Block',
	                loc: node.block.loc,
	                children: node.block.children.copy()
	            },
	            pseudoSignature: node.pseudoSignature
	        }), item);
	    }
	}

	_3DisjoinRuleset = function disjoinRule(ast) {
	    walk(ast, {
	        visit: 'Rule',
	        reverse: true,
	        enter: processRule
	    });
	};
	return _3DisjoinRuleset;
}

var _4RestructShorthand;
var hasRequired_4RestructShorthand;

function require_4RestructShorthand () {
	if (hasRequired_4RestructShorthand) return _4RestructShorthand;
	hasRequired_4RestructShorthand = 1;
	var List = requireLib$1().List;
	var generate = requireLib$1().generate;
	var walk = requireLib$1().walk;

	var REPLACE = 1;
	var REMOVE = 2;
	var TOP = 0;
	var RIGHT = 1;
	var BOTTOM = 2;
	var LEFT = 3;
	var SIDES = ['top', 'right', 'bottom', 'left'];
	var SIDE = {
	    'margin-top': 'top',
	    'margin-right': 'right',
	    'margin-bottom': 'bottom',
	    'margin-left': 'left',

	    'padding-top': 'top',
	    'padding-right': 'right',
	    'padding-bottom': 'bottom',
	    'padding-left': 'left',

	    'border-top-color': 'top',
	    'border-right-color': 'right',
	    'border-bottom-color': 'bottom',
	    'border-left-color': 'left',
	    'border-top-width': 'top',
	    'border-right-width': 'right',
	    'border-bottom-width': 'bottom',
	    'border-left-width': 'left',
	    'border-top-style': 'top',
	    'border-right-style': 'right',
	    'border-bottom-style': 'bottom',
	    'border-left-style': 'left'
	};
	var MAIN_PROPERTY = {
	    'margin': 'margin',
	    'margin-top': 'margin',
	    'margin-right': 'margin',
	    'margin-bottom': 'margin',
	    'margin-left': 'margin',

	    'padding': 'padding',
	    'padding-top': 'padding',
	    'padding-right': 'padding',
	    'padding-bottom': 'padding',
	    'padding-left': 'padding',

	    'border-color': 'border-color',
	    'border-top-color': 'border-color',
	    'border-right-color': 'border-color',
	    'border-bottom-color': 'border-color',
	    'border-left-color': 'border-color',
	    'border-width': 'border-width',
	    'border-top-width': 'border-width',
	    'border-right-width': 'border-width',
	    'border-bottom-width': 'border-width',
	    'border-left-width': 'border-width',
	    'border-style': 'border-style',
	    'border-top-style': 'border-style',
	    'border-right-style': 'border-style',
	    'border-bottom-style': 'border-style',
	    'border-left-style': 'border-style'
	};

	function TRBL(name) {
	    this.name = name;
	    this.loc = null;
	    this.iehack = undefined;
	    this.sides = {
	        'top': null,
	        'right': null,
	        'bottom': null,
	        'left': null
	    };
	}

	TRBL.prototype.getValueSequence = function(declaration, count) {
	    var values = [];
	    var iehack = '';
	    var hasBadValues = declaration.value.type !== 'Value' || declaration.value.children.some(function(child) {
	        var special = false;

	        switch (child.type) {
	            case 'Identifier':
	                switch (child.name) {
	                    case '\\0':
	                    case '\\9':
	                        iehack = child.name;
	                        return;

	                    case 'inherit':
	                    case 'initial':
	                    case 'unset':
	                    case 'revert':
	                        special = child.name;
	                        break;
	                }
	                break;

	            case 'Dimension':
	                switch (child.unit) {
	                    // is not supported until IE11
	                    case 'rem':

	                    // v* units is too buggy across browsers and better
	                    // don't merge values with those units
	                    case 'vw':
	                    case 'vh':
	                    case 'vmin':
	                    case 'vmax':
	                    case 'vm': // IE9 supporting "vm" instead of "vmin".
	                        special = child.unit;
	                        break;
	                }
	                break;

	            case 'Hash': // color
	            case 'Number':
	            case 'Percentage':
	                break;

	            case 'Function':
	                if (child.name === 'var') {
	                    return true;
	                }

	                special = child.name;
	                break;

	            case 'WhiteSpace':
	                return false; // ignore space

	            default:
	                return true;  // bad value
	        }

	        values.push({
	            node: child,
	            special: special,
	            important: declaration.important
	        });
	    });

	    if (hasBadValues || values.length > count) {
	        return false;
	    }

	    if (typeof this.iehack === 'string' && this.iehack !== iehack) {
	        return false;
	    }

	    this.iehack = iehack; // move outside

	    return values;
	};

	TRBL.prototype.canOverride = function(side, value) {
	    var currentValue = this.sides[side];

	    return !currentValue || (value.important && !currentValue.important);
	};

	TRBL.prototype.add = function(name, declaration) {
	    function attemptToAdd() {
	        var sides = this.sides;
	        var side = SIDE[name];

	        if (side) {
	            if (side in sides === false) {
	                return false;
	            }

	            var values = this.getValueSequence(declaration, 1);

	            if (!values || !values.length) {
	                return false;
	            }

	            // can mix only if specials are equal
	            for (var key in sides) {
	                if (sides[key] !== null && sides[key].special !== values[0].special) {
	                    return false;
	                }
	            }

	            if (!this.canOverride(side, values[0])) {
	                return true;
	            }

	            sides[side] = values[0];
	            return true;
	        } else if (name === this.name) {
	            var values = this.getValueSequence(declaration, 4);

	            if (!values || !values.length) {
	                return false;
	            }

	            switch (values.length) {
	                case 1:
	                    values[RIGHT] = values[TOP];
	                    values[BOTTOM] = values[TOP];
	                    values[LEFT] = values[TOP];
	                    break;

	                case 2:
	                    values[BOTTOM] = values[TOP];
	                    values[LEFT] = values[RIGHT];
	                    break;

	                case 3:
	                    values[LEFT] = values[RIGHT];
	                    break;
	            }

	            // can mix only if specials are equal
	            for (var i = 0; i < 4; i++) {
	                for (var key in sides) {
	                    if (sides[key] !== null && sides[key].special !== values[i].special) {
	                        return false;
	                    }
	                }
	            }

	            for (var i = 0; i < 4; i++) {
	                if (this.canOverride(SIDES[i], values[i])) {
	                    sides[SIDES[i]] = values[i];
	                }
	            }

	            return true;
	        }
	    }

	    if (!attemptToAdd.call(this)) {
	        return false;
	    }

	    // TODO: use it when we can refer to several points in source
	    // if (this.loc) {
	    //     this.loc = {
	    //         primary: this.loc,
	    //         merged: declaration.loc
	    //     };
	    // } else {
	    //     this.loc = declaration.loc;
	    // }
	    if (!this.loc) {
	        this.loc = declaration.loc;
	    }

	    return true;
	};

	TRBL.prototype.isOkToMinimize = function() {
	    var top = this.sides.top;
	    var right = this.sides.right;
	    var bottom = this.sides.bottom;
	    var left = this.sides.left;

	    if (top && right && bottom && left) {
	        var important =
	            top.important +
	            right.important +
	            bottom.important +
	            left.important;

	        return important === 0 || important === 4;
	    }

	    return false;
	};

	TRBL.prototype.getValue = function() {
	    var result = new List();
	    var sides = this.sides;
	    var values = [
	        sides.top,
	        sides.right,
	        sides.bottom,
	        sides.left
	    ];
	    var stringValues = [
	        generate(sides.top.node),
	        generate(sides.right.node),
	        generate(sides.bottom.node),
	        generate(sides.left.node)
	    ];

	    if (stringValues[LEFT] === stringValues[RIGHT]) {
	        values.pop();
	        if (stringValues[BOTTOM] === stringValues[TOP]) {
	            values.pop();
	            if (stringValues[RIGHT] === stringValues[TOP]) {
	                values.pop();
	            }
	        }
	    }

	    for (var i = 0; i < values.length; i++) {
	        if (i) {
	            result.appendData({ type: 'WhiteSpace', value: ' ' });
	        }

	        result.appendData(values[i].node);
	    }

	    if (this.iehack) {
	        result.appendData({ type: 'WhiteSpace', value: ' ' });
	        result.appendData({
	            type: 'Identifier',
	            loc: null,
	            name: this.iehack
	        });
	    }

	    return {
	        type: 'Value',
	        loc: null,
	        children: result
	    };
	};

	TRBL.prototype.getDeclaration = function() {
	    return {
	        type: 'Declaration',
	        loc: this.loc,
	        important: this.sides.top.important,
	        property: this.name,
	        value: this.getValue()
	    };
	};

	function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
	    var declarations = rule.block.children;
	    var selector = rule.prelude.children.first().id;

	    rule.block.children.eachRight(function(declaration, item) {
	        var property = declaration.property;

	        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
	            return;
	        }

	        var key = MAIN_PROPERTY[property];
	        var shorthand;
	        var operation;

	        if (!lastShortSelector || selector === lastShortSelector) {
	            if (key in shorts) {
	                operation = REMOVE;
	                shorthand = shorts[key];
	            }
	        }

	        if (!shorthand || !shorthand.add(property, declaration)) {
	            operation = REPLACE;
	            shorthand = new TRBL(key);

	            // if can't parse value ignore it and break shorthand children
	            if (!shorthand.add(property, declaration)) {
	                lastShortSelector = null;
	                return;
	            }
	        }

	        shorts[key] = shorthand;
	        shortDeclarations.push({
	            operation: operation,
	            block: declarations,
	            item: item,
	            shorthand: shorthand
	        });

	        lastShortSelector = selector;
	    });

	    return lastShortSelector;
	}

	function processShorthands(shortDeclarations, markDeclaration) {
	    shortDeclarations.forEach(function(item) {
	        var shorthand = item.shorthand;

	        if (!shorthand.isOkToMinimize()) {
	            return;
	        }

	        if (item.operation === REPLACE) {
	            item.item.data = markDeclaration(shorthand.getDeclaration());
	        } else {
	            item.block.remove(item.item);
	        }
	    });
	}

	_4RestructShorthand = function restructBlock(ast, indexer) {
	    var stylesheetMap = {};
	    var shortDeclarations = [];

	    walk(ast, {
	        visit: 'Rule',
	        reverse: true,
	        enter: function(node) {
	            var stylesheet = this.block || this.stylesheet;
	            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
	            var ruleMap;
	            var shorts;

	            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
	                ruleMap = {
	                    lastShortSelector: null
	                };
	                stylesheetMap[stylesheet.id] = ruleMap;
	            } else {
	                ruleMap = stylesheetMap[stylesheet.id];
	            }

	            if (ruleMap.hasOwnProperty(ruleId)) {
	                shorts = ruleMap[ruleId];
	            } else {
	                shorts = {};
	                ruleMap[ruleId] = shorts;
	            }

	            ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
	        }
	    });

	    processShorthands(shortDeclarations, indexer.declaration);
	};
	return _4RestructShorthand;
}

var _6RestructBlock;
var hasRequired_6RestructBlock;

function require_6RestructBlock () {
	if (hasRequired_6RestructBlock) return _6RestructBlock;
	hasRequired_6RestructBlock = 1;
	var resolveProperty = requireLib$1().property;
	var resolveKeyword = requireLib$1().keyword;
	var walk = requireLib$1().walk;
	var generate = requireLib$1().generate;
	var fingerprintId = 1;
	var dontRestructure = {
	    'src': 1 // https://github.com/afelix/csso/issues/50
	};

	var DONT_MIX_VALUE = {
	    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
	    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
	    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
	    'text-align': /^(start|end|match-parent|justify-all)$/i
	};

	var SAFE_VALUES = {
	    cursor: [
	        'auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help',
	        'n-resize', 'e-resize', 's-resize', 'w-resize',
	        'ne-resize', 'nw-resize', 'se-resize', 'sw-resize',
	        'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll',
	        'col-resize', 'row-resize'
	    ],
	    overflow: [
	        'hidden', 'visible', 'scroll', 'auto'
	    ],
	    position: [
	        'static', 'relative', 'absolute', 'fixed'
	    ]
	};

	var NEEDLESS_TABLE = {
	    'border-width': ['border'],
	    'border-style': ['border'],
	    'border-color': ['border'],
	    'border-top': ['border'],
	    'border-right': ['border'],
	    'border-bottom': ['border'],
	    'border-left': ['border'],
	    'border-top-width': ['border-top', 'border-width', 'border'],
	    'border-right-width': ['border-right', 'border-width', 'border'],
	    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
	    'border-left-width': ['border-left', 'border-width', 'border'],
	    'border-top-style': ['border-top', 'border-style', 'border'],
	    'border-right-style': ['border-right', 'border-style', 'border'],
	    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
	    'border-left-style': ['border-left', 'border-style', 'border'],
	    'border-top-color': ['border-top', 'border-color', 'border'],
	    'border-right-color': ['border-right', 'border-color', 'border'],
	    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
	    'border-left-color': ['border-left', 'border-color', 'border'],
	    'margin-top': ['margin'],
	    'margin-right': ['margin'],
	    'margin-bottom': ['margin'],
	    'margin-left': ['margin'],
	    'padding-top': ['padding'],
	    'padding-right': ['padding'],
	    'padding-bottom': ['padding'],
	    'padding-left': ['padding'],
	    'font-style': ['font'],
	    'font-variant': ['font'],
	    'font-weight': ['font'],
	    'font-size': ['font'],
	    'font-family': ['font'],
	    'list-style-type': ['list-style'],
	    'list-style-position': ['list-style'],
	    'list-style-image': ['list-style']
	};

	function getPropertyFingerprint(propertyName, declaration, fingerprints) {
	    var realName = resolveProperty(propertyName).basename;

	    if (realName === 'background') {
	        return propertyName + ':' + generate(declaration.value);
	    }

	    var declarationId = declaration.id;
	    var fingerprint = fingerprints[declarationId];

	    if (!fingerprint) {
	        switch (declaration.value.type) {
	            case 'Value':
	                var vendorId = '';
	                var iehack = '';
	                var special = {};
	                var raw = false;

	                declaration.value.children.each(function walk(node) {
	                    switch (node.type) {
	                        case 'Value':
	                        case 'Brackets':
	                        case 'Parentheses':
	                            node.children.each(walk);
	                            break;

	                        case 'Raw':
	                            raw = true;
	                            break;

	                        case 'Identifier':
	                            var name = node.name;

	                            if (!vendorId) {
	                                vendorId = resolveKeyword(name).vendor;
	                            }

	                            if (/\\[09]/.test(name)) {
	                                iehack = RegExp.lastMatch;
	                            }

	                            if (SAFE_VALUES.hasOwnProperty(realName)) {
	                                if (SAFE_VALUES[realName].indexOf(name) === -1) {
	                                    special[name] = true;
	                                }
	                            } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
	                                if (DONT_MIX_VALUE[realName].test(name)) {
	                                    special[name] = true;
	                                }
	                            }

	                            break;

	                        case 'Function':
	                            var name = node.name;

	                            if (!vendorId) {
	                                vendorId = resolveKeyword(name).vendor;
	                            }

	                            if (name === 'rect') {
	                                // there are 2 forms of rect:
	                                //   rect(<top>, <right>, <bottom>, <left>) - standart
	                                //   rect(<top> <right> <bottom> <left>) â€“ backwards compatible syntax
	                                // only the same form values can be merged
	                                var hasComma = node.children.some(function(node) {
	                                    return node.type === 'Operator' && node.value === ',';
	                                });
	                                if (!hasComma) {
	                                    name = 'rect-backward';
	                                }
	                            }

	                            special[name + '()'] = true;

	                            // check nested tokens too
	                            node.children.each(walk);

	                            break;

	                        case 'Dimension':
	                            var unit = node.unit;

	                            if (/\\[09]/.test(unit)) {
	                                iehack = RegExp.lastMatch;
	                            }

	                            switch (unit) {
	                                // is not supported until IE11
	                                case 'rem':

	                                // v* units is too buggy across browsers and better
	                                // don't merge values with those units
	                                case 'vw':
	                                case 'vh':
	                                case 'vmin':
	                                case 'vmax':
	                                case 'vm': // IE9 supporting "vm" instead of "vmin".
	                                    special[unit] = true;
	                                    break;
	                            }
	                            break;
	                    }
	                });

	                fingerprint = raw
	                    ? '!' + fingerprintId++
	                    : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
	                break;

	            case 'Raw':
	                fingerprint = '!' + declaration.value.value;
	                break;

	            default:
	                fingerprint = generate(declaration.value);
	        }

	        fingerprints[declarationId] = fingerprint;
	    }

	    return propertyName + fingerprint;
	}

	function needless(props, declaration, fingerprints) {
	    var property = resolveProperty(declaration.property);

	    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
	        var table = NEEDLESS_TABLE[property.basename];

	        for (var i = 0; i < table.length; i++) {
	            var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
	            var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

	            if (prev && (!declaration.important || prev.item.data.important)) {
	                return prev;
	            }
	        }
	    }
	}

	function processRule(rule, item, list, props, fingerprints) {
	    var declarations = rule.block.children;

	    declarations.eachRight(function(declaration, declarationItem) {
	        var property = declaration.property;
	        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
	        var prev = props[fingerprint];

	        if (prev && !dontRestructure.hasOwnProperty(property)) {
	            if (declaration.important && !prev.item.data.important) {
	                props[fingerprint] = {
	                    block: declarations,
	                    item: declarationItem
	                };

	                prev.block.remove(prev.item);

	                // TODO: use it when we can refer to several points in source
	                // declaration.loc = {
	                //     primary: declaration.loc,
	                //     merged: prev.item.data.loc
	                // };
	            } else {
	                declarations.remove(declarationItem);

	                // TODO: use it when we can refer to several points in source
	                // prev.item.data.loc = {
	                //     primary: prev.item.data.loc,
	                //     merged: declaration.loc
	                // };
	            }
	        } else {
	            var prev = needless(props, declaration, fingerprints);

	            if (prev) {
	                declarations.remove(declarationItem);

	                // TODO: use it when we can refer to several points in source
	                // prev.item.data.loc = {
	                //     primary: prev.item.data.loc,
	                //     merged: declaration.loc
	                // };
	            } else {
	                declaration.fingerprint = fingerprint;

	                props[fingerprint] = {
	                    block: declarations,
	                    item: declarationItem
	                };
	            }
	        }
	    });

	    if (declarations.isEmpty()) {
	        list.remove(item);
	    }
	}

	_6RestructBlock = function restructBlock(ast) {
	    var stylesheetMap = {};
	    var fingerprints = Object.create(null);

	    walk(ast, {
	        visit: 'Rule',
	        reverse: true,
	        enter: function(node, item, list) {
	            var stylesheet = this.block || this.stylesheet;
	            var ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first().id;
	            var ruleMap;
	            var props;

	            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
	                ruleMap = {};
	                stylesheetMap[stylesheet.id] = ruleMap;
	            } else {
	                ruleMap = stylesheetMap[stylesheet.id];
	            }

	            if (ruleMap.hasOwnProperty(ruleId)) {
	                props = ruleMap[ruleId];
	            } else {
	                props = {};
	                ruleMap[ruleId] = props;
	            }

	            processRule.call(this, node, item, list, props, fingerprints);
	        }
	    });
	};
	return _6RestructBlock;
}

var _7MergeRuleset;
var hasRequired_7MergeRuleset;

function require_7MergeRuleset () {
	if (hasRequired_7MergeRuleset) return _7MergeRuleset;
	hasRequired_7MergeRuleset = 1;
	var walk = requireLib$1().walk;
	var utils = requireUtils();

	/*
	    At this step all rules has single simple selector. We try to join by equal
	    declaration blocks to first rule, e.g.

	    .a { color: red }
	    b { ... }
	    .b { color: red }
	    ->
	    .a, .b { color: red }
	    b { ... }
	*/

	function processRule(node, item, list) {
	    var selectors = node.prelude.children;
	    var declarations = node.block.children;
	    var nodeCompareMarker = selectors.first().compareMarker;
	    var skippedCompareMarkers = {};

	    list.nextUntil(item.next, function(next, nextItem) {
	        // skip non-ruleset node if safe
	        if (next.type !== 'Rule') {
	            return utils.unsafeToSkipNode.call(selectors, next);
	        }

	        if (node.pseudoSignature !== next.pseudoSignature) {
	            return true;
	        }

	        var nextFirstSelector = next.prelude.children.head;
	        var nextDeclarations = next.block.children;
	        var nextCompareMarker = nextFirstSelector.data.compareMarker;

	        // if next ruleset has same marked as one of skipped then stop joining
	        if (nextCompareMarker in skippedCompareMarkers) {
	            return true;
	        }

	        // try to join by selectors
	        if (selectors.head === selectors.tail) {
	            if (selectors.first().id === nextFirstSelector.data.id) {
	                declarations.appendList(nextDeclarations);
	                list.remove(nextItem);
	                return;
	            }
	        }

	        // try to join by properties
	        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
	            var nextStr = nextFirstSelector.data.id;

	            selectors.some(function(data, item) {
	                var curStr = data.id;

	                if (nextStr < curStr) {
	                    selectors.insert(nextFirstSelector, item);
	                    return true;
	                }

	                if (!item.next) {
	                    selectors.insert(nextFirstSelector);
	                    return true;
	                }
	            });

	            list.remove(nextItem);
	            return;
	        }

	        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
	        if (nextCompareMarker === nodeCompareMarker) {
	            return true;
	        }

	        skippedCompareMarkers[nextCompareMarker] = true;
	    });
	}

	_7MergeRuleset = function mergeRule(ast) {
	    walk(ast, {
	        visit: 'Rule',
	        enter: processRule
	    });
	};
	return _7MergeRuleset;
}

var _8RestructRuleset;
var hasRequired_8RestructRuleset;

function require_8RestructRuleset () {
	if (hasRequired_8RestructRuleset) return _8RestructRuleset;
	hasRequired_8RestructRuleset = 1;
	var List = requireLib$1().List;
	var walk = requireLib$1().walk;
	var utils = requireUtils();

	function calcSelectorLength(list) {
	    var length = 0;

	    list.each(function(data) {
	        length += data.id.length + 1;
	    });

	    return length - 1;
	}

	function calcDeclarationsLength(tokens) {
	    var length = 0;

	    for (var i = 0; i < tokens.length; i++) {
	        length += tokens[i].length;
	    }

	    return (
	        length +          // declarations
	        tokens.length - 1 // delimeters
	    );
	}

	function processRule(node, item, list) {
	    var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
	    var selectors = node.prelude.children;
	    var block = node.block;
	    var disallowDownMarkers = Object.create(null);
	    var allowMergeUp = true;
	    var allowMergeDown = true;

	    list.prevUntil(item.prev, function(prev, prevItem) {
	        var prevBlock = prev.block;
	        var prevType = prev.type;

	        if (prevType !== 'Rule') {
	            var unsafe = utils.unsafeToSkipNode.call(selectors, prev);

	            if (!unsafe && prevType === 'Atrule' && prevBlock) {
	                walk(prevBlock, {
	                    visit: 'Rule',
	                    enter: function(node) {
	                        node.prelude.children.each(function(data) {
	                            disallowDownMarkers[data.compareMarker] = true;
	                        });
	                    }
	                });
	            }

	            return unsafe;
	        }

	        var prevSelectors = prev.prelude.children;

	        if (node.pseudoSignature !== prev.pseudoSignature) {
	            return true;
	        }

	        allowMergeDown = !prevSelectors.some(function(selector) {
	            return selector.compareMarker in disallowDownMarkers;
	        });

	        // try prev ruleset if simpleselectors has no equal specifity and element selector
	        if (!allowMergeDown && !allowMergeUp) {
	            return true;
	        }

	        // try to join by selectors
	        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
	            prevBlock.children.appendList(block.children);
	            list.remove(item);
	            return true;
	        }

	        // try to join by properties
	        var diff = utils.compareDeclarations(block.children, prevBlock.children);

	        // console.log(diff.eq, diff.ne1, diff.ne2);

	        if (diff.eq.length) {
	            if (!diff.ne1.length && !diff.ne2.length) {
	                // equal blocks
	                if (allowMergeDown) {
	                    utils.addSelectors(selectors, prevSelectors);
	                    list.remove(prevItem);
	                }

	                return true;
	            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
	                                              TODO: need to be checked */

	                if (diff.ne1.length && !diff.ne2.length) {
	                    // prevBlock is subset block
	                    var selectorLength = calcSelectorLength(selectors);
	                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	                    if (allowMergeUp && selectorLength < blockLength) {
	                        utils.addSelectors(prevSelectors, selectors);
	                        block.children = new List().fromArray(diff.ne1);
	                    }
	                } else if (!diff.ne1.length && diff.ne2.length) {
	                    // node is subset of prevBlock
	                    var selectorLength = calcSelectorLength(prevSelectors);
	                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	                    if (allowMergeDown && selectorLength < blockLength) {
	                        utils.addSelectors(selectors, prevSelectors);
	                        prevBlock.children = new List().fromArray(diff.ne2);
	                    }
	                } else {
	                    // diff.ne1.length && diff.ne2.length
	                    // extract equal block
	                    var newSelector = {
	                        type: 'SelectorList',
	                        loc: null,
	                        children: utils.addSelectors(prevSelectors.copy(), selectors)
	                    };
	                    var newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
	                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	                    // create new ruleset if declarations length greater than
	                    // ruleset description overhead
	                    if (blockLength >= newBlockLength) {
	                        var newItem = list.createItem({
	                            type: 'Rule',
	                            loc: null,
	                            prelude: newSelector,
	                            block: {
	                                type: 'Block',
	                                loc: null,
	                                children: new List().fromArray(diff.eq)
	                            },
	                            pseudoSignature: node.pseudoSignature
	                        });

	                        block.children = new List().fromArray(diff.ne1);
	                        prevBlock.children = new List().fromArray(diff.ne2overrided);

	                        if (allowMergeUp) {
	                            list.insert(newItem, prevItem);
	                        } else {
	                            list.insert(newItem, item);
	                        }

	                        return true;
	                    }
	                }
	            }
	        }

	        if (allowMergeUp) {
	            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
	            // await property families to find property interception correctly
	            allowMergeUp = !prevSelectors.some(function(prevSelector) {
	                return selectors.some(function(selector) {
	                    return selector.compareMarker === prevSelector.compareMarker;
	                });
	            });
	        }

	        prevSelectors.each(function(data) {
	            disallowDownMarkers[data.compareMarker] = true;
	        });
	    });
	}

	_8RestructRuleset = function restructRule(ast) {
	    walk(ast, {
	        visit: 'Rule',
	        reverse: true,
	        enter: processRule
	    });
	};
	return _8RestructRuleset;
}

var restructure;
var hasRequiredRestructure;

function requireRestructure () {
	if (hasRequiredRestructure) return restructure;
	hasRequiredRestructure = 1;
	var prepare = requirePrepare();
	var mergeAtrule = require_1MergeAtrule();
	var initialMergeRuleset = require_2InitialMergeRuleset();
	var disjoinRuleset = require_3DisjoinRuleset();
	var restructShorthand = require_4RestructShorthand();
	var restructBlock = require_6RestructBlock();
	var mergeRuleset = require_7MergeRuleset();
	var restructRuleset = require_8RestructRuleset();

	restructure = function(ast, options) {
	    // prepare ast for restructing
	    var indexer = prepare(ast, options);
	    options.logger('prepare', ast);

	    mergeAtrule(ast, options);
	    options.logger('mergeAtrule', ast);

	    initialMergeRuleset(ast);
	    options.logger('initialMergeRuleset', ast);

	    disjoinRuleset(ast);
	    options.logger('disjoinRuleset', ast);

	    restructShorthand(ast, indexer);
	    options.logger('restructShorthand', ast);

	    restructBlock(ast);
	    options.logger('restructBlock', ast);

	    mergeRuleset(ast);
	    options.logger('mergeRuleset', ast);

	    restructRuleset(ast);
	    options.logger('restructRuleset', ast);
	};
	return restructure;
}

var compress;
var hasRequiredCompress;

function requireCompress () {
	if (hasRequiredCompress) return compress;
	hasRequiredCompress = 1;
	var List = requireLib$1().List;
	var clone = requireLib$1().clone;
	var usageUtils = requireUsage();
	var clean = requireClean();
	var replace = requireReplace();
	var restructure = requireRestructure();
	var walk = requireLib$1().walk;

	function readChunk(children, specialComments) {
	    var buffer = new List();
	    var nonSpaceTokenInBuffer = false;
	    var protectedComment;

	    children.nextUntil(children.head, function(node, item, list) {
	        if (node.type === 'Comment') {
	            if (!specialComments || node.value.charAt(0) !== '!') {
	                list.remove(item);
	                return;
	            }

	            if (nonSpaceTokenInBuffer || protectedComment) {
	                return true;
	            }

	            list.remove(item);
	            protectedComment = node;
	            return;
	        }

	        if (node.type !== 'WhiteSpace') {
	            nonSpaceTokenInBuffer = true;
	        }

	        buffer.insert(list.remove(item));
	    });

	    return {
	        comment: protectedComment,
	        stylesheet: {
	            type: 'StyleSheet',
	            loc: null,
	            children: buffer
	        }
	    };
	}

	function compressChunk(ast, firstAtrulesAllowed, num, options) {
	    options.logger('Compress block #' + num, null, true);

	    var seed = 1;

	    if (ast.type === 'StyleSheet') {
	        ast.firstAtrulesAllowed = firstAtrulesAllowed;
	        ast.id = seed++;
	    }

	    walk(ast, {
	        visit: 'Atrule',
	        enter: function markScopes(node) {
	            if (node.block !== null) {
	                node.block.id = seed++;
	            }
	        }
	    });
	    options.logger('init', ast);

	    // remove redundant
	    clean(ast, options);
	    options.logger('clean', ast);

	    // replace nodes for shortened forms
	    replace(ast, options);
	    options.logger('replace', ast);

	    // structure optimisations
	    if (options.restructuring) {
	        restructure(ast, options);
	    }

	    return ast;
	}

	function getCommentsOption(options) {
	    var comments = 'comments' in options ? options.comments : 'exclamation';

	    if (typeof comments === 'boolean') {
	        comments = comments ? 'exclamation' : false;
	    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
	        comments = false;
	    }

	    return comments;
	}

	function getRestructureOption(options) {
	    if ('restructure' in options) {
	        return options.restructure;
	    }

	    return 'restructuring' in options ? options.restructuring : true;
	}

	function wrapBlock(block) {
	    return new List().appendData({
	        type: 'Rule',
	        loc: null,
	        prelude: {
	            type: 'SelectorList',
	            loc: null,
	            children: new List().appendData({
	                type: 'Selector',
	                loc: null,
	                children: new List().appendData({
	                    type: 'TypeSelector',
	                    loc: null,
	                    name: 'x'
	                })
	            })
	        },
	        block: block
	    });
	}

	compress = function compress(ast, options) {
	    ast = ast || { type: 'StyleSheet', loc: null, children: new List() };
	    options = options || {};

	    var compressOptions = {
	        logger: typeof options.logger === 'function' ? options.logger : function() {},
	        restructuring: getRestructureOption(options),
	        forceMediaMerge: Boolean(options.forceMediaMerge),
	        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
	    };
	    var specialComments = getCommentsOption(options);
	    var firstAtrulesAllowed = true;
	    var input;
	    var output = new List();
	    var chunk;
	    var chunkNum = 1;
	    var chunkChildren;

	    if (options.clone) {
	        ast = clone(ast);
	    }

	    if (ast.type === 'StyleSheet') {
	        input = ast.children;
	        ast.children = output;
	    } else {
	        input = wrapBlock(ast);
	    }

	    do {
	        chunk = readChunk(input, Boolean(specialComments));
	        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
	        chunkChildren = chunk.stylesheet.children;

	        if (chunk.comment) {
	            // add \n before comment if there is another content in output
	            if (!output.isEmpty()) {
	                output.insert(List.createItem({
	                    type: 'Raw',
	                    value: '\n'
	                }));
	            }

	            output.insert(List.createItem(chunk.comment));

	            // add \n after comment if chunk is not empty
	            if (!chunkChildren.isEmpty()) {
	                output.insert(List.createItem({
	                    type: 'Raw',
	                    value: '\n'
	                }));
	            }
	        }

	        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
	            var lastRule = chunkChildren.last();

	            if (lastRule.type !== 'Atrule' ||
	               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
	                firstAtrulesAllowed = false;
	            }
	        }

	        if (specialComments !== 'exclamation') {
	            specialComments = false;
	        }

	        output.appendList(chunkChildren);
	    } while (!input.isEmpty());

	    return {
	        ast: ast
	    };
	};
	return compress;
}

const version = "4.2.0";
const require$$2 = {
  version};

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	var csstree = requireLib$1();
	var parse = csstree.parse;
	var compress = requireCompress();
	var generate = csstree.generate;

	function debugOutput(name, options, startTime, data) {
	    if (options.debug) {
	        console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
	    }

	    return data;
	}

	function createDefaultLogger(level) {
	    var lastDebug;

	    return function logger(title, ast) {
	        var line = title;

	        if (ast) {
	            line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
	        }

	        if (level > 1 && ast) {
	            var css = generate(ast);

	            // when level 2, limit css to 256 symbols
	            if (level === 2 && css.length > 256) {
	                css = css.substr(0, 256) + '...';
	            }

	            line += '\n  ' + css + '\n';
	        }

	        console.error(line);
	        lastDebug = Date.now();
	    };
	}

	function copy(obj) {
	    var result = {};

	    for (var key in obj) {
	        result[key] = obj[key];
	    }

	    return result;
	}

	function buildCompressOptions(options) {
	    options = copy(options);

	    if (typeof options.logger !== 'function' && options.debug) {
	        options.logger = createDefaultLogger(options.debug);
	    }

	    return options;
	}

	function runHandler(ast, options, handlers) {
	    if (!Array.isArray(handlers)) {
	        handlers = [handlers];
	    }

	    handlers.forEach(function(fn) {
	        fn(ast, options);
	    });
	}

	function minify(context, source, options) {
	    options = options || {};

	    var filename = options.filename || '<unknown>';
	    var result;

	    // parse
	    var ast = debugOutput('parsing', options, Date.now(),
	        parse(source, {
	            context: context,
	            filename: filename,
	            positions: Boolean(options.sourceMap)
	        })
	    );

	    // before compress handlers
	    if (options.beforeCompress) {
	        debugOutput('beforeCompress', options, Date.now(),
	            runHandler(ast, options, options.beforeCompress)
	        );
	    }

	    // compress
	    var compressResult = debugOutput('compress', options, Date.now(),
	        compress(ast, buildCompressOptions(options))
	    );

	    // after compress handlers
	    if (options.afterCompress) {
	        debugOutput('afterCompress', options, Date.now(),
	            runHandler(compressResult, options, options.afterCompress)
	        );
	    }

	    // generate
	    if (options.sourceMap) {
	        result = debugOutput('generate(sourceMap: true)', options, Date.now(), (function() {
	            var tmp = generate(compressResult.ast, { sourceMap: true });
	            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
	            tmp.map.setSourceContent(filename, source);
	            return tmp;
	        }()));
	    } else {
	        result = debugOutput('generate', options, Date.now(), {
	            css: generate(compressResult.ast),
	            map: null
	        });
	    }

	    return result;
	}

	function minifyStylesheet(source, options) {
	    return minify('stylesheet', source, options);
	}

	function minifyBlock(source, options) {
	    return minify('declarationList', source, options);
	}

	lib = {
	    version: require$$2.version,

	    // main methods
	    minify: minifyStylesheet,
	    minifyBlock: minifyBlock,

	    // css syntax parser/walkers/generator/etc
	    syntax: Object.assign({
	        compress: compress
	    }, csstree)
	};
	return lib;
}

var hasRequiredMinifyStyles;

function requireMinifyStyles () {
	if (hasRequiredMinifyStyles) return minifyStyles;
	hasRequiredMinifyStyles = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 */

	const csso = requireLib();

	minifyStyles.type = 'visitor';
	minifyStyles.name = 'minifyStyles';
	minifyStyles.active = true;
	minifyStyles.description =
	  'minifies styles and removes unused styles based on usage data';

	/**
	 * Minifies styles (<style> element + style attribute) using CSSO
	 *
	 * @author strarsis <strarsis@gmail.com>
	 *
	 * @type {import('../lib/types').Plugin<csso.MinifyOptions & Omit<csso.CompressOptions, 'usage'> & {
	 *   usage?: boolean | {
	 *     force?: boolean,
	 *     ids?: boolean,
	 *     classes?: boolean,
	 *     tags?: boolean
	 *   }
	 * }>}
	 */
	minifyStyles.fn = (_root, { usage, ...params }) => {
	  let enableTagsUsage = true;
	  let enableIdsUsage = true;
	  let enableClassesUsage = true;
	  // force to use usage data even if it unsafe (document contains <script> or on* attributes)
	  let forceUsageDeoptimized = false;
	  if (typeof usage === 'boolean') {
	    enableTagsUsage = usage;
	    enableIdsUsage = usage;
	    enableClassesUsage = usage;
	  } else if (usage) {
	    enableTagsUsage = usage.tags == null ? true : usage.tags;
	    enableIdsUsage = usage.ids == null ? true : usage.ids;
	    enableClassesUsage = usage.classes == null ? true : usage.classes;
	    forceUsageDeoptimized = usage.force == null ? false : usage.force;
	  }
	  /**
	   * @type {Array<XastElement>}
	   */
	  const styleElements = [];
	  /**
	   * @type {Array<XastElement>}
	   */
	  const elementsWithStyleAttributes = [];
	  let deoptimized = false;
	  /**
	   * @type {Set<string>}
	   */
	  const tagsUsage = new Set();
	  /**
	   * @type {Set<string>}
	   */
	  const idsUsage = new Set();
	  /**
	   * @type {Set<string>}
	   */
	  const classesUsage = new Set();

	  return {
	    element: {
	      enter: (node) => {
	        // detect deoptimisations
	        if (node.name === 'script') {
	          deoptimized = true;
	        }
	        for (const name of Object.keys(node.attributes)) {
	          if (name.startsWith('on')) {
	            deoptimized = true;
	          }
	        }
	        // collect tags, ids and classes usage
	        tagsUsage.add(node.name);
	        if (node.attributes.id != null) {
	          idsUsage.add(node.attributes.id);
	        }
	        if (node.attributes.class != null) {
	          for (const className of node.attributes.class.split(/\s+/)) {
	            classesUsage.add(className);
	          }
	        }
	        // collect style elements or elements with style attribute
	        if (node.name === 'style' && node.children.length !== 0) {
	          styleElements.push(node);
	        } else if (node.attributes.style != null) {
	          elementsWithStyleAttributes.push(node);
	        }
	      },
	    },

	    root: {
	      exit: () => {
	        /**
	         * @type {csso.Usage}
	         */
	        const cssoUsage = {};
	        if (deoptimized === false || forceUsageDeoptimized === true) {
	          if (enableTagsUsage && tagsUsage.size !== 0) {
	            cssoUsage.tags = Array.from(tagsUsage);
	          }
	          if (enableIdsUsage && idsUsage.size !== 0) {
	            cssoUsage.ids = Array.from(idsUsage);
	          }
	          if (enableClassesUsage && classesUsage.size !== 0) {
	            cssoUsage.classes = Array.from(classesUsage);
	          }
	        }
	        // minify style elements
	        for (const node of styleElements) {
	          if (
	            node.children[0].type === 'text' ||
	            node.children[0].type === 'cdata'
	          ) {
	            const cssText = node.children[0].value;
	            const minified = csso.minify(cssText, {
	              ...params,
	              usage: cssoUsage,
	            }).css;
	            // preserve cdata if necessary
	            // TODO split cdata -> text optimisation into separate plugin
	            if (cssText.indexOf('>') >= 0 || cssText.indexOf('<') >= 0) {
	              node.children[0].type = 'cdata';
	              node.children[0].value = minified;
	            } else {
	              node.children[0].type = 'text';
	              node.children[0].value = minified;
	            }
	          }
	        }
	        // minify style attributes
	        for (const node of elementsWithStyleAttributes) {
	          // style attribute
	          const elemStyle = node.attributes.style;
	          node.attributes.style = csso.minifyBlock(elemStyle, {
	            ...params,
	          }).css;
	        }
	      },
	    },
	  };
	};
	return minifyStyles;
}

var cleanupIDs = {};

var hasRequiredCleanupIDs;

function requireCleanupIDs () {
	if (hasRequiredCleanupIDs) return cleanupIDs;
	hasRequiredCleanupIDs = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 */

	const { visitSkip } = requireXast();
	const { referencesProps } = require_collections();

	cleanupIDs.type = 'visitor';
	cleanupIDs.name = 'cleanupIDs';
	cleanupIDs.active = true;
	cleanupIDs.description = 'removes unused IDs and minifies used';

	const regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/;
	const regReferencesHref = /^#(.+?)$/;
	const regReferencesBegin = /(\w+)\./;
	const generateIDchars = [
	  'a',
	  'b',
	  'c',
	  'd',
	  'e',
	  'f',
	  'g',
	  'h',
	  'i',
	  'j',
	  'k',
	  'l',
	  'm',
	  'n',
	  'o',
	  'p',
	  'q',
	  'r',
	  's',
	  't',
	  'u',
	  'v',
	  'w',
	  'x',
	  'y',
	  'z',
	  'A',
	  'B',
	  'C',
	  'D',
	  'E',
	  'F',
	  'G',
	  'H',
	  'I',
	  'J',
	  'K',
	  'L',
	  'M',
	  'N',
	  'O',
	  'P',
	  'Q',
	  'R',
	  'S',
	  'T',
	  'U',
	  'V',
	  'W',
	  'X',
	  'Y',
	  'Z',
	];
	const maxIDindex = generateIDchars.length - 1;

	/**
	 * Check if an ID starts with any one of a list of strings.
	 *
	 * @type {(string: string, prefixes: Array<string>) => boolean}
	 */
	const hasStringPrefix = (string, prefixes) => {
	  for (const prefix of prefixes) {
	    if (string.startsWith(prefix)) {
	      return true;
	    }
	  }
	  return false;
	};

	/**
	 * Generate unique minimal ID.
	 *
	 * @type {(currentID: null | Array<number>) => Array<number>}
	 */
	const generateID = (currentID) => {
	  if (currentID == null) {
	    return [0];
	  }
	  currentID[currentID.length - 1] += 1;
	  for (let i = currentID.length - 1; i > 0; i--) {
	    if (currentID[i] > maxIDindex) {
	      currentID[i] = 0;
	      if (currentID[i - 1] !== undefined) {
	        currentID[i - 1]++;
	      }
	    }
	  }
	  if (currentID[0] > maxIDindex) {
	    currentID[0] = 0;
	    currentID.unshift(0);
	  }
	  return currentID;
	};

	/**
	 * Get string from generated ID array.
	 *
	 * @type {(arr: Array<number>, prefix: string) => string}
	 */
	const getIDstring = (arr, prefix) => {
	  return prefix + arr.map((i) => generateIDchars[i]).join('');
	};

	/**
	 * Remove unused and minify used IDs
	 * (only if there are no any <style> or <script>).
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   remove?: boolean,
	 *   minify?: boolean,
	 *   prefix?: string,
	 *   preserve?: Array<string>,
	 *   preservePrefixes?: Array<string>,
	 *   force?: boolean,
	 * }>}
	 */
	cleanupIDs.fn = (_root, params) => {
	  const {
	    remove = true,
	    minify = true,
	    prefix = '',
	    preserve = [],
	    preservePrefixes = [],
	    force = false,
	  } = params;
	  const preserveIDs = new Set(
	    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []
	  );
	  const preserveIDPrefixes = Array.isArray(preservePrefixes)
	    ? preservePrefixes
	    : preservePrefixes
	    ? [preservePrefixes]
	    : [];
	  /**
	   * @type {Map<string, XastElement>}
	   */
	  const nodeById = new Map();
	  /**
	   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}
	   */
	  const referencesById = new Map();
	  let deoptimized = false;

	  return {
	    element: {
	      enter: (node) => {
	        if (force == false) {
	          // deoptimize if style or script elements are present
	          if (
	            (node.name === 'style' || node.name === 'script') &&
	            node.children.length !== 0
	          ) {
	            deoptimized = true;
	            return;
	          }

	          // avoid removing IDs if the whole SVG consists only of defs
	          if (node.name === 'svg') {
	            let hasDefsOnly = true;
	            for (const child of node.children) {
	              if (child.type !== 'element' || child.name !== 'defs') {
	                hasDefsOnly = false;
	                break;
	              }
	            }
	            if (hasDefsOnly) {
	              return visitSkip;
	            }
	          }
	        }

	        for (const [name, value] of Object.entries(node.attributes)) {
	          if (name === 'id') {
	            // collect all ids
	            const id = value;
	            if (nodeById.has(id)) {
	              delete node.attributes.id; // remove repeated id
	            } else {
	              nodeById.set(id, node);
	            }
	          } else {
	            // collect all references
	            /**
	             * @type {null | string}
	             */
	            let id = null;
	            if (referencesProps.includes(name)) {
	              const match = value.match(regReferencesUrl);
	              if (match != null) {
	                id = match[2]; // url() reference
	              }
	            }
	            if (name === 'href' || name.endsWith(':href')) {
	              const match = value.match(regReferencesHref);
	              if (match != null) {
	                id = match[1]; // href reference
	              }
	            }
	            if (name === 'begin') {
	              const match = value.match(regReferencesBegin);
	              if (match != null) {
	                id = match[1]; // href reference
	              }
	            }
	            if (id != null) {
	              let refs = referencesById.get(id);
	              if (refs == null) {
	                refs = [];
	                referencesById.set(id, refs);
	              }
	              refs.push({ element: node, name, value });
	            }
	          }
	        }
	      },
	    },

	    root: {
	      exit: () => {
	        if (deoptimized) {
	          return;
	        }
	        /**
	         * @type {(id: string) => boolean}
	         **/
	        const isIdPreserved = (id) =>
	          preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);
	        /**
	         * @type {null | Array<number>}
	         */
	        let currentID = null;
	        for (const [id, refs] of referencesById) {
	          const node = nodeById.get(id);
	          if (node != null) {
	            // replace referenced IDs with the minified ones
	            if (minify && isIdPreserved(id) === false) {
	              /**
	               * @type {null | string}
	               */
	              let currentIDString = null;
	              do {
	                currentID = generateID(currentID);
	                currentIDString = getIDstring(currentID, prefix);
	              } while (isIdPreserved(currentIDString));
	              node.attributes.id = currentIDString;
	              for (const { element, name, value } of refs) {
	                if (value.includes('#')) {
	                  // replace id in href and url()
	                  element.attributes[name] = value.replace(
	                    `#${id}`,
	                    `#${currentIDString}`
	                  );
	                } else {
	                  // replace id in begin attribute
	                  element.attributes[name] = value.replace(
	                    `${id}.`,
	                    `${currentIDString}.`
	                  );
	                }
	              }
	            }
	            // keep referenced node
	            nodeById.delete(id);
	          }
	        }
	        // remove non-referenced IDs attributes from elements
	        if (remove) {
	          for (const [id, node] of nodeById) {
	            if (isIdPreserved(id) === false) {
	              delete node.attributes.id;
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return cleanupIDs;
}

var removeUselessDefs = {};

var hasRequiredRemoveUselessDefs;

function requireRemoveUselessDefs () {
	if (hasRequiredRemoveUselessDefs) return removeUselessDefs;
	hasRequiredRemoveUselessDefs = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 */

	const { detachNodeFromParent } = requireXast();
	const { elemsGroups } = require_collections();

	removeUselessDefs.type = 'visitor';
	removeUselessDefs.name = 'removeUselessDefs';
	removeUselessDefs.active = true;
	removeUselessDefs.description = 'removes elements in <defs> without id';

	/**
	 * Removes content of defs and properties that aren't rendered directly without ids.
	 *
	 * @author Lev Solntsev
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeUselessDefs.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'defs') {
	          /**
	           * @type {Array<XastElement>}
	           */
	          const usefulNodes = [];
	          collectUsefulNodes(node, usefulNodes);
	          if (usefulNodes.length === 0) {
	            detachNodeFromParent(node, parentNode);
	          }
	          // TODO remove in SVGO 3
	          for (const usefulNode of usefulNodes) {
	            // @ts-ignore parentNode is legacy
	            usefulNode.parentNode = node;
	          }
	          node.children = usefulNodes;
	        } else if (
	          elemsGroups.nonRendering.includes(node.name) &&
	          node.attributes.id == null
	        ) {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};

	/**
	 * @type {(node: XastElement, usefulNodes: Array<XastElement>) => void}
	 */
	const collectUsefulNodes = (node, usefulNodes) => {
	  for (const child of node.children) {
	    if (child.type === 'element') {
	      if (child.attributes.id != null || child.name === 'style') {
	        usefulNodes.push(child);
	      } else {
	        collectUsefulNodes(child, usefulNodes);
	      }
	    }
	  }
	};
	return removeUselessDefs;
}

var cleanupNumericValues = {};

var tools = {};

var hasRequiredTools;

function requireTools () {
	if (hasRequiredTools) return tools;
	hasRequiredTools = 1;

	/**
	 * @typedef {import('../types').PathDataCommand} PathDataCommand
	 */

	/**
	 * Encode plain SVG data string into Data URI string.
	 *
	 * @type {(str: string, type?: 'base64' | 'enc' | 'unenc') => string}
	 */
	tools.encodeSVGDatauri = (str, type) => {
	  var prefix = 'data:image/svg+xml';
	  if (!type || type === 'base64') {
	    // base64
	    prefix += ';base64,';
	    str = prefix + Buffer.from(str).toString('base64');
	  } else if (type === 'enc') {
	    // URI encoded
	    str = prefix + ',' + encodeURIComponent(str);
	  } else if (type === 'unenc') {
	    // unencoded
	    str = prefix + ',' + str;
	  }
	  return str;
	};

	/**
	 * Decode SVG Data URI string into plain SVG string.
	 *
	 * @type {(str: string) => string}
	 */
	tools.decodeSVGDatauri = (str) => {
	  var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
	  var match = regexp.exec(str);

	  // plain string
	  if (!match) return str;

	  var data = match[3];

	  if (match[2]) {
	    // base64
	    str = Buffer.from(data, 'base64').toString('utf8');
	  } else if (data.charAt(0) === '%') {
	    // URI encoded
	    str = decodeURIComponent(data);
	  } else if (data.charAt(0) === '<') {
	    // unencoded
	    str = data;
	  }
	  return str;
	};

	/**
	 * @typedef {{
	 *   noSpaceAfterFlags?: boolean,
	 *   leadingZero?: boolean,
	 *   negativeExtraSpace?: boolean
	 * }} CleanupOutDataParams
	 */

	/**
	 * Convert a row of numbers to an optimized string view.
	 *
	 * @example
	 * [0, -1, .5, .5] â†’ "0-1 .5.5"
	 *
	 * @type {(data: Array<number>, params: CleanupOutDataParams, command?: PathDataCommand) => string}
	 */
	tools.cleanupOutData = (data, params, command) => {
	  let str = '';
	  let delimiter;
	  /**
	   * @type {number}
	   */
	  let prev;

	  data.forEach((item, i) => {
	    // space delimiter by default
	    delimiter = ' ';

	    // no extra space in front of first number
	    if (i == 0) delimiter = '';

	    // no extra space after 'arcto' command flags(large-arc and sweep flags)
	    // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20
	    if (params.noSpaceAfterFlags && (command == 'A' || command == 'a')) {
	      var pos = i % 7;
	      if (pos == 4 || pos == 5) delimiter = '';
	    }

	    // remove floating-point numbers leading zeros
	    // 0.5 â†’ .5
	    // -0.5 â†’ -.5
	    const itemStr = params.leadingZero
	      ? removeLeadingZero(item)
	      : item.toString();

	    // no extra space in front of negative number or
	    // in front of a floating number if a previous number is floating too
	    if (
	      params.negativeExtraSpace &&
	      delimiter != '' &&
	      (item < 0 || (itemStr.charAt(0) === '.' && prev % 1 !== 0))
	    ) {
	      delimiter = '';
	    }
	    // save prev item value
	    prev = item;
	    str += delimiter + itemStr;
	  });
	  return str;
	};

	/**
	 * Remove floating-point numbers leading zero.
	 *
	 * @example
	 * 0.5 â†’ .5
	 *
	 * @example
	 * -0.5 â†’ -.5
	 *
	 * @type {(num: number) => string}
	 */
	const removeLeadingZero = (num) => {
	  var strNum = num.toString();

	  if (0 < num && num < 1 && strNum.charAt(0) === '0') {
	    strNum = strNum.slice(1);
	  } else if (-1 < num && num < 0 && strNum.charAt(1) === '0') {
	    strNum = strNum.charAt(0) + strNum.slice(2);
	  }
	  return strNum;
	};
	tools.removeLeadingZero = removeLeadingZero;
	return tools;
}

var hasRequiredCleanupNumericValues;

function requireCleanupNumericValues () {
	if (hasRequiredCleanupNumericValues) return cleanupNumericValues;
	hasRequiredCleanupNumericValues = 1;

	const { removeLeadingZero } = requireTools();

	cleanupNumericValues.name = 'cleanupNumericValues';
	cleanupNumericValues.type = 'visitor';
	cleanupNumericValues.active = true;
	cleanupNumericValues.description =
	  'rounds numeric values to the fixed precision, removes default â€˜pxâ€™ units';

	const regNumericValues =
	  /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;

	const absoluteLengths = {
	  // relative to px
	  cm: 96 / 2.54,
	  mm: 96 / 25.4,
	  in: 96,
	  pt: 4 / 3,
	  pc: 16,
	  px: 1,
	};

	/**
	 * Round numeric values to the fixed precision,
	 * remove default 'px' units.
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   floatPrecision?: number,
	 *   leadingZero?: boolean,
	 *   defaultPx?: boolean,
	 *   convertToPx?: boolean
	 * }>}
	 */
	cleanupNumericValues.fn = (_root, params) => {
	  const {
	    floatPrecision = 3,
	    leadingZero = true,
	    defaultPx = true,
	    convertToPx = true,
	  } = params;

	  return {
	    element: {
	      enter: (node) => {
	        if (node.attributes.viewBox != null) {
	          const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
	          node.attributes.viewBox = nums
	            .map((value) => {
	              const num = Number(value);
	              return Number.isNaN(num)
	                ? value
	                : Number(num.toFixed(floatPrecision));
	            })
	            .join(' ');
	        }

	        for (const [name, value] of Object.entries(node.attributes)) {
	          // The `version` attribute is a text string and cannot be rounded
	          if (name === 'version') {
	            continue;
	          }

	          const match = value.match(regNumericValues);

	          // if attribute value matches regNumericValues
	          if (match) {
	            // round it to the fixed precision
	            let num = Number(Number(match[1]).toFixed(floatPrecision));
	            /**
	             * @type {any}
	             */
	            let matchedUnit = match[3] || '';
	            /**
	             * @type{'' | keyof typeof absoluteLengths}
	             */
	            let units = matchedUnit;

	            // convert absolute values to pixels
	            if (convertToPx && units !== '' && units in absoluteLengths) {
	              const pxNum = Number(
	                (absoluteLengths[units] * Number(match[1])).toFixed(
	                  floatPrecision
	                )
	              );
	              if (pxNum.toString().length < match[0].length) {
	                num = pxNum;
	                units = 'px';
	              }
	            }

	            // and remove leading zero
	            let str;
	            if (leadingZero) {
	              str = removeLeadingZero(num);
	            } else {
	              str = num.toString();
	            }

	            // remove default 'px' units
	            if (defaultPx && units === 'px') {
	              units = '';
	            }

	            node.attributes[name] = str + units;
	          }
	        }
	      },
	    },
	  };
	};
	return cleanupNumericValues;
}

var convertColors = {};

var hasRequiredConvertColors;

function requireConvertColors () {
	if (hasRequiredConvertColors) return convertColors;
	hasRequiredConvertColors = 1;

	const collections = require_collections();

	convertColors.type = 'visitor';
	convertColors.name = 'convertColors';
	convertColors.active = true;
	convertColors.description = 'converts colors: rgb() to #rrggbb and #rrggbb to #rgb';

	const rNumber = '([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)';
	const rComma = '\\s*,\\s*';
	const regRGB = new RegExp(
	  '^rgb\\(\\s*' + rNumber + rComma + rNumber + rComma + rNumber + '\\s*\\)$'
	);
	const regHEX = /^#(([a-fA-F0-9])\2){3}$/;

	/**
	 * Convert [r, g, b] to #rrggbb.
	 *
	 * @see https://gist.github.com/983535
	 *
	 * @example
	 * rgb2hex([255, 255, 255]) // '#ffffff'
	 *
	 * @author Jed Schmidt
	 *
	 * @type {(rgb: Array<number>) => string}
	 */
	const convertRgbToHex = ([r, g, b]) => {
	  // combine the octets into a 32-bit integer as: [1][r][g][b]
	  const hexNumber =
	    // operator precedence is (+) > (<<) > (|)
	    ((((256 + // [1][0]
	      r) << // [1][r]
	      8) | // [1][r][0]
	      g) << // [1][r][g]
	      8) | // [1][r][g][0]
	    b;
	  // serialize [1][r][g][b] to a hex string, and
	  // remove the 1 to get the number with 0s intact
	  return '#' + hexNumber.toString(16).slice(1).toUpperCase();
	};

	/**
	 * Convert different colors formats in element attributes to hex.
	 *
	 * @see https://www.w3.org/TR/SVG11/types.html#DataTypeColor
	 * @see https://www.w3.org/TR/SVG11/single-page.html#types-ColorKeywords
	 *
	 * @example
	 * Convert color name keyword to long hex:
	 * fuchsia â¡ #ff00ff
	 *
	 * Convert rgb() to long hex:
	 * rgb(255, 0, 255) â¡ #ff00ff
	 * rgb(50%, 100, 100%) â¡ #7f64ff
	 *
	 * Convert long hex to short hex:
	 * #aabbcc â¡ #abc
	 *
	 * Convert hex to short name
	 * #000080 â¡ navy
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   currentColor?: boolean | string | RegExp,
	 *   names2hex?: boolean,
	 *   rgb2hex?: boolean,
	 *   shorthex?: boolean,
	 *   shortname?: boolean,
	 * }>}
	 */
	convertColors.fn = (_root, params) => {
	  const {
	    currentColor = false,
	    names2hex = true,
	    rgb2hex = true,
	    shorthex = true,
	    shortname = true,
	  } = params;

	  return {
	    element: {
	      enter: (node) => {
	        for (const [name, value] of Object.entries(node.attributes)) {
	          if (collections.colorsProps.includes(name)) {
	            let val = value;

	            // convert colors to currentColor
	            if (currentColor) {
	              let matched;
	              if (typeof currentColor === 'string') {
	                matched = val === currentColor;
	              } else if (currentColor instanceof RegExp) {
	                matched = currentColor.exec(val) != null;
	              } else {
	                matched = val !== 'none';
	              }
	              if (matched) {
	                val = 'currentColor';
	              }
	            }

	            // convert color name keyword to long hex
	            if (names2hex) {
	              const colorName = val.toLowerCase();
	              if (collections.colorsNames[colorName] != null) {
	                val = collections.colorsNames[colorName];
	              }
	            }

	            // convert rgb() to long hex
	            if (rgb2hex) {
	              let match = val.match(regRGB);
	              if (match != null) {
	                let nums = match.slice(1, 4).map((m) => {
	                  let n;
	                  if (m.indexOf('%') > -1) {
	                    n = Math.round(parseFloat(m) * 2.55);
	                  } else {
	                    n = Number(m);
	                  }
	                  return Math.max(0, Math.min(n, 255));
	                });
	                val = convertRgbToHex(nums);
	              }
	            }

	            // convert long hex to short hex
	            if (shorthex) {
	              let match = val.match(regHEX);
	              if (match != null) {
	                val = '#' + match[0][1] + match[0][3] + match[0][5];
	              }
	            }

	            // convert hex to short name
	            if (shortname) {
	              const colorName = val.toLowerCase();
	              if (collections.colorsShortNames[colorName] != null) {
	                val = collections.colorsShortNames[colorName];
	              }
	            }

	            node.attributes[name] = val;
	          }
	        }
	      },
	    },
	  };
	};
	return convertColors;
}

var removeUnknownsAndDefaults = {};

var style = {};

var hasRequiredStyle;

function requireStyle () {
	if (hasRequiredStyle) return style;
	hasRequiredStyle = 1;

	/**
	 * @typedef {import('css-tree').Rule} CsstreeRule
	 * @typedef {import('./types').Specificity} Specificity
	 * @typedef {import('./types').Stylesheet} Stylesheet
	 * @typedef {import('./types').StylesheetRule} StylesheetRule
	 * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration
	 * @typedef {import('./types').ComputedStyles} ComputedStyles
	 * @typedef {import('./types').XastRoot} XastRoot
	 * @typedef {import('./types').XastElement} XastElement
	 * @typedef {import('./types').XastParent} XastParent
	 * @typedef {import('./types').XastChild} XastChild
	 */

	const stable = requireStable();
	const csstree = requireLib$1();
	// @ts-ignore not defined in @types/csso
	const specificity = requireSpecificity();
	const { visit, matches } = requireXast();
	const {
	  attrsGroups,
	  inheritableAttrs,
	  presentationNonInheritableGroupAttrs,
	} = require_collections();

	// @ts-ignore not defined in @types/csstree
	const csstreeWalkSkip = csstree.walk.skip;

	/**
	 * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule}
	 */
	const parseRule = (ruleNode, dynamic) => {
	  let selectors;
	  let selectorsSpecificity;
	  /**
	   * @type {Array<StylesheetDeclaration>}
	   */
	  const declarations = [];
	  csstree.walk(ruleNode, (cssNode) => {
	    if (cssNode.type === 'SelectorList') {
	      // compute specificity from original node to consider pseudo classes
	      selectorsSpecificity = specificity(cssNode);
	      const newSelectorsNode = csstree.clone(cssNode);
	      csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
	        if (pseudoClassNode.type === 'PseudoClassSelector') {
	          dynamic = true;
	          list.remove(item);
	        }
	      });
	      selectors = csstree.generate(newSelectorsNode);
	      return csstreeWalkSkip;
	    }
	    if (cssNode.type === 'Declaration') {
	      declarations.push({
	        name: cssNode.property,
	        value: csstree.generate(cssNode.value),
	        important: cssNode.important === true,
	      });
	      return csstreeWalkSkip;
	    }
	  });
	  if (selectors == null || selectorsSpecificity == null) {
	    throw Error('assert');
	  }
	  return {
	    dynamic,
	    selectors,
	    specificity: selectorsSpecificity,
	    declarations,
	  };
	};

	/**
	 * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}
	 */
	const parseStylesheet = (css, dynamic) => {
	  /**
	   * @type {Array<StylesheetRule>}
	   */
	  const rules = [];
	  const ast = csstree.parse(css, {
	    parseValue: false,
	    parseAtrulePrelude: false,
	  });
	  csstree.walk(ast, (cssNode) => {
	    if (cssNode.type === 'Rule') {
	      rules.push(parseRule(cssNode, dynamic || false));
	      return csstreeWalkSkip;
	    }
	    if (cssNode.type === 'Atrule') {
	      if (cssNode.name === 'keyframes') {
	        return csstreeWalkSkip;
	      }
	      csstree.walk(cssNode, (ruleNode) => {
	        if (ruleNode.type === 'Rule') {
	          rules.push(parseRule(ruleNode, dynamic || true));
	          return csstreeWalkSkip;
	        }
	      });
	      return csstreeWalkSkip;
	    }
	  });
	  return rules;
	};

	/**
	 * @type {(css: string) => Array<StylesheetDeclaration>}
	 */
	const parseStyleDeclarations = (css) => {
	  /**
	   * @type {Array<StylesheetDeclaration>}
	   */
	  const declarations = [];
	  const ast = csstree.parse(css, {
	    context: 'declarationList',
	    parseValue: false,
	  });
	  csstree.walk(ast, (cssNode) => {
	    if (cssNode.type === 'Declaration') {
	      declarations.push({
	        name: cssNode.property,
	        value: csstree.generate(cssNode.value),
	        important: cssNode.important === true,
	      });
	    }
	  });
	  return declarations;
	};

	/**
	 * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}
	 */
	const computeOwnStyle = (stylesheet, node) => {
	  /**
	   * @type {ComputedStyles}
	   */
	  const computedStyle = {};
	  const importantStyles = new Map();

	  // collect attributes
	  for (const [name, value] of Object.entries(node.attributes)) {
	    if (attrsGroups.presentation.includes(name)) {
	      computedStyle[name] = { type: 'static', inherited: false, value };
	      importantStyles.set(name, false);
	    }
	  }

	  // collect matching rules
	  for (const { selectors, declarations, dynamic } of stylesheet.rules) {
	    if (matches(node, selectors)) {
	      for (const { name, value, important } of declarations) {
	        const computed = computedStyle[name];
	        if (computed && computed.type === 'dynamic') {
	          continue;
	        }
	        if (dynamic) {
	          computedStyle[name] = { type: 'dynamic', inherited: false };
	          continue;
	        }
	        if (
	          computed == null ||
	          important === true ||
	          importantStyles.get(name) === false
	        ) {
	          computedStyle[name] = { type: 'static', inherited: false, value };
	          importantStyles.set(name, important);
	        }
	      }
	    }
	  }

	  // collect inline styles
	  const styleDeclarations =
	    node.attributes.style == null
	      ? []
	      : parseStyleDeclarations(node.attributes.style);
	  for (const { name, value, important } of styleDeclarations) {
	    const computed = computedStyle[name];
	    if (computed && computed.type === 'dynamic') {
	      continue;
	    }
	    if (
	      computed == null ||
	      important === true ||
	      importantStyles.get(name) === false
	    ) {
	      computedStyle[name] = { type: 'static', inherited: false, value };
	      importantStyles.set(name, important);
	    }
	  }

	  return computedStyle;
	};

	/**
	 * Compares two selector specificities.
	 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
	 *
	 * @type {(a: Specificity, b: Specificity) => number}
	 */
	const compareSpecificity = (a, b) => {
	  for (var i = 0; i < 4; i += 1) {
	    if (a[i] < b[i]) {
	      return -1;
	    } else if (a[i] > b[i]) {
	      return 1;
	    }
	  }

	  return 0;
	};

	/**
	 * @type {(root: XastRoot) => Stylesheet}
	 */
	const collectStylesheet = (root) => {
	  /**
	   * @type {Array<StylesheetRule>}
	   */
	  const rules = [];
	  /**
	   * @type {Map<XastElement, XastParent>}
	   */
	  const parents = new Map();
	  visit(root, {
	    element: {
	      enter: (node, parentNode) => {
	        // store parents
	        parents.set(node, parentNode);
	        // find and parse all styles
	        if (node.name === 'style') {
	          const dynamic =
	            node.attributes.media != null && node.attributes.media !== 'all';
	          if (
	            node.attributes.type == null ||
	            node.attributes.type === '' ||
	            node.attributes.type === 'text/css'
	          ) {
	            const children = node.children;
	            for (const child of children) {
	              if (child.type === 'text' || child.type === 'cdata') {
	                rules.push(...parseStylesheet(child.value, dynamic));
	              }
	            }
	          }
	        }
	      },
	    },
	  });
	  // sort by selectors specificity
	  stable.inplace(rules, (a, b) =>
	    compareSpecificity(a.specificity, b.specificity)
	  );
	  return { rules, parents };
	};
	style.collectStylesheet = collectStylesheet;

	/**
	 * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}
	 */
	const computeStyle = (stylesheet, node) => {
	  const { parents } = stylesheet;
	  // collect inherited styles
	  const computedStyles = computeOwnStyle(stylesheet, node);
	  let parent = parents.get(node);
	  while (parent != null && parent.type !== 'root') {
	    const inheritedStyles = computeOwnStyle(stylesheet, parent);
	    for (const [name, computed] of Object.entries(inheritedStyles)) {
	      if (
	        computedStyles[name] == null &&
	        // ignore not inheritable styles
	        inheritableAttrs.includes(name) === true &&
	        presentationNonInheritableGroupAttrs.includes(name) === false
	      ) {
	        computedStyles[name] = { ...computed, inherited: true };
	      }
	    }
	    parent = parents.get(parent);
	  }
	  return computedStyles;
	};
	style.computeStyle = computeStyle;
	return style;
}

var hasRequiredRemoveUnknownsAndDefaults;

function requireRemoveUnknownsAndDefaults () {
	if (hasRequiredRemoveUnknownsAndDefaults) return removeUnknownsAndDefaults;
	hasRequiredRemoveUnknownsAndDefaults = 1;

	const { visitSkip, detachNodeFromParent } = requireXast();
	const { collectStylesheet, computeStyle } = requireStyle();
	const {
	  elems,
	  attrsGroups,
	  elemsGroups,
	  attrsGroupsDefaults,
	  presentationNonInheritableGroupAttrs,
	} = require_collections();

	removeUnknownsAndDefaults.type = 'visitor';
	removeUnknownsAndDefaults.name = 'removeUnknownsAndDefaults';
	removeUnknownsAndDefaults.active = true;
	removeUnknownsAndDefaults.description =
	  'removes unknown elements content and attributes, removes attrs with default values';

	// resolve all groups references

	/**
	 * @type {Map<string, Set<string>>}
	 */
	const allowedChildrenPerElement = new Map();
	/**
	 * @type {Map<string, Set<string>>}
	 */
	const allowedAttributesPerElement = new Map();
	/**
	 * @type {Map<string, Map<string, string>>}
	 */
	const attributesDefaultsPerElement = new Map();

	for (const [name, config] of Object.entries(elems)) {
	  /**
	   * @type {Set<string>}
	   */
	  const allowedChildren = new Set();
	  if (config.content) {
	    for (const elementName of config.content) {
	      allowedChildren.add(elementName);
	    }
	  }
	  if (config.contentGroups) {
	    for (const contentGroupName of config.contentGroups) {
	      const elemsGroup = elemsGroups[contentGroupName];
	      if (elemsGroup) {
	        for (const elementName of elemsGroup) {
	          allowedChildren.add(elementName);
	        }
	      }
	    }
	  }
	  /**
	   * @type {Set<string>}
	   */
	  const allowedAttributes = new Set();
	  if (config.attrs) {
	    for (const attrName of config.attrs) {
	      allowedAttributes.add(attrName);
	    }
	  }
	  /**
	   * @type {Map<string, string>}
	   */
	  const attributesDefaults = new Map();
	  if (config.defaults) {
	    for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
	      attributesDefaults.set(attrName, defaultValue);
	    }
	  }
	  for (const attrsGroupName of config.attrsGroups) {
	    const attrsGroup = attrsGroups[attrsGroupName];
	    if (attrsGroup) {
	      for (const attrName of attrsGroup) {
	        allowedAttributes.add(attrName);
	      }
	    }
	    const groupDefaults = attrsGroupsDefaults[attrsGroupName];
	    if (groupDefaults) {
	      for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
	        attributesDefaults.set(attrName, defaultValue);
	      }
	    }
	  }
	  allowedChildrenPerElement.set(name, allowedChildren);
	  allowedAttributesPerElement.set(name, allowedAttributes);
	  attributesDefaultsPerElement.set(name, attributesDefaults);
	}

	/**
	 * Remove unknown elements content and attributes,
	 * remove attributes with default values.
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   unknownContent?: boolean,
	 *   unknownAttrs?: boolean,
	 *   defaultAttrs?: boolean,
	 *   uselessOverrides?: boolean,
	 *   keepDataAttrs?: boolean,
	 *   keepAriaAttrs?: boolean,
	 *   keepRoleAttr?: boolean,
	 * }>}
	 */
	removeUnknownsAndDefaults.fn = (root, params) => {
	  const {
	    unknownContent = true,
	    unknownAttrs = true,
	    defaultAttrs = true,
	    uselessOverrides = true,
	    keepDataAttrs = true,
	    keepAriaAttrs = true,
	    keepRoleAttr = false,
	  } = params;
	  const stylesheet = collectStylesheet(root);

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // skip namespaced elements
	        if (node.name.includes(':')) {
	          return;
	        }
	        // skip visiting foreignObject subtree
	        if (node.name === 'foreignObject') {
	          return visitSkip;
	        }

	        // remove unknown element's content
	        if (unknownContent && parentNode.type === 'element') {
	          const allowedChildren = allowedChildrenPerElement.get(
	            parentNode.name
	          );
	          if (allowedChildren == null || allowedChildren.size === 0) {
	            // remove unknown elements
	            if (allowedChildrenPerElement.get(node.name) == null) {
	              detachNodeFromParent(node, parentNode);
	              return;
	            }
	          } else {
	            // remove not allowed children
	            if (allowedChildren.has(node.name) === false) {
	              detachNodeFromParent(node, parentNode);
	              return;
	            }
	          }
	        }

	        const allowedAttributes = allowedAttributesPerElement.get(node.name);
	        const attributesDefaults = attributesDefaultsPerElement.get(node.name);
	        const computedParentStyle =
	          parentNode.type === 'element'
	            ? computeStyle(stylesheet, parentNode)
	            : null;

	        // remove element's unknown attrs and attrs with default values
	        for (const [name, value] of Object.entries(node.attributes)) {
	          if (keepDataAttrs && name.startsWith('data-')) {
	            continue;
	          }
	          if (keepAriaAttrs && name.startsWith('aria-')) {
	            continue;
	          }
	          if (keepRoleAttr && name === 'role') {
	            continue;
	          }
	          // skip xmlns attribute
	          if (name === 'xmlns') {
	            continue;
	          }
	          // skip namespaced attributes except xml:* and xlink:*
	          if (name.includes(':')) {
	            const [prefix] = name.split(':');
	            if (prefix !== 'xml' && prefix !== 'xlink') {
	              continue;
	            }
	          }

	          if (
	            unknownAttrs &&
	            allowedAttributes &&
	            allowedAttributes.has(name) === false
	          ) {
	            delete node.attributes[name];
	          }
	          if (
	            defaultAttrs &&
	            node.attributes.id == null &&
	            attributesDefaults &&
	            attributesDefaults.get(name) === value
	          ) {
	            // keep defaults if parent has own or inherited style
	            if (
	              computedParentStyle == null ||
	              computedParentStyle[name] == null
	            ) {
	              delete node.attributes[name];
	            }
	          }
	          if (uselessOverrides && node.attributes.id == null) {
	            const style =
	              computedParentStyle == null ? null : computedParentStyle[name];
	            if (
	              presentationNonInheritableGroupAttrs.includes(name) === false &&
	              style != null &&
	              style.type === 'static' &&
	              style.value === value
	            ) {
	              delete node.attributes[name];
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return removeUnknownsAndDefaults;
}

var removeNonInheritableGroupAttrs = {};

var hasRequiredRemoveNonInheritableGroupAttrs;

function requireRemoveNonInheritableGroupAttrs () {
	if (hasRequiredRemoveNonInheritableGroupAttrs) return removeNonInheritableGroupAttrs;
	hasRequiredRemoveNonInheritableGroupAttrs = 1;

	removeNonInheritableGroupAttrs.name = 'removeNonInheritableGroupAttrs';

	removeNonInheritableGroupAttrs.type = 'perItem';

	removeNonInheritableGroupAttrs.active = true;

	removeNonInheritableGroupAttrs.description =
	  'removes non-inheritable groupâ€™s presentational attributes';

	const {
	  inheritableAttrs,
	  attrsGroups,
	  presentationNonInheritableGroupAttrs,
	} = require_collections();

	/**
	 * Remove non-inheritable group's "presentation" attributes.
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	removeNonInheritableGroupAttrs.fn = function (item) {
	  if (item.type === 'element' && item.name === 'g') {
	    for (const name of Object.keys(item.attributes)) {
	      if (
	        attrsGroups.presentation.includes(name) === true &&
	        inheritableAttrs.includes(name) === false &&
	        presentationNonInheritableGroupAttrs.includes(name) === false
	      ) {
	        delete item.attributes[name];
	      }
	    }
	  }
	};
	return removeNonInheritableGroupAttrs;
}

var removeUselessStrokeAndFill = {};

var hasRequiredRemoveUselessStrokeAndFill;

function requireRemoveUselessStrokeAndFill () {
	if (hasRequiredRemoveUselessStrokeAndFill) return removeUselessStrokeAndFill;
	hasRequiredRemoveUselessStrokeAndFill = 1;

	const { visit, visitSkip, detachNodeFromParent } = requireXast();
	const { collectStylesheet, computeStyle } = requireStyle();
	const { elemsGroups } = require_collections();

	removeUselessStrokeAndFill.type = 'visitor';
	removeUselessStrokeAndFill.name = 'removeUselessStrokeAndFill';
	removeUselessStrokeAndFill.active = true;
	removeUselessStrokeAndFill.description = 'removes useless stroke and fill attributes';

	/**
	 * Remove useless stroke and fill attrs.
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *  stroke?: boolean,
	 *  fill?: boolean,
	 *  removeNone?: boolean
	 * }>}
	 */
	removeUselessStrokeAndFill.fn = (root, params) => {
	  const {
	    stroke: removeStroke = true,
	    fill: removeFill = true,
	    removeNone = false,
	  } = params;

	  // style and script elements deoptimise this plugin
	  let hasStyleOrScript = false;
	  visit(root, {
	    element: {
	      enter: (node) => {
	        if (node.name === 'style' || node.name === 'script') {
	          hasStyleOrScript = true;
	        }
	      },
	    },
	  });
	  if (hasStyleOrScript) {
	    return null;
	  }

	  const stylesheet = collectStylesheet(root);

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // id attribute deoptimise the whole subtree
	        if (node.attributes.id != null) {
	          return visitSkip;
	        }
	        if (elemsGroups.shape.includes(node.name) == false) {
	          return;
	        }
	        const computedStyle = computeStyle(stylesheet, node);
	        const stroke = computedStyle.stroke;
	        const strokeOpacity = computedStyle['stroke-opacity'];
	        const strokeWidth = computedStyle['stroke-width'];
	        const markerEnd = computedStyle['marker-end'];
	        const fill = computedStyle.fill;
	        const fillOpacity = computedStyle['fill-opacity'];
	        const computedParentStyle =
	          parentNode.type === 'element'
	            ? computeStyle(stylesheet, parentNode)
	            : null;
	        const parentStroke =
	          computedParentStyle == null ? null : computedParentStyle.stroke;

	        // remove stroke*
	        if (removeStroke) {
	          if (
	            stroke == null ||
	            (stroke.type === 'static' && stroke.value == 'none') ||
	            (strokeOpacity != null &&
	              strokeOpacity.type === 'static' &&
	              strokeOpacity.value === '0') ||
	            (strokeWidth != null &&
	              strokeWidth.type === 'static' &&
	              strokeWidth.value === '0')
	          ) {
	            // stroke-width may affect the size of marker-end
	            // marker is not visible when stroke-width is 0
	            if (
	              (strokeWidth != null &&
	                strokeWidth.type === 'static' &&
	                strokeWidth.value === '0') ||
	              markerEnd == null
	            ) {
	              for (const name of Object.keys(node.attributes)) {
	                if (name.startsWith('stroke')) {
	                  delete node.attributes[name];
	                }
	              }
	              // set explicit none to not inherit from parent
	              if (
	                parentStroke != null &&
	                parentStroke.type === 'static' &&
	                parentStroke.value !== 'none'
	              ) {
	                node.attributes.stroke = 'none';
	              }
	            }
	          }
	        }

	        // remove fill*
	        if (removeFill) {
	          if (
	            (fill != null && fill.type === 'static' && fill.value === 'none') ||
	            (fillOpacity != null &&
	              fillOpacity.type === 'static' &&
	              fillOpacity.value === '0')
	          ) {
	            for (const name of Object.keys(node.attributes)) {
	              if (name.startsWith('fill-')) {
	                delete node.attributes[name];
	              }
	            }
	            if (
	              fill == null ||
	              (fill.type === 'static' && fill.value !== 'none')
	            ) {
	              node.attributes.fill = 'none';
	            }
	          }
	        }

	        if (removeNone) {
	          if (
	            (stroke == null || node.attributes.stroke === 'none') &&
	            ((fill != null &&
	              fill.type === 'static' &&
	              fill.value === 'none') ||
	              node.attributes.fill === 'none')
	          ) {
	            detachNodeFromParent(node, parentNode);
	          }
	        }
	      },
	    },
	  };
	};
	return removeUselessStrokeAndFill;
}

var removeViewBox = {};

var hasRequiredRemoveViewBox;

function requireRemoveViewBox () {
	if (hasRequiredRemoveViewBox) return removeViewBox;
	hasRequiredRemoveViewBox = 1;

	removeViewBox.type = 'visitor';
	removeViewBox.name = 'removeViewBox';
	removeViewBox.active = true;
	removeViewBox.description = 'removes viewBox attribute when possible';

	const viewBoxElems = ['svg', 'pattern', 'symbol'];

	/**
	 * Remove viewBox attr which coincides with a width/height box.
	 *
	 * @see https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute
	 *
	 * @example
	 * <svg width="100" height="50" viewBox="0 0 100 50">
	 *             â¬‡
	 * <svg width="100" height="50">
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeViewBox.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (
	          viewBoxElems.includes(node.name) &&
	          node.attributes.viewBox != null &&
	          node.attributes.width != null &&
	          node.attributes.height != null
	        ) {
	          // TODO remove width/height for such case instead
	          if (node.name === 'svg' && parentNode.type !== 'root') {
	            return;
	          }
	          const nums = node.attributes.viewBox.split(/[ ,]+/g);
	          if (
	            nums[0] === '0' &&
	            nums[1] === '0' &&
	            node.attributes.width.replace(/px$/, '') === nums[2] && // could use parseFloat too
	            node.attributes.height.replace(/px$/, '') === nums[3]
	          ) {
	            delete node.attributes.viewBox;
	          }
	        }
	      },
	    },
	  };
	};
	return removeViewBox;
}

var cleanupEnableBackground = {};

var hasRequiredCleanupEnableBackground;

function requireCleanupEnableBackground () {
	if (hasRequiredCleanupEnableBackground) return cleanupEnableBackground;
	hasRequiredCleanupEnableBackground = 1;

	const { visit } = requireXast();

	cleanupEnableBackground.type = 'visitor';
	cleanupEnableBackground.name = 'cleanupEnableBackground';
	cleanupEnableBackground.active = true;
	cleanupEnableBackground.description =
	  'remove or cleanup enable-background attribute when possible';

	/**
	 * Remove or cleanup enable-background attr which coincides with a width/height box.
	 *
	 * @see https://www.w3.org/TR/SVG11/filters.html#EnableBackgroundProperty
	 *
	 * @example
	 * <svg width="100" height="50" enable-background="new 0 0 100 50">
	 *             â¬‡
	 * <svg width="100" height="50">
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	cleanupEnableBackground.fn = (root) => {
	  const regEnableBackground =
	    /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;

	  let hasFilter = false;
	  visit(root, {
	    element: {
	      enter: (node) => {
	        if (node.name === 'filter') {
	          hasFilter = true;
	        }
	      },
	    },
	  });

	  return {
	    element: {
	      enter: (node) => {
	        if (node.attributes['enable-background'] == null) {
	          return;
	        }
	        if (hasFilter) {
	          if (
	            (node.name === 'svg' ||
	              node.name === 'mask' ||
	              node.name === 'pattern') &&
	            node.attributes.width != null &&
	            node.attributes.height != null
	          ) {
	            const match =
	              node.attributes['enable-background'].match(regEnableBackground);
	            if (
	              match != null &&
	              node.attributes.width === match[1] &&
	              node.attributes.height === match[3]
	            ) {
	              if (node.name === 'svg') {
	                delete node.attributes['enable-background'];
	              } else {
	                node.attributes['enable-background'] = 'new';
	              }
	            }
	          }
	        } else {
	          //we don't need 'enable-background' if we have no filters
	          delete node.attributes['enable-background'];
	        }
	      },
	    },
	  };
	};
	return cleanupEnableBackground;
}

var removeHiddenElems = {};

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;

	/**
	 * @typedef {import('./types').PathDataItem} PathDataItem
	 * @typedef {import('./types').PathDataCommand} PathDataCommand
	 */

	// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF

	const argsCountPerCommand = {
	  M: 2,
	  m: 2,
	  Z: 0,
	  z: 0,
	  L: 2,
	  l: 2,
	  H: 1,
	  h: 1,
	  V: 1,
	  v: 1,
	  C: 6,
	  c: 6,
	  S: 4,
	  s: 4,
	  Q: 4,
	  q: 4,
	  T: 2,
	  t: 2,
	  A: 7,
	  a: 7,
	};

	/**
	 * @type {(c: string) => c is PathDataCommand}
	 */
	const isCommand = (c) => {
	  return c in argsCountPerCommand;
	};

	/**
	 * @type {(c: string) => boolean}
	 */
	const isWsp = (c) => {
	  const codePoint = c.codePointAt(0);
	  return (
	    codePoint === 0x20 ||
	    codePoint === 0x9 ||
	    codePoint === 0xd ||
	    codePoint === 0xa
	  );
	};

	/**
	 * @type {(c: string) => boolean}
	 */
	const isDigit = (c) => {
	  const codePoint = c.codePointAt(0);
	  if (codePoint == null) {
	    return false;
	  }
	  return 48 <= codePoint && codePoint <= 57;
	};

	/**
	 * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState
	 */

	/**
	 * @type {(string: string, cursor: number) => [number, number | null]}
	 */
	const readNumber = (string, cursor) => {
	  let i = cursor;
	  let value = '';
	  let state = /** @type {ReadNumberState} */ ('none');
	  for (; i < string.length; i += 1) {
	    const c = string[i];
	    if (c === '+' || c === '-') {
	      if (state === 'none') {
	        state = 'sign';
	        value += c;
	        continue;
	      }
	      if (state === 'e') {
	        state = 'exponent_sign';
	        value += c;
	        continue;
	      }
	    }
	    if (isDigit(c)) {
	      if (state === 'none' || state === 'sign' || state === 'whole') {
	        state = 'whole';
	        value += c;
	        continue;
	      }
	      if (state === 'decimal_point' || state === 'decimal') {
	        state = 'decimal';
	        value += c;
	        continue;
	      }
	      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {
	        state = 'exponent';
	        value += c;
	        continue;
	      }
	    }
	    if (c === '.') {
	      if (state === 'none' || state === 'sign' || state === 'whole') {
	        state = 'decimal_point';
	        value += c;
	        continue;
	      }
	    }
	    if (c === 'E' || c == 'e') {
	      if (
	        state === 'whole' ||
	        state === 'decimal_point' ||
	        state === 'decimal'
	      ) {
	        state = 'e';
	        value += c;
	        continue;
	      }
	    }
	    break;
	  }
	  const number = Number.parseFloat(value);
	  if (Number.isNaN(number)) {
	    return [cursor, null];
	  } else {
	    // step back to delegate iteration to parent loop
	    return [i - 1, number];
	  }
	};

	/**
	 * @type {(string: string) => Array<PathDataItem>}
	 */
	const parsePathData = (string) => {
	  /**
	   * @type {Array<PathDataItem>}
	   */
	  const pathData = [];
	  /**
	   * @type {null | PathDataCommand}
	   */
	  let command = null;
	  let args = /** @type {number[]} */ ([]);
	  let argsCount = 0;
	  let canHaveComma = false;
	  let hadComma = false;
	  for (let i = 0; i < string.length; i += 1) {
	    const c = string.charAt(i);
	    if (isWsp(c)) {
	      continue;
	    }
	    // allow comma only between arguments
	    if (canHaveComma && c === ',') {
	      if (hadComma) {
	        break;
	      }
	      hadComma = true;
	      continue;
	    }
	    if (isCommand(c)) {
	      if (hadComma) {
	        return pathData;
	      }
	      if (command == null) {
	        // moveto should be leading command
	        if (c !== 'M' && c !== 'm') {
	          return pathData;
	        }
	      } else {
	        // stop if previous command arguments are not flushed
	        if (args.length !== 0) {
	          return pathData;
	        }
	      }
	      command = c;
	      args = [];
	      argsCount = argsCountPerCommand[command];
	      canHaveComma = false;
	      // flush command without arguments
	      if (argsCount === 0) {
	        pathData.push({ command, args });
	      }
	      continue;
	    }
	    // avoid parsing arguments if no command detected
	    if (command == null) {
	      return pathData;
	    }
	    // read next argument
	    let newCursor = i;
	    let number = null;
	    if (command === 'A' || command === 'a') {
	      const position = args.length;
	      if (position === 0 || position === 1) {
	        // allow only positive number without sign as first two arguments
	        if (c !== '+' && c !== '-') {
	          [newCursor, number] = readNumber(string, i);
	        }
	      }
	      if (position === 2 || position === 5 || position === 6) {
	        [newCursor, number] = readNumber(string, i);
	      }
	      if (position === 3 || position === 4) {
	        // read flags
	        if (c === '0') {
	          number = 0;
	        }
	        if (c === '1') {
	          number = 1;
	        }
	      }
	    } else {
	      [newCursor, number] = readNumber(string, i);
	    }
	    if (number == null) {
	      return pathData;
	    }
	    args.push(number);
	    canHaveComma = true;
	    hadComma = false;
	    i = newCursor;
	    // flush arguments when necessary count is reached
	    if (args.length === argsCount) {
	      pathData.push({ command, args });
	      // subsequent moveto coordinates are threated as implicit lineto commands
	      if (command === 'M') {
	        command = 'L';
	      }
	      if (command === 'm') {
	        command = 'l';
	      }
	      args = [];
	    }
	  }
	  return pathData;
	};
	path.parsePathData = parsePathData;

	/**
	 * @type {(number: number, precision?: number) => string}
	 */
	const stringifyNumber = (number, precision) => {
	  if (precision != null) {
	    const ratio = 10 ** precision;
	    number = Math.round(number * ratio) / ratio;
	  }
	  // remove zero whole from decimal number
	  return number.toString().replace(/^0\./, '.').replace(/^-0\./, '-.');
	};

	/**
	 * Elliptical arc large-arc and sweep flags are rendered with spaces
	 * because many non-browser environments are not able to parse such paths
	 *
	 * @type {(
	 *   command: string,
	 *   args: number[],
	 *   precision?: number,
	 *   disableSpaceAfterFlags?: boolean
	 * ) => string}
	 */
	const stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
	  let result = '';
	  let prev = '';
	  for (let i = 0; i < args.length; i += 1) {
	    const number = args[i];
	    const numberString = stringifyNumber(number, precision);
	    if (
	      disableSpaceAfterFlags &&
	      (command === 'A' || command === 'a') &&
	      // consider combined arcs
	      (i % 7 === 4 || i % 7 === 5)
	    ) {
	      result += numberString;
	    } else if (i === 0 || numberString.startsWith('-')) {
	      // avoid space before first and negative numbers
	      result += numberString;
	    } else if (prev.includes('.') && numberString.startsWith('.')) {
	      // remove space before decimal with zero whole
	      // only when previous number is also decimal
	      result += numberString;
	    } else {
	      result += ` ${numberString}`;
	    }
	    prev = numberString;
	  }
	  return result;
	};

	/**
	 * @typedef {{
	 *   pathData: Array<PathDataItem>;
	 *   precision?: number;
	 *   disableSpaceAfterFlags?: boolean;
	 * }} StringifyPathDataOptions
	 */

	/**
	 * @type {(options: StringifyPathDataOptions) => string}
	 */
	const stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {
	  // combine sequence of the same commands
	  let combined = [];
	  for (let i = 0; i < pathData.length; i += 1) {
	    const { command, args } = pathData[i];
	    if (i === 0) {
	      combined.push({ command, args });
	    } else {
	      /**
	       * @type {PathDataItem}
	       */
	      const last = combined[combined.length - 1];
	      // match leading moveto with following lineto
	      if (i === 1) {
	        if (command === 'L') {
	          last.command = 'M';
	        }
	        if (command === 'l') {
	          last.command = 'm';
	        }
	      }
	      if (
	        (last.command === command &&
	          last.command !== 'M' &&
	          last.command !== 'm') ||
	        // combine matching moveto and lineto sequences
	        (last.command === 'M' && command === 'L') ||
	        (last.command === 'm' && command === 'l')
	      ) {
	        last.args = [...last.args, ...args];
	      } else {
	        combined.push({ command, args });
	      }
	    }
	  }
	  let result = '';
	  for (const { command, args } of combined) {
	    result +=
	      command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
	  }
	  return result;
	};
	path.stringifyPathData = stringifyPathData;
	return path;
}

var hasRequiredRemoveHiddenElems;

function requireRemoveHiddenElems () {
	if (hasRequiredRemoveHiddenElems) return removeHiddenElems;
	hasRequiredRemoveHiddenElems = 1;

	const {
	  querySelector,
	  closestByName,
	  detachNodeFromParent,
	} = requireXast();
	const { collectStylesheet, computeStyle } = requireStyle();
	const { parsePathData } = requirePath();

	removeHiddenElems.name = 'removeHiddenElems';
	removeHiddenElems.type = 'visitor';
	removeHiddenElems.active = true;
	removeHiddenElems.description =
	  'removes hidden elements (zero sized, with absent attributes)';

	/**
	 * Remove hidden elements with disabled rendering:
	 * - display="none"
	 * - opacity="0"
	 * - circle with zero radius
	 * - ellipse with zero x-axis or y-axis radius
	 * - rectangle with zero width or height
	 * - pattern with zero width or height
	 * - image with zero width or height
	 * - path with empty data
	 * - polyline with empty points
	 * - polygon with empty points
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   isHidden: boolean,
	 *   displayNone: boolean,
	 *   opacity0: boolean,
	 *   circleR0: boolean,
	 *   ellipseRX0: boolean,
	 *   ellipseRY0: boolean,
	 *   rectWidth0: boolean,
	 *   rectHeight0: boolean,
	 *   patternWidth0: boolean,
	 *   patternHeight0: boolean,
	 *   imageWidth0: boolean,
	 *   imageHeight0: boolean,
	 *   pathEmptyD: boolean,
	 *   polylineEmptyPoints: boolean,
	 *   polygonEmptyPoints: boolean,
	 * }>}
	 */
	removeHiddenElems.fn = (root, params) => {
	  const {
	    isHidden = true,
	    displayNone = true,
	    opacity0 = true,
	    circleR0 = true,
	    ellipseRX0 = true,
	    ellipseRY0 = true,
	    rectWidth0 = true,
	    rectHeight0 = true,
	    patternWidth0 = true,
	    patternHeight0 = true,
	    imageWidth0 = true,
	    imageHeight0 = true,
	    pathEmptyD = true,
	    polylineEmptyPoints = true,
	    polygonEmptyPoints = true,
	  } = params;
	  const stylesheet = collectStylesheet(root);

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // Removes hidden elements
	        // https://www.w3schools.com/cssref/pr_class_visibility.asp
	        const computedStyle = computeStyle(stylesheet, node);
	        if (
	          isHidden &&
	          computedStyle.visibility &&
	          computedStyle.visibility.type === 'static' &&
	          computedStyle.visibility.value === 'hidden' &&
	          // keep if any descendant enables visibility
	          querySelector(node, '[visibility=visible]') == null
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // display="none"
	        //
	        // https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
	        // "A value of display: none indicates that the given element
	        // and its children shall not be rendered directly"
	        if (
	          displayNone &&
	          computedStyle.display &&
	          computedStyle.display.type === 'static' &&
	          computedStyle.display.value === 'none' &&
	          // markers with display: none still rendered
	          node.name !== 'marker'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // opacity="0"
	        //
	        // https://www.w3.org/TR/SVG11/masking.html#ObjectAndGroupOpacityProperties
	        if (
	          opacity0 &&
	          computedStyle.opacity &&
	          computedStyle.opacity.type === 'static' &&
	          computedStyle.opacity.value === '0' &&
	          // transparent element inside clipPath still affect clipped elements
	          closestByName(node, 'clipPath') == null
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Circles with zero radius
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#CircleElementRAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <circle r="0">
	        if (
	          circleR0 &&
	          node.name === 'circle' &&
	          node.children.length === 0 &&
	          node.attributes.r === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Ellipse with zero x-axis radius
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRXAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <ellipse rx="0">
	        if (
	          ellipseRX0 &&
	          node.name === 'ellipse' &&
	          node.children.length === 0 &&
	          node.attributes.rx === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Ellipse with zero y-axis radius
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRYAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <ellipse ry="0">
	        if (
	          ellipseRY0 &&
	          node.name === 'ellipse' &&
	          node.children.length === 0 &&
	          node.attributes.ry === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Rectangle with zero width
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#RectElementWidthAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <rect width="0">
	        if (
	          rectWidth0 &&
	          node.name === 'rect' &&
	          node.children.length === 0 &&
	          node.attributes.width === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Rectangle with zero height
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#RectElementHeightAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <rect height="0">
	        if (
	          rectHeight0 &&
	          rectWidth0 &&
	          node.name === 'rect' &&
	          node.children.length === 0 &&
	          node.attributes.height === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Pattern with zero width
	        //
	        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementWidthAttribute
	        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
	        //
	        // <pattern width="0">
	        if (
	          patternWidth0 &&
	          node.name === 'pattern' &&
	          node.attributes.width === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Pattern with zero height
	        //
	        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementHeightAttribute
	        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
	        //
	        // <pattern height="0">
	        if (
	          patternHeight0 &&
	          node.name === 'pattern' &&
	          node.attributes.height === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Image with zero width
	        //
	        // https://www.w3.org/TR/SVG11/struct.html#ImageElementWidthAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <image width="0">
	        if (
	          imageWidth0 &&
	          node.name === 'image' &&
	          node.attributes.width === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Image with zero height
	        //
	        // https://www.w3.org/TR/SVG11/struct.html#ImageElementHeightAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <image height="0">
	        if (
	          imageHeight0 &&
	          node.name === 'image' &&
	          node.attributes.height === '0'
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Path with empty data
	        //
	        // https://www.w3.org/TR/SVG11/paths.html#DAttribute
	        //
	        // <path d=""/>
	        if (pathEmptyD && node.name === 'path') {
	          if (node.attributes.d == null) {
	            detachNodeFromParent(node, parentNode);
	            return;
	          }
	          const pathData = parsePathData(node.attributes.d);
	          if (pathData.length === 0) {
	            detachNodeFromParent(node, parentNode);
	            return;
	          }
	          // keep single point paths for markers
	          if (
	            pathData.length === 1 &&
	            computedStyle['marker-start'] == null &&
	            computedStyle['marker-end'] == null
	          ) {
	            detachNodeFromParent(node, parentNode);
	            return;
	          }
	          return;
	        }

	        // Polyline with empty points
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#PolylineElementPointsAttribute
	        //
	        // <polyline points="">
	        if (
	          polylineEmptyPoints &&
	          node.name === 'polyline' &&
	          node.attributes.points == null
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }

	        // Polygon with empty points
	        //
	        // https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute
	        //
	        // <polygon points="">
	        if (
	          polygonEmptyPoints &&
	          node.name === 'polygon' &&
	          node.attributes.points == null
	        ) {
	          detachNodeFromParent(node, parentNode);
	          return;
	        }
	      },
	    },
	  };
	};
	return removeHiddenElems;
}

var removeEmptyText = {};

var hasRequiredRemoveEmptyText;

function requireRemoveEmptyText () {
	if (hasRequiredRemoveEmptyText) return removeEmptyText;
	hasRequiredRemoveEmptyText = 1;

	const { detachNodeFromParent } = requireXast();

	removeEmptyText.name = 'removeEmptyText';
	removeEmptyText.type = 'visitor';
	removeEmptyText.active = true;
	removeEmptyText.description = 'removes empty <text> elements';

	/**
	 * Remove empty Text elements.
	 *
	 * @see https://www.w3.org/TR/SVG11/text.html
	 *
	 * @example
	 * Remove empty text element:
	 * <text/>
	 *
	 * Remove empty tspan element:
	 * <tspan/>
	 *
	 * Remove tref with empty xlink:href attribute:
	 * <tref xlink:href=""/>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   text?: boolean,
	 *   tspan?: boolean,
	 *   tref?: boolean
	 * }>}
	 */
	removeEmptyText.fn = (root, params) => {
	  const { text = true, tspan = true, tref = true } = params;
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // Remove empty text element
	        if (text && node.name === 'text' && node.children.length === 0) {
	          detachNodeFromParent(node, parentNode);
	        }
	        // Remove empty tspan element
	        if (tspan && node.name === 'tspan' && node.children.length === 0) {
	          detachNodeFromParent(node, parentNode);
	        }
	        // Remove tref with empty xlink:href attribute
	        if (
	          tref &&
	          node.name === 'tref' &&
	          node.attributes['xlink:href'] == null
	        ) {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeEmptyText;
}

var convertShapeToPath = {};

var hasRequiredConvertShapeToPath;

function requireConvertShapeToPath () {
	if (hasRequiredConvertShapeToPath) return convertShapeToPath;
	hasRequiredConvertShapeToPath = 1;

	/**
	 * @typedef {import('../lib/types').PathDataItem} PathDataItem
	 */

	const { stringifyPathData } = requirePath();
	const { detachNodeFromParent } = requireXast();

	convertShapeToPath.name = 'convertShapeToPath';
	convertShapeToPath.type = 'visitor';
	convertShapeToPath.active = true;
	convertShapeToPath.description = 'converts basic shapes to more compact path form';

	const regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

	/**
	 * Converts basic shape to more compact path.
	 * It also allows further optimizations like
	 * combining paths with similar attributes.
	 *
	 * @see https://www.w3.org/TR/SVG11/shapes.html
	 *
	 * @author Lev Solntsev
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   convertArcs?: boolean,
	 *   floatPrecision?: number
	 * }>}
	 */
	convertShapeToPath.fn = (root, params) => {
	  const { convertArcs = false, floatPrecision: precision } = params;

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // convert rect to path
	        if (
	          node.name === 'rect' &&
	          node.attributes.width != null &&
	          node.attributes.height != null &&
	          node.attributes.rx == null &&
	          node.attributes.ry == null
	        ) {
	          const x = Number(node.attributes.x || '0');
	          const y = Number(node.attributes.y || '0');
	          const width = Number(node.attributes.width);
	          const height = Number(node.attributes.height);
	          // Values like '100%' compute to NaN, thus running after
	          // cleanupNumericValues when 'px' units has already been removed.
	          // TODO: Calculate sizes from % and non-px units if possible.
	          if (Number.isNaN(x - y + width - height)) return;
	          /**
	           * @type {Array<PathDataItem>}
	           */
	          const pathData = [
	            { command: 'M', args: [x, y] },
	            { command: 'H', args: [x + width] },
	            { command: 'V', args: [y + height] },
	            { command: 'H', args: [x] },
	            { command: 'z', args: [] },
	          ];
	          node.name = 'path';
	          node.attributes.d = stringifyPathData({ pathData, precision });
	          delete node.attributes.x;
	          delete node.attributes.y;
	          delete node.attributes.width;
	          delete node.attributes.height;
	        }

	        // convert line to path
	        if (node.name === 'line') {
	          const x1 = Number(node.attributes.x1 || '0');
	          const y1 = Number(node.attributes.y1 || '0');
	          const x2 = Number(node.attributes.x2 || '0');
	          const y2 = Number(node.attributes.y2 || '0');
	          if (Number.isNaN(x1 - y1 + x2 - y2)) return;
	          /**
	           * @type {Array<PathDataItem>}
	           */
	          const pathData = [
	            { command: 'M', args: [x1, y1] },
	            { command: 'L', args: [x2, y2] },
	          ];
	          node.name = 'path';
	          node.attributes.d = stringifyPathData({ pathData, precision });
	          delete node.attributes.x1;
	          delete node.attributes.y1;
	          delete node.attributes.x2;
	          delete node.attributes.y2;
	        }

	        // convert polyline and polygon to path
	        if (
	          (node.name === 'polyline' || node.name === 'polygon') &&
	          node.attributes.points != null
	        ) {
	          const coords = (node.attributes.points.match(regNumber) || []).map(
	            Number
	          );
	          if (coords.length < 4) {
	            detachNodeFromParent(node, parentNode);
	            return;
	          }
	          /**
	           * @type {Array<PathDataItem>}
	           */
	          const pathData = [];
	          for (let i = 0; i < coords.length; i += 2) {
	            pathData.push({
	              command: i === 0 ? 'M' : 'L',
	              args: coords.slice(i, i + 2),
	            });
	          }
	          if (node.name === 'polygon') {
	            pathData.push({ command: 'z', args: [] });
	          }
	          node.name = 'path';
	          node.attributes.d = stringifyPathData({ pathData, precision });
	          delete node.attributes.points;
	        }

	        //  optionally convert circle
	        if (node.name === 'circle' && convertArcs) {
	          const cx = Number(node.attributes.cx || '0');
	          const cy = Number(node.attributes.cy || '0');
	          const r = Number(node.attributes.r || '0');
	          if (Number.isNaN(cx - cy + r)) {
	            return;
	          }
	          /**
	           * @type {Array<PathDataItem>}
	           */
	          const pathData = [
	            { command: 'M', args: [cx, cy - r] },
	            { command: 'A', args: [r, r, 0, 1, 0, cx, cy + r] },
	            { command: 'A', args: [r, r, 0, 1, 0, cx, cy - r] },
	            { command: 'z', args: [] },
	          ];
	          node.name = 'path';
	          node.attributes.d = stringifyPathData({ pathData, precision });
	          delete node.attributes.cx;
	          delete node.attributes.cy;
	          delete node.attributes.r;
	        }

	        // optionally covert ellipse
	        if (node.name === 'ellipse' && convertArcs) {
	          const ecx = Number(node.attributes.cx || '0');
	          const ecy = Number(node.attributes.cy || '0');
	          const rx = Number(node.attributes.rx || '0');
	          const ry = Number(node.attributes.ry || '0');
	          if (Number.isNaN(ecx - ecy + rx - ry)) {
	            return;
	          }
	          /**
	           * @type {Array<PathDataItem>}
	           */
	          const pathData = [
	            { command: 'M', args: [ecx, ecy - ry] },
	            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
	            { command: 'A', args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
	            { command: 'z', args: [] },
	          ];
	          node.name = 'path';
	          node.attributes.d = stringifyPathData({ pathData, precision });
	          delete node.attributes.cx;
	          delete node.attributes.cy;
	          delete node.attributes.rx;
	          delete node.attributes.ry;
	        }
	      },
	    },
	  };
	};
	return convertShapeToPath;
}

var convertEllipseToCircle = {};

var hasRequiredConvertEllipseToCircle;

function requireConvertEllipseToCircle () {
	if (hasRequiredConvertEllipseToCircle) return convertEllipseToCircle;
	hasRequiredConvertEllipseToCircle = 1;

	convertEllipseToCircle.name = 'convertEllipseToCircle';
	convertEllipseToCircle.type = 'visitor';
	convertEllipseToCircle.active = true;
	convertEllipseToCircle.description = 'converts non-eccentric <ellipse>s to <circle>s';

	/**
	 * Converts non-eccentric <ellipse>s to <circle>s.
	 *
	 * @see https://www.w3.org/TR/SVG11/shapes.html
	 *
	 * @author Taylor Hunt
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	convertEllipseToCircle.fn = () => {
	  return {
	    element: {
	      enter: (node) => {
	        if (node.name === 'ellipse') {
	          const rx = node.attributes.rx || '0';
	          const ry = node.attributes.ry || '0';
	          if (
	            rx === ry ||
	            rx === 'auto' ||
	            ry === 'auto' // SVG2
	          ) {
	            node.name = 'circle';
	            const radius = rx === 'auto' ? ry : rx;
	            delete node.attributes.rx;
	            delete node.attributes.ry;
	            node.attributes.r = radius;
	          }
	        }
	      },
	    },
	  };
	};
	return convertEllipseToCircle;
}

var moveElemsAttrsToGroup = {};

var hasRequiredMoveElemsAttrsToGroup;

function requireMoveElemsAttrsToGroup () {
	if (hasRequiredMoveElemsAttrsToGroup) return moveElemsAttrsToGroup;
	hasRequiredMoveElemsAttrsToGroup = 1;

	const { visit } = requireXast();
	const { inheritableAttrs, pathElems } = require_collections();

	moveElemsAttrsToGroup.type = 'visitor';
	moveElemsAttrsToGroup.name = 'moveElemsAttrsToGroup';
	moveElemsAttrsToGroup.active = true;
	moveElemsAttrsToGroup.description = 'Move common attributes of group children to the group';

	/**
	 * Move common attributes of group children to the group
	 *
	 * @example
	 * <g attr1="val1">
	 *     <g attr2="val2">
	 *         text
	 *     </g>
	 *     <circle attr2="val2" attr3="val3"/>
	 * </g>
	 *              â¬‡
	 * <g attr1="val1" attr2="val2">
	 *     <g>
	 *         text
	 *     </g>
	 *    <circle attr3="val3"/>
	 * </g>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	moveElemsAttrsToGroup.fn = (root) => {
	  // find if any style element is present
	  let deoptimizedWithStyles = false;
	  visit(root, {
	    element: {
	      enter: (node) => {
	        if (node.name === 'style') {
	          deoptimizedWithStyles = true;
	        }
	      },
	    },
	  });

	  return {
	    element: {
	      exit: (node) => {
	        // process only groups with more than 1 children
	        if (node.name !== 'g' || node.children.length <= 1) {
	          return;
	        }

	        // deoptimize the plugin when style elements are present
	        // selectors may rely on id, classes or tag names
	        if (deoptimizedWithStyles) {
	          return;
	        }

	        /**
	         * find common attributes in group children
	         * @type {Map<string, string>}
	         */
	        const commonAttributes = new Map();
	        let initial = true;
	        let everyChildIsPath = true;
	        for (const child of node.children) {
	          if (child.type === 'element') {
	            if (pathElems.includes(child.name) === false) {
	              everyChildIsPath = false;
	            }
	            if (initial) {
	              initial = false;
	              // collect all inheritable attributes from first child element
	              for (const [name, value] of Object.entries(child.attributes)) {
	                // consider only inheritable attributes
	                if (inheritableAttrs.includes(name)) {
	                  commonAttributes.set(name, value);
	                }
	              }
	            } else {
	              // exclude uncommon attributes from initial list
	              for (const [name, value] of commonAttributes) {
	                if (child.attributes[name] !== value) {
	                  commonAttributes.delete(name);
	                }
	              }
	            }
	          }
	        }

	        // preserve transform on children when group has clip-path or mask
	        if (
	          node.attributes['clip-path'] != null ||
	          node.attributes.mask != null
	        ) {
	          commonAttributes.delete('transform');
	        }

	        // preserve transform when all children are paths
	        // so the transform could be applied to path data by other plugins
	        if (everyChildIsPath) {
	          commonAttributes.delete('transform');
	        }

	        // add common children attributes to group
	        for (const [name, value] of commonAttributes) {
	          if (name === 'transform') {
	            if (node.attributes.transform != null) {
	              node.attributes.transform = `${node.attributes.transform} ${value}`;
	            } else {
	              node.attributes.transform = value;
	            }
	          } else {
	            node.attributes[name] = value;
	          }
	        }

	        // delete common attributes from children
	        for (const child of node.children) {
	          if (child.type === 'element') {
	            for (const [name] of commonAttributes) {
	              delete child.attributes[name];
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return moveElemsAttrsToGroup;
}

var moveGroupAttrsToElems = {};

var hasRequiredMoveGroupAttrsToElems;

function requireMoveGroupAttrsToElems () {
	if (hasRequiredMoveGroupAttrsToElems) return moveGroupAttrsToElems;
	hasRequiredMoveGroupAttrsToElems = 1;

	const { pathElems, referencesProps } = require_collections();

	moveGroupAttrsToElems.name = 'moveGroupAttrsToElems';

	moveGroupAttrsToElems.type = 'perItem';

	moveGroupAttrsToElems.active = true;

	moveGroupAttrsToElems.description = 'moves some group attributes to the content elements';

	const pathElemsWithGroupsAndText = [...pathElems, 'g', 'text'];

	/**
	 * Move group attrs to the content elements.
	 *
	 * @example
	 * <g transform="scale(2)">
	 *     <path transform="rotate(45)" d="M0,0 L10,20"/>
	 *     <path transform="translate(10, 20)" d="M0,10 L20,30"/>
	 * </g>
	 *                          â¬‡
	 * <g>
	 *     <path transform="scale(2) rotate(45)" d="M0,0 L10,20"/>
	 *     <path transform="scale(2) translate(10, 20)" d="M0,10 L20,30"/>
	 * </g>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	moveGroupAttrsToElems.fn = function (item) {
	  // move group transform attr to content's pathElems
	  if (
	    item.type === 'element' &&
	    item.name === 'g' &&
	    item.children.length !== 0 &&
	    item.attributes.transform != null &&
	    Object.entries(item.attributes).some(
	      ([name, value]) =>
	        referencesProps.includes(name) && value.includes('url(')
	    ) === false &&
	    item.children.every(
	      (inner) =>
	        pathElemsWithGroupsAndText.includes(inner.name) &&
	        inner.attributes.id == null
	    )
	  ) {
	    for (const inner of item.children) {
	      const value = item.attributes.transform;
	      if (inner.attributes.transform != null) {
	        inner.attributes.transform = value + ' ' + inner.attributes.transform;
	      } else {
	        inner.attributes.transform = value;
	      }
	    }

	    delete item.attributes.transform;
	  }
	};
	return moveGroupAttrsToElems;
}

var collapseGroups = {};

var hasRequiredCollapseGroups;

function requireCollapseGroups () {
	if (hasRequiredCollapseGroups) return collapseGroups;
	hasRequiredCollapseGroups = 1;

	/**
	 * @typedef {import('../lib/types').XastNode} XastNode
	 */

	const { inheritableAttrs, elemsGroups } = require_collections();

	collapseGroups.type = 'visitor';
	collapseGroups.name = 'collapseGroups';
	collapseGroups.active = true;
	collapseGroups.description = 'collapses useless groups';

	/**
	 * @type {(node: XastNode, name: string) => boolean}
	 */
	const hasAnimatedAttr = (node, name) => {
	  if (node.type === 'element') {
	    if (
	      elemsGroups.animation.includes(node.name) &&
	      node.attributes.attributeName === name
	    ) {
	      return true;
	    }
	    for (const child of node.children) {
	      if (hasAnimatedAttr(child, name)) {
	        return true;
	      }
	    }
	  }
	  return false;
	};

	/**
	 * Collapse useless groups.
	 *
	 * @example
	 * <g>
	 *     <g attr1="val1">
	 *         <path d="..."/>
	 *     </g>
	 * </g>
	 *         â¬‡
	 * <g>
	 *     <g>
	 *         <path attr1="val1" d="..."/>
	 *     </g>
	 * </g>
	 *         â¬‡
	 * <path attr1="val1" d="..."/>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	collapseGroups.fn = () => {
	  return {
	    element: {
	      exit: (node, parentNode) => {
	        if (parentNode.type === 'root' || parentNode.name === 'switch') {
	          return;
	        }
	        // non-empty groups
	        if (node.name !== 'g' || node.children.length === 0) {
	          return;
	        }

	        // move group attibutes to the single child element
	        if (
	          Object.keys(node.attributes).length !== 0 &&
	          node.children.length === 1
	        ) {
	          const firstChild = node.children[0];
	          // TODO untangle this mess
	          if (
	            firstChild.type === 'element' &&
	            firstChild.attributes.id == null &&
	            node.attributes.filter == null &&
	            (node.attributes.class == null ||
	              firstChild.attributes.class == null) &&
	            ((node.attributes['clip-path'] == null &&
	              node.attributes.mask == null) ||
	              (firstChild.name === 'g' &&
	                node.attributes.transform == null &&
	                firstChild.attributes.transform == null))
	          ) {
	            for (const [name, value] of Object.entries(node.attributes)) {
	              // avoid copying to not conflict with animated attribute
	              if (hasAnimatedAttr(firstChild, name)) {
	                return;
	              }
	              if (firstChild.attributes[name] == null) {
	                firstChild.attributes[name] = value;
	              } else if (name === 'transform') {
	                firstChild.attributes[name] =
	                  value + ' ' + firstChild.attributes[name];
	              } else if (firstChild.attributes[name] === 'inherit') {
	                firstChild.attributes[name] = value;
	              } else if (
	                inheritableAttrs.includes(name) === false &&
	                firstChild.attributes[name] !== value
	              ) {
	                return;
	              }
	              delete node.attributes[name];
	            }
	          }
	        }

	        // collapse groups without attributes
	        if (Object.keys(node.attributes).length === 0) {
	          // animation elements "add" attributes to group
	          // group should be preserved
	          for (const child of node.children) {
	            if (
	              child.type === 'element' &&
	              elemsGroups.animation.includes(child.name)
	            ) {
	              return;
	            }
	          }
	          // replace current node with all its children
	          const index = parentNode.children.indexOf(node);
	          parentNode.children.splice(index, 1, ...node.children);
	          // TODO remove in v3
	          for (const child of node.children) {
	            // @ts-ignore parentNode is forbidden for public usage
	            // and will be moved in v3
	            child.parentNode = parentNode;
	          }
	        }
	      },
	    },
	  };
	};
	return collapseGroups;
}

var convertPathData = {};

var _path = {};

var hasRequired_path;

function require_path () {
	if (hasRequired_path) return _path;
	hasRequired_path = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 * @typedef {import('../lib/types').PathDataItem} PathDataItem
	 */

	const { parsePathData, stringifyPathData } = requirePath();

	/**
	 * @type {[number, number]}
	 */
	var prevCtrlPoint;

	/**
	 * Convert path string to JS representation.
	 *
	 * @type {(path: XastElement) => Array<PathDataItem>}
	 */
	const path2js = (path) => {
	  // @ts-ignore legacy
	  if (path.pathJS) return path.pathJS;
	  /**
	   * @type {Array<PathDataItem>}
	   */
	  const pathData = []; // JS representation of the path data
	  const newPathData = parsePathData(path.attributes.d);
	  for (const { command, args } of newPathData) {
	    pathData.push({ command, args });
	  }
	  // First moveto is actually absolute. Subsequent coordinates were separated above.
	  if (pathData.length && pathData[0].command == 'm') {
	    pathData[0].command = 'M';
	  }
	  // @ts-ignore legacy
	  path.pathJS = pathData;
	  return pathData;
	};
	_path.path2js = path2js;

	/**
	 * Convert relative Path data to absolute.
	 *
	 * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}
	 *
	 */
	const convertRelativeToAbsolute = (data) => {
	  /**
	   * @type {Array<PathDataItem>}
	   */
	  const newData = [];
	  let start = [0, 0];
	  let cursor = [0, 0];

	  for (let { command, args } of data) {
	    args = args.slice();

	    // moveto (x y)
	    if (command === 'm') {
	      args[0] += cursor[0];
	      args[1] += cursor[1];
	      command = 'M';
	    }
	    if (command === 'M') {
	      cursor[0] = args[0];
	      cursor[1] = args[1];
	      start[0] = cursor[0];
	      start[1] = cursor[1];
	    }

	    // horizontal lineto (x)
	    if (command === 'h') {
	      args[0] += cursor[0];
	      command = 'H';
	    }
	    if (command === 'H') {
	      cursor[0] = args[0];
	    }

	    // vertical lineto (y)
	    if (command === 'v') {
	      args[0] += cursor[1];
	      command = 'V';
	    }
	    if (command === 'V') {
	      cursor[1] = args[0];
	    }

	    // lineto (x y)
	    if (command === 'l') {
	      args[0] += cursor[0];
	      args[1] += cursor[1];
	      command = 'L';
	    }
	    if (command === 'L') {
	      cursor[0] = args[0];
	      cursor[1] = args[1];
	    }

	    // curveto (x1 y1 x2 y2 x y)
	    if (command === 'c') {
	      args[0] += cursor[0];
	      args[1] += cursor[1];
	      args[2] += cursor[0];
	      args[3] += cursor[1];
	      args[4] += cursor[0];
	      args[5] += cursor[1];
	      command = 'C';
	    }
	    if (command === 'C') {
	      cursor[0] = args[4];
	      cursor[1] = args[5];
	    }

	    // smooth curveto (x2 y2 x y)
	    if (command === 's') {
	      args[0] += cursor[0];
	      args[1] += cursor[1];
	      args[2] += cursor[0];
	      args[3] += cursor[1];
	      command = 'S';
	    }
	    if (command === 'S') {
	      cursor[0] = args[2];
	      cursor[1] = args[3];
	    }

	    // quadratic BÃ©zier curveto (x1 y1 x y)
	    if (command === 'q') {
	      args[0] += cursor[0];
	      args[1] += cursor[1];
	      args[2] += cursor[0];
	      args[3] += cursor[1];
	      command = 'Q';
	    }
	    if (command === 'Q') {
	      cursor[0] = args[2];
	      cursor[1] = args[3];
	    }

	    // smooth quadratic BÃ©zier curveto (x y)
	    if (command === 't') {
	      args[0] += cursor[0];
	      args[1] += cursor[1];
	      command = 'T';
	    }
	    if (command === 'T') {
	      cursor[0] = args[0];
	      cursor[1] = args[1];
	    }

	    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
	    if (command === 'a') {
	      args[5] += cursor[0];
	      args[6] += cursor[1];
	      command = 'A';
	    }
	    if (command === 'A') {
	      cursor[0] = args[5];
	      cursor[1] = args[6];
	    }

	    // closepath
	    if (command === 'z' || command === 'Z') {
	      cursor[0] = start[0];
	      cursor[1] = start[1];
	      command = 'z';
	    }

	    newData.push({ command, args });
	  }
	  return newData;
	};

	/**
	 * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams
	 */

	/**
	 * Convert path array to string.
	 *
	 * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}
	 */
	_path.js2path = function (path, data, params) {
	  // @ts-ignore legacy
	  path.pathJS = data;

	  const pathData = [];
	  for (const item of data) {
	    // remove moveto commands which are followed by moveto commands
	    if (
	      pathData.length !== 0 &&
	      (item.command === 'M' || item.command === 'm')
	    ) {
	      const last = pathData[pathData.length - 1];
	      if (last.command === 'M' || last.command === 'm') {
	        pathData.pop();
	      }
	    }
	    pathData.push({
	      command: item.command,
	      args: item.args,
	    });
	  }

	  path.attributes.d = stringifyPathData({
	    pathData,
	    precision: params.floatPrecision,
	    disableSpaceAfterFlags: params.noSpaceAfterFlags,
	  });
	};

	/**
	 * @type {(dest: Array<number>, source: Array<number>) => Array<number>}
	 */
	function set(dest, source) {
	  dest[0] = source[source.length - 2];
	  dest[1] = source[source.length - 1];
	  return dest;
	}

	/**
	 * Checks if two paths have an intersection by checking convex hulls
	 * collision using Gilbert-Johnson-Keerthi distance algorithm
	 * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/
	 *
	 * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}
	 */
	_path.intersects = function (path1, path2) {
	  // Collect points of every subpath.
	  const points1 = gatherPoints(convertRelativeToAbsolute(path1));
	  const points2 = gatherPoints(convertRelativeToAbsolute(path2));

	  // Axis-aligned bounding box check.
	  if (
	    points1.maxX <= points2.minX ||
	    points2.maxX <= points1.minX ||
	    points1.maxY <= points2.minY ||
	    points2.maxY <= points1.minY ||
	    points1.list.every((set1) => {
	      return points2.list.every((set2) => {
	        return (
	          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||
	          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||
	          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||
	          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]
	        );
	      });
	    })
	  )
	    return false;

	  // Get a convex hull from points of each subpath. Has the most complexity O(nÂ·log n).
	  const hullNest1 = points1.list.map(convexHull);
	  const hullNest2 = points2.list.map(convexHull);

	  // Check intersection of every subpath of the first path with every subpath of the second.
	  return hullNest1.some(function (hull1) {
	    if (hull1.list.length < 3) return false;

	    return hullNest2.some(function (hull2) {
	      if (hull2.list.length < 3) return false;

	      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex
	        direction = minus(simplex[0]); // set the direction to point towards the origin

	      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough
	      // eslint-disable-next-line no-constant-condition
	      while (true) {
	        // eslint-disable-next-line no-constant-condition
	        if (iterations-- == 0) {
	          console.error(
	            'Error: infinite loop while processing mergePaths plugin.'
	          );
	          return true; // true is the safe value that means â€œdo nothing with pathsâ€
	        }
	        // add a new point
	        simplex.push(getSupport(hull1, hull2, direction));
	        // see if the new point was on the correct side of the origin
	        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
	        // process the simplex
	        if (processSimplex(simplex, direction)) return true;
	      }
	    });
	  });

	  /**
	   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}
	   */
	  function getSupport(a, b, direction) {
	    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
	  }

	  // Computes farthest polygon point in particular direction.
	  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.
	  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.
	  /**
	   * @type {(polygon: Point, direction: Array<number>) => Array<number>}
	   */
	  function supportPoint(polygon, direction) {
	    var index =
	        direction[1] >= 0
	          ? direction[0] < 0
	            ? polygon.maxY
	            : polygon.maxX
	          : direction[0] < 0
	          ? polygon.minX
	          : polygon.minY,
	      max = -Infinity,
	      value;
	    while ((value = dot(polygon.list[index], direction)) > max) {
	      max = value;
	      index = ++index % polygon.list.length;
	    }
	    return polygon.list[(index || polygon.list.length) - 1];
	  }
	};

	/**
	 * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}
	 */
	function processSimplex(simplex, direction) {
	  // we only need to handle to 1-simplex and 2-simplex
	  if (simplex.length == 2) {
	    // 1-simplex
	    let a = simplex[1],
	      b = simplex[0],
	      AO = minus(simplex[1]),
	      AB = sub(b, a);
	    // AO is in the same direction as AB
	    if (dot(AO, AB) > 0) {
	      // get the vector perpendicular to AB facing O
	      set(direction, orth(AB, a));
	    } else {
	      set(direction, AO);
	      // only A remains in the simplex
	      simplex.shift();
	    }
	  } else {
	    // 2-simplex
	    let a = simplex[2], // [a, b, c] = simplex
	      b = simplex[1],
	      c = simplex[0],
	      AB = sub(b, a),
	      AC = sub(c, a),
	      AO = minus(a),
	      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C
	      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B

	    if (dot(ACB, AO) > 0) {
	      if (dot(AB, AO) > 0) {
	        // region 4
	        set(direction, ACB);
	        simplex.shift(); // simplex = [b, a]
	      } else {
	        // region 5
	        set(direction, AO);
	        simplex.splice(0, 2); // simplex = [a]
	      }
	    } else if (dot(ABC, AO) > 0) {
	      if (dot(AC, AO) > 0) {
	        // region 6
	        set(direction, ABC);
	        simplex.splice(1, 1); // simplex = [c, a]
	      } else {
	        // region 5 (again)
	        set(direction, AO);
	        simplex.splice(0, 2); // simplex = [a]
	      }
	    } // region 7
	    else return true;
	  }
	  return false;
	}

	/**
	 * @type {(v: Array<number>) => Array<number>}
	 */
	function minus(v) {
	  return [-v[0], -v[1]];
	}

	/**
	 * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}
	 */
	function sub(v1, v2) {
	  return [v1[0] - v2[0], v1[1] - v2[1]];
	}

	/**
	 * @type {(v1: Array<number>, v2: Array<number>) => number}
	 */
	function dot(v1, v2) {
	  return v1[0] * v2[0] + v1[1] * v2[1];
	}

	/**
	 * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}
	 */
	function orth(v, from) {
	  var o = [-v[1], v[0]];
	  return dot(o, minus(from)) < 0 ? minus(o) : o;
	}

	/**
	 * @typedef {{
	 *   list: Array<Array<number>>,
	 *   minX: number,
	 *   minY: number,
	 *   maxX: number,
	 *   maxY: number
	 * }} Point
	 */

	/**
	 * @typedef {{
	 *   list: Array<Point>,
	 *   minX: number,
	 *   minY: number,
	 *   maxX: number,
	 *   maxY: number
	 * }} Points
	 */

	/**
	 * @type {(pathData: Array<PathDataItem>) => Points}
	 */
	function gatherPoints(pathData) {
	  /**
	   * @type {Points}
	   */
	  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };

	  // Writes data about the extreme points on each axle
	  /**
	   * @type {(path: Point, point: Array<number>) => void}
	   */
	  const addPoint = (path, point) => {
	    if (!path.list.length || point[1] > path.list[path.maxY][1]) {
	      path.maxY = path.list.length;
	      points.maxY = points.list.length
	        ? Math.max(point[1], points.maxY)
	        : point[1];
	    }
	    if (!path.list.length || point[0] > path.list[path.maxX][0]) {
	      path.maxX = path.list.length;
	      points.maxX = points.list.length
	        ? Math.max(point[0], points.maxX)
	        : point[0];
	    }
	    if (!path.list.length || point[1] < path.list[path.minY][1]) {
	      path.minY = path.list.length;
	      points.minY = points.list.length
	        ? Math.min(point[1], points.minY)
	        : point[1];
	    }
	    if (!path.list.length || point[0] < path.list[path.minX][0]) {
	      path.minX = path.list.length;
	      points.minX = points.list.length
	        ? Math.min(point[0], points.minX)
	        : point[0];
	    }
	    path.list.push(point);
	  };

	  for (let i = 0; i < pathData.length; i += 1) {
	    const pathDataItem = pathData[i];
	    let subPath =
	      points.list.length === 0
	        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }
	        : points.list[points.list.length - 1];
	    let prev = i === 0 ? null : pathData[i - 1];
	    let basePoint =
	      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
	    let data = pathDataItem.args;
	    let ctrlPoint = basePoint;

	    /**
	     * @type {(n: number, i: number) => number}
	     * TODO fix null hack
	     */
	    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);

	    switch (pathDataItem.command) {
	      case 'M':
	        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
	        points.list.push(subPath);
	        break;

	      case 'H':
	        if (basePoint != null) {
	          addPoint(subPath, [data[0], basePoint[1]]);
	        }
	        break;

	      case 'V':
	        if (basePoint != null) {
	          addPoint(subPath, [basePoint[0], data[0]]);
	        }
	        break;

	      case 'Q':
	        addPoint(subPath, data.slice(0, 2));
	        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand
	        break;

	      case 'T':
	        if (
	          basePoint != null &&
	          prev != null &&
	          (prev.command == 'Q' || prev.command == 'T')
	        ) {
	          ctrlPoint = [
	            basePoint[0] + prevCtrlPoint[0],
	            basePoint[1] + prevCtrlPoint[1],
	          ];
	          addPoint(subPath, ctrlPoint);
	          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
	        }
	        break;

	      case 'C':
	        if (basePoint != null) {
	          // Approximate quibic Bezier curve with middle points between control points
	          addPoint(subPath, [
	            0.5 * (basePoint[0] + data[0]),
	            0.5 * (basePoint[1] + data[1]),
	          ]);
	        }
	        addPoint(subPath, [
	          0.5 * (data[0] + data[2]),
	          0.5 * (data[1] + data[3]),
	        ]);
	        addPoint(subPath, [
	          0.5 * (data[2] + data[4]),
	          0.5 * (data[3] + data[5]),
	        ]);
	        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand
	        break;

	      case 'S':
	        if (
	          basePoint != null &&
	          prev != null &&
	          (prev.command == 'C' || prev.command == 'S')
	        ) {
	          addPoint(subPath, [
	            basePoint[0] + 0.5 * prevCtrlPoint[0],
	            basePoint[1] + 0.5 * prevCtrlPoint[1],
	          ]);
	          ctrlPoint = [
	            basePoint[0] + prevCtrlPoint[0],
	            basePoint[1] + prevCtrlPoint[1],
	          ];
	        }
	        if (ctrlPoint != null) {
	          addPoint(subPath, [
	            0.5 * (ctrlPoint[0] + data[0]),
	            0.5 * (ctrlPoint[1] + data[1]),
	          ]);
	        }
	        addPoint(subPath, [
	          0.5 * (data[0] + data[2]),
	          0.5 * (data[1] + data[3]),
	        ]);
	        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
	        break;

	      case 'A':
	        if (basePoint != null) {
	          // Convert the arc to bezier curves and use the same approximation
	          // @ts-ignore no idea what's going on here
	          var curves = a2c.apply(0, basePoint.concat(data));
	          for (
	            var cData;
	            (cData = curves.splice(0, 6).map(toAbsolute)).length;

	          ) {
	            if (basePoint != null) {
	              addPoint(subPath, [
	                0.5 * (basePoint[0] + cData[0]),
	                0.5 * (basePoint[1] + cData[1]),
	              ]);
	            }
	            addPoint(subPath, [
	              0.5 * (cData[0] + cData[2]),
	              0.5 * (cData[1] + cData[3]),
	            ]);
	            addPoint(subPath, [
	              0.5 * (cData[2] + cData[4]),
	              0.5 * (cData[3] + cData[5]),
	            ]);
	            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));
	          }
	        }
	        break;
	    }

	    // Save final command coordinates
	    if (data.length >= 2) addPoint(subPath, data.slice(-2));
	  }

	  return points;
	}

	/**
	 * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.
	 * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	 *
	 * @type {(points: Point) => Point}
	 */
	function convexHull(points) {
	  points.list.sort(function (a, b) {
	    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
	  });

	  var lower = [],
	    minY = 0,
	    bottom = 0;
	  for (let i = 0; i < points.list.length; i++) {
	    while (
	      lower.length >= 2 &&
	      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=
	        0
	    ) {
	      lower.pop();
	    }
	    if (points.list[i][1] < points.list[minY][1]) {
	      minY = i;
	      bottom = lower.length;
	    }
	    lower.push(points.list[i]);
	  }

	  var upper = [],
	    maxY = points.list.length - 1,
	    top = 0;
	  for (let i = points.list.length; i--; ) {
	    while (
	      upper.length >= 2 &&
	      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=
	        0
	    ) {
	      upper.pop();
	    }
	    if (points.list[i][1] > points.list[maxY][1]) {
	      maxY = i;
	      top = upper.length;
	    }
	    upper.push(points.list[i]);
	  }

	  // last points are equal to starting points of the other part
	  upper.pop();
	  lower.pop();

	  const hullList = lower.concat(upper);

	  /**
	   * @type {Point}
	   */
	  const hull = {
	    list: hullList,
	    minX: 0, // by sorting
	    maxX: lower.length,
	    minY: bottom,
	    maxY: (lower.length + top) % hullList.length,
	  };

	  return hull;
	}

	/**
	 * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}
	 */
	function cross(o, a, b) {
	  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
	}

	/**
	 * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/
	 * Thanks to Dmitry Baranovskiy for his great work!
	 *
	 * @type {(
	 *  x1: number,
	 *  y1: number,
	 *  rx: number,
	 *  ry: number,
	 *  angle: number,
	 *  large_arc_flag: number,
	 *  sweep_flag: number,
	 *  x2: number,
	 *  y2: number,
	 *  recursive: Array<number>
	 * ) => Array<number>}
	 */
	const a2c = (
	  x1,
	  y1,
	  rx,
	  ry,
	  angle,
	  large_arc_flag,
	  sweep_flag,
	  x2,
	  y2,
	  recursive
	) => {
	  // for more information of where this Math came from visit:
	  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	  const _120 = (Math.PI * 120) / 180;
	  const rad = (Math.PI / 180) * (+angle || 0);
	  /**
	   * @type {Array<number>}
	   */
	  let res = [];
	  /**
	   * @type {(x: number, y: number, rad: number) => number}
	   */
	  const rotateX = (x, y, rad) => {
	    return x * Math.cos(rad) - y * Math.sin(rad);
	  };
	  /**
	   * @type {(x: number, y: number, rad: number) => number}
	   */
	  const rotateY = (x, y, rad) => {
	    return x * Math.sin(rad) + y * Math.cos(rad);
	  };
	  if (!recursive) {
	    x1 = rotateX(x1, y1, -rad);
	    y1 = rotateY(x1, y1, -rad);
	    x2 = rotateX(x2, y2, -rad);
	    y2 = rotateY(x2, y2, -rad);
	    var x = (x1 - x2) / 2,
	      y = (y1 - y2) / 2;
	    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	    if (h > 1) {
	      h = Math.sqrt(h);
	      rx = h * rx;
	      ry = h * ry;
	    }
	    var rx2 = rx * rx;
	    var ry2 = ry * ry;
	    var k =
	      (large_arc_flag == sweep_flag ? -1 : 1) *
	      Math.sqrt(
	        Math.abs(
	          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)
	        )
	      );
	    var cx = (k * rx * y) / ry + (x1 + x2) / 2;
	    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;
	    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
	    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));

	    f1 = x1 < cx ? Math.PI - f1 : f1;
	    f2 = x2 < cx ? Math.PI - f2 : f2;
	    f1 < 0 && (f1 = Math.PI * 2 + f1);
	    f2 < 0 && (f2 = Math.PI * 2 + f2);
	    if (sweep_flag && f1 > f2) {
	      f1 = f1 - Math.PI * 2;
	    }
	    if (!sweep_flag && f2 > f1) {
	      f2 = f2 - Math.PI * 2;
	    }
	  } else {
	    f1 = recursive[0];
	    f2 = recursive[1];
	    cx = recursive[2];
	    cy = recursive[3];
	  }
	  var df = f2 - f1;
	  if (Math.abs(df) > _120) {
	    var f2old = f2,
	      x2old = x2,
	      y2old = y2;
	    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
	    x2 = cx + rx * Math.cos(f2);
	    y2 = cy + ry * Math.sin(f2);
	    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
	      f2,
	      f2old,
	      cx,
	      cy,
	    ]);
	  }
	  df = f2 - f1;
	  var c1 = Math.cos(f1),
	    s1 = Math.sin(f1),
	    c2 = Math.cos(f2),
	    s2 = Math.sin(f2),
	    t = Math.tan(df / 4),
	    hx = (4 / 3) * rx * t,
	    hy = (4 / 3) * ry * t,
	    m = [
	      -hx * s1,
	      hy * c1,
	      x2 + hx * s2 - x1,
	      y2 - hy * c2 - y1,
	      x2 - x1,
	      y2 - y1,
	    ];
	  if (recursive) {
	    return m.concat(res);
	  } else {
	    res = m.concat(res);
	    var newres = [];
	    for (var i = 0, n = res.length; i < n; i++) {
	      newres[i] =
	        i % 2
	          ? rotateY(res[i - 1], res[i], rad)
	          : rotateX(res[i], res[i + 1], rad);
	    }
	    return newres;
	  }
	};
	return _path;
}

var _applyTransforms = {};

var _transforms = {};

var hasRequired_transforms;

function require_transforms () {
	if (hasRequired_transforms) return _transforms;
	hasRequired_transforms = 1;

	const regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;
	const regTransformSplit =
	  /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
	const regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

	/**
	 * @typedef {{ name: string, data: Array<number> }} TransformItem
	 */

	/**
	 * Convert transform string to JS representation.
	 *
	 * @type {(transformString: string) => Array<TransformItem>}
	 */
	_transforms.transform2js = (transformString) => {
	  // JS representation of the transform data
	  /**
	   * @type {Array<TransformItem>}
	   */
	  const transforms = [];
	  // current transform context
	  /**
	   * @type {null | TransformItem}
	   */
	  let current = null;
	  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']
	  for (const item of transformString.split(regTransformSplit)) {
	    var num;
	    if (item) {
	      // if item is a translate function
	      if (regTransformTypes.test(item)) {
	        // then collect it and change current context
	        current = { name: item, data: [] };
	        transforms.push(current);
	        // else if item is data
	      } else {
	        // then split it into [10, 50] and collect as context.data
	        // eslint-disable-next-line no-cond-assign
	        while ((num = regNumericValues.exec(item))) {
	          num = Number(num);
	          if (current != null) {
	            current.data.push(num);
	          }
	        }
	      }
	    }
	  }
	  // return empty array if broken transform (no data)
	  return current == null || current.data.length == 0 ? [] : transforms;
	};

	/**
	 * Multiply transforms into one.
	 *
	 * @type {(transforms: Array<TransformItem>) => TransformItem}
	 */
	_transforms.transformsMultiply = (transforms) => {
	  // convert transforms objects to the matrices
	  const matrixData = transforms.map((transform) => {
	    if (transform.name === 'matrix') {
	      return transform.data;
	    }
	    return transformToMatrix(transform);
	  });
	  // multiply all matrices into one
	  const matrixTransform = {
	    name: 'matrix',
	    data:
	      matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : [],
	  };
	  return matrixTransform;
	};

	/**
	 * math utilities in radians.
	 */
	const mth = {
	  /**
	   * @type {(deg: number) => number}
	   */
	  rad: (deg) => {
	    return (deg * Math.PI) / 180;
	  },

	  /**
	   * @type {(rad: number) => number}
	   */
	  deg: (rad) => {
	    return (rad * 180) / Math.PI;
	  },

	  /**
	   * @type {(deg: number) => number}
	   */
	  cos: (deg) => {
	    return Math.cos(mth.rad(deg));
	  },

	  /**
	   * @type {(val: number, floatPrecision: number) => number}
	   */
	  acos: (val, floatPrecision) => {
	    return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));
	  },

	  /**
	   * @type {(deg: number) => number}
	   */
	  sin: (deg) => {
	    return Math.sin(mth.rad(deg));
	  },

	  /**
	   * @type {(val: number, floatPrecision: number) => number}
	   */
	  asin: (val, floatPrecision) => {
	    return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));
	  },

	  /**
	   * @type {(deg: number) => number}
	   */
	  tan: (deg) => {
	    return Math.tan(mth.rad(deg));
	  },

	  /**
	   * @type {(val: number, floatPrecision: number) => number}
	   */
	  atan: (val, floatPrecision) => {
	    return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));
	  },
	};

	/**
	 * @typedef {{
	 *   convertToShorts: boolean,
	 *   floatPrecision: number,
	 *   transformPrecision: number,
	 *   matrixToTransform: boolean,
	 *   shortTranslate: boolean,
	 *   shortScale: boolean,
	 *   shortRotate: boolean,
	 *   removeUseless: boolean,
	 *   collapseIntoOne: boolean,
	 *   leadingZero: boolean,
	 *   negativeExtraSpace: boolean,
	 * }} TransformParams
	 */

	/**
	 * Decompose matrix into simple transforms. See
	 * https://frederic-wang.fr/decomposition-of-2d-transform-matrices.html
	 *
	 * @type {(transform: TransformItem, params: TransformParams) => Array<TransformItem>}
	 */
	_transforms.matrixToTransform = (transform, params) => {
	  let floatPrecision = params.floatPrecision;
	  let data = transform.data;
	  let transforms = [];
	  let sx = Number(
	    Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)
	  );
	  let sy = Number(
	    ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(
	      params.transformPrecision
	    )
	  );
	  let colsSum = data[0] * data[2] + data[1] * data[3];
	  let rowsSum = data[0] * data[1] + data[2] * data[3];
	  let scaleBefore = rowsSum != 0 || sx == sy;

	  // [..., ..., ..., ..., tx, ty] â†’ translate(tx, ty)
	  if (data[4] || data[5]) {
	    transforms.push({
	      name: 'translate',
	      data: data.slice(4, data[5] ? 6 : 5),
	    });
	  }

	  // [sx, 0, tan(a)Â·sy, sy, 0, 0] â†’ skewX(a)Â·scale(sx, sy)
	  if (!data[1] && data[2]) {
	    transforms.push({
	      name: 'skewX',
	      data: [mth.atan(data[2] / sy, floatPrecision)],
	    });

	    // [sx, sxÂ·tan(a), 0, sy, 0, 0] â†’ skewY(a)Â·scale(sx, sy)
	  } else if (data[1] && !data[2]) {
	    transforms.push({
	      name: 'skewY',
	      data: [mth.atan(data[1] / data[0], floatPrecision)],
	    });
	    sx = data[0];
	    sy = data[3];

	    // [sxÂ·cos(a), sxÂ·sin(a), syÂ·-sin(a), syÂ·cos(a), x, y] â†’ rotate(a[, cx, cy])Â·(scale or skewX) or
	    // [sxÂ·cos(a), syÂ·sin(a), sxÂ·-sin(a), syÂ·cos(a), x, y] â†’ scale(sx, sy)Â·rotate(a[, cx, cy]) (if !scaleBefore)
	  } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {
	    if (!scaleBefore) {
	      sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);
	      sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);
	      transforms.push({ name: 'scale', data: [sx, sy] });
	    }
	    var angle = Math.min(Math.max(-1, data[0] / sx), 1),
	      rotate = [
	        mth.acos(angle, floatPrecision) *
	          ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1),
	      ];

	    if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });

	    if (rowsSum && colsSum)
	      transforms.push({
	        name: 'skewX',
	        data: [mth.atan(colsSum / (sx * sx), floatPrecision)],
	      });

	    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)
	    if (rotate[0] && (data[4] || data[5])) {
	      transforms.shift();
	      var cos = data[0] / sx,
	        sin = data[1] / (scaleBefore ? sx : sy),
	        x = data[4] * (scaleBefore ? 1 : sy),
	        y = data[5] * (scaleBefore ? 1 : sx),
	        denom =
	          (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) *
	          (scaleBefore ? 1 : sx * sy);
	      rotate.push(((1 - cos) * x - sin * y) / denom);
	      rotate.push(((1 - cos) * y + sin * x) / denom);
	    }

	    // Too many transformations, return original matrix if it isn't just a scale/translate
	  } else if (data[1] || data[2]) {
	    return [transform];
	  }

	  if ((scaleBefore && (sx != 1 || sy != 1)) || !transforms.length)
	    transforms.push({
	      name: 'scale',
	      data: sx == sy ? [sx] : [sx, sy],
	    });

	  return transforms;
	};

	/**
	 * Convert transform to the matrix data.
	 *
	 * @type {(transform: TransformItem) => Array<number> }
	 */
	const transformToMatrix = (transform) => {
	  if (transform.name === 'matrix') {
	    return transform.data;
	  }
	  switch (transform.name) {
	    case 'translate':
	      // [1, 0, 0, 1, tx, ty]
	      return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
	    case 'scale':
	      // [sx, 0, 0, sy, 0, 0]
	      return [
	        transform.data[0],
	        0,
	        0,
	        transform.data[1] || transform.data[0],
	        0,
	        0,
	      ];
	    case 'rotate':
	      // [cos(a), sin(a), -sin(a), cos(a), x, y]
	      var cos = mth.cos(transform.data[0]),
	        sin = mth.sin(transform.data[0]),
	        cx = transform.data[1] || 0,
	        cy = transform.data[2] || 0;
	      return [
	        cos,
	        sin,
	        -sin,
	        cos,
	        (1 - cos) * cx + sin * cy,
	        (1 - cos) * cy - sin * cx,
	      ];
	    case 'skewX':
	      // [1, 0, tan(a), 1, 0, 0]
	      return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
	    case 'skewY':
	      // [1, tan(a), 0, 1, 0, 0]
	      return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
	    default:
	      throw Error(`Unknown transform ${transform.name}`);
	  }
	};

	/**
	 * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it
	 * by the transformation matrix and use a singular value decomposition to represent in a form
	 * rotate(Î¸)Â·scale(a b)Â·rotate(Ï†). This gives us new ellipse params a, b and Î¸.
	 * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})
	 *
	 * @type {(
	 *   cursor: [x: number, y: number],
	 *   arc: Array<number>,
	 *   transform: Array<number>
	 * ) => Array<number>}
	 */
	_transforms.transformArc = (cursor, arc, transform) => {
	  const x = arc[5] - cursor[0];
	  const y = arc[6] - cursor[1];
	  let a = arc[0];
	  let b = arc[1];
	  const rot = (arc[2] * Math.PI) / 180;
	  const cos = Math.cos(rot);
	  const sin = Math.sin(rot);
	  // skip if radius is 0
	  if (a > 0 && b > 0) {
	    let h =
	      Math.pow(x * cos + y * sin, 2) / (4 * a * a) +
	      Math.pow(y * cos - x * sin, 2) / (4 * b * b);
	    if (h > 1) {
	      h = Math.sqrt(h);
	      a *= h;
	      b *= h;
	    }
	  }
	  const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
	  const m = multiplyTransformMatrices(transform, ellipse);
	  // Decompose the new ellipse matrix
	  const lastCol = m[2] * m[2] + m[3] * m[3];
	  const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
	  const root =
	    Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);

	  if (!root) {
	    // circle
	    arc[0] = arc[1] = Math.sqrt(squareSum / 2);
	    arc[2] = 0;
	  } else {
	    const majorAxisSqr = (squareSum + root) / 2;
	    const minorAxisSqr = (squareSum - root) / 2;
	    const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
	    const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
	    const rowsSum = m[0] * m[2] + m[1] * m[3];
	    const term1 = m[0] * sub + m[2] * rowsSum;
	    const term2 = m[1] * sub + m[3] * rowsSum;
	    arc[0] = Math.sqrt(majorAxisSqr);
	    arc[1] = Math.sqrt(minorAxisSqr);
	    arc[2] =
	      (((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
	        Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) *
	        180) /
	      Math.PI;
	  }

	  if (transform[0] < 0 !== transform[3] < 0) {
	    // Flip the sweep flag if coordinates are being flipped horizontally XOR vertically
	    arc[4] = 1 - arc[4];
	  }

	  return arc;
	};

	/**
	 * Multiply transformation matrices.
	 *
	 * @type {(a: Array<number>, b: Array<number>) => Array<number>}
	 */
	const multiplyTransformMatrices = (a, b) => {
	  return [
	    a[0] * b[0] + a[2] * b[1],
	    a[1] * b[0] + a[3] * b[1],
	    a[0] * b[2] + a[2] * b[3],
	    a[1] * b[2] + a[3] * b[3],
	    a[0] * b[4] + a[2] * b[5] + a[4],
	    a[1] * b[4] + a[3] * b[5] + a[5],
	  ];
	};
	return _transforms;
}

var hasRequired_applyTransforms;

function require_applyTransforms () {
	if (hasRequired_applyTransforms) return _applyTransforms;
	hasRequired_applyTransforms = 1;

	// TODO implement as separate plugin

	const {
	  transformsMultiply,
	  transform2js,
	  transformArc,
	} = require_transforms();
	const { removeLeadingZero } = requireTools();
	const { referencesProps, attrsGroupsDefaults } = require_collections();

	const regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
	const defaultStrokeWidth = attrsGroupsDefaults.presentation['stroke-width'];

	/**
	 * Apply transformation(s) to the Path data.
	 *
	 * @param {Object} elem current element
	 * @param {Array} path input path data
	 * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)
	 * @return {Array} output path data
	 */
	const applyTransforms = (elem, pathData, params) => {
	  // if there are no 'stroke' attr and references to other objects such as
	  // gradiends or clip-path which are also subjects to transform.
	  if (
	    elem.attributes.transform == null ||
	    elem.attributes.transform === '' ||
	    // styles are not considered when applying transform
	    // can be fixed properly with new style engine
	    elem.attributes.style != null ||
	    Object.entries(elem.attributes).some(
	      ([name, value]) =>
	        referencesProps.includes(name) && value.includes('url(')
	    )
	  ) {
	    return;
	  }

	  const matrix = transformsMultiply(transform2js(elem.attributes.transform));
	  const stroke = elem.computedAttr('stroke');
	  const id = elem.computedAttr('id');
	  const transformPrecision = params.transformPrecision;

	  if (stroke && stroke != 'none') {
	    if (
	      !params.applyTransformsStroked ||
	      ((matrix.data[0] != matrix.data[3] ||
	        matrix.data[1] != -matrix.data[2]) &&
	        (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))
	    )
	      return;

	    // "stroke-width" should be inside the part with ID, otherwise it can be overrided in <use>
	    if (id) {
	      let idElem = elem;
	      let hasStrokeWidth = false;

	      do {
	        if (idElem.attributes['stroke-width']) {
	          hasStrokeWidth = true;
	        }
	      } while (
	        idElem.attributes.id !== id &&
	        !hasStrokeWidth &&
	        (idElem = idElem.parentNode)
	      );

	      if (!hasStrokeWidth) return;
	    }

	    const scale = +Math.sqrt(
	      matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]
	    ).toFixed(transformPrecision);

	    if (scale !== 1) {
	      const strokeWidth =
	        elem.computedAttr('stroke-width') || defaultStrokeWidth;

	      if (
	        elem.attributes['vector-effect'] == null ||
	        elem.attributes['vector-effect'] !== 'non-scaling-stroke'
	      ) {
	        if (elem.attributes['stroke-width'] != null) {
	          elem.attributes['stroke-width'] = elem.attributes['stroke-width']
	            .trim()
	            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));
	        } else {
	          elem.attributes['stroke-width'] = strokeWidth.replace(
	            regNumericValues,
	            (num) => removeLeadingZero(num * scale)
	          );
	        }

	        if (elem.attributes['stroke-dashoffset'] != null) {
	          elem.attributes['stroke-dashoffset'] = elem.attributes[
	            'stroke-dashoffset'
	          ]
	            .trim()
	            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));
	        }

	        if (elem.attributes['stroke-dasharray'] != null) {
	          elem.attributes['stroke-dasharray'] = elem.attributes[
	            'stroke-dasharray'
	          ]
	            .trim()
	            .replace(regNumericValues, (num) => removeLeadingZero(num * scale));
	        }
	      }
	    }
	  } else if (id) {
	    // Stroke and stroke-width can be redefined with <use>
	    return;
	  }

	  applyMatrixToPathData(pathData, matrix.data);

	  // remove transform attr
	  delete elem.attributes.transform;

	  return;
	};
	_applyTransforms.applyTransforms = applyTransforms;

	const transformAbsolutePoint = (matrix, x, y) => {
	  const newX = matrix[0] * x + matrix[2] * y + matrix[4];
	  const newY = matrix[1] * x + matrix[3] * y + matrix[5];
	  return [newX, newY];
	};

	const transformRelativePoint = (matrix, x, y) => {
	  const newX = matrix[0] * x + matrix[2] * y;
	  const newY = matrix[1] * x + matrix[3] * y;
	  return [newX, newY];
	};

	const applyMatrixToPathData = (pathData, matrix) => {
	  const start = [0, 0];
	  const cursor = [0, 0];

	  for (const pathItem of pathData) {
	    let { command, args } = pathItem;

	    // moveto (x y)
	    if (command === 'M') {
	      cursor[0] = args[0];
	      cursor[1] = args[1];
	      start[0] = cursor[0];
	      start[1] = cursor[1];
	      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
	      args[0] = x;
	      args[1] = y;
	    }
	    if (command === 'm') {
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	      start[0] = cursor[0];
	      start[1] = cursor[1];
	      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
	      args[0] = x;
	      args[1] = y;
	    }

	    // horizontal lineto (x)
	    // convert to lineto to handle two-dimentional transforms
	    if (command === 'H') {
	      command = 'L';
	      args = [args[0], cursor[1]];
	    }
	    if (command === 'h') {
	      command = 'l';
	      args = [args[0], 0];
	    }

	    // vertical lineto (y)
	    // convert to lineto to handle two-dimentional transforms
	    if (command === 'V') {
	      command = 'L';
	      args = [cursor[0], args[0]];
	    }
	    if (command === 'v') {
	      command = 'l';
	      args = [0, args[0]];
	    }

	    // lineto (x y)
	    if (command === 'L') {
	      cursor[0] = args[0];
	      cursor[1] = args[1];
	      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
	      args[0] = x;
	      args[1] = y;
	    }
	    if (command === 'l') {
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
	      args[0] = x;
	      args[1] = y;
	    }

	    // curveto (x1 y1 x2 y2 x y)
	    if (command === 'C') {
	      cursor[0] = args[4];
	      cursor[1] = args[5];
	      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
	      const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
	      const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
	      args[0] = x1;
	      args[1] = y1;
	      args[2] = x2;
	      args[3] = y2;
	      args[4] = x;
	      args[5] = y;
	    }
	    if (command === 'c') {
	      cursor[0] += args[4];
	      cursor[1] += args[5];
	      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
	      const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
	      const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
	      args[0] = x1;
	      args[1] = y1;
	      args[2] = x2;
	      args[3] = y2;
	      args[4] = x;
	      args[5] = y;
	    }

	    // smooth curveto (x2 y2 x y)
	    if (command === 'S') {
	      cursor[0] = args[2];
	      cursor[1] = args[3];
	      const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
	      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
	      args[0] = x2;
	      args[1] = y2;
	      args[2] = x;
	      args[3] = y;
	    }
	    if (command === 's') {
	      cursor[0] += args[2];
	      cursor[1] += args[3];
	      const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
	      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
	      args[0] = x2;
	      args[1] = y2;
	      args[2] = x;
	      args[3] = y;
	    }

	    // quadratic BÃ©zier curveto (x1 y1 x y)
	    if (command === 'Q') {
	      cursor[0] = args[2];
	      cursor[1] = args[3];
	      const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
	      const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
	      args[0] = x1;
	      args[1] = y1;
	      args[2] = x;
	      args[3] = y;
	    }
	    if (command === 'q') {
	      cursor[0] += args[2];
	      cursor[1] += args[3];
	      const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
	      const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
	      args[0] = x1;
	      args[1] = y1;
	      args[2] = x;
	      args[3] = y;
	    }

	    // smooth quadratic BÃ©zier curveto (x y)
	    if (command === 'T') {
	      cursor[0] = args[0];
	      cursor[1] = args[1];
	      const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
	      args[0] = x;
	      args[1] = y;
	    }
	    if (command === 't') {
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	      const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
	      args[0] = x;
	      args[1] = y;
	    }

	    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
	    if (command === 'A') {
	      transformArc(cursor, args, matrix);
	      cursor[0] = args[5];
	      cursor[1] = args[6];
	      // reduce number of digits in rotation angle
	      if (Math.abs(args[2]) > 80) {
	        const a = args[0];
	        const rotation = args[2];
	        args[0] = args[1];
	        args[1] = a;
	        args[2] = rotation + (rotation > 0 ? -90 : 90);
	      }
	      const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
	      args[5] = x;
	      args[6] = y;
	    }
	    if (command === 'a') {
	      transformArc([0, 0], args, matrix);
	      cursor[0] += args[5];
	      cursor[1] += args[6];
	      // reduce number of digits in rotation angle
	      if (Math.abs(args[2]) > 80) {
	        const a = args[0];
	        const rotation = args[2];
	        args[0] = args[1];
	        args[1] = a;
	        args[2] = rotation + (rotation > 0 ? -90 : 90);
	      }
	      const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
	      args[5] = x;
	      args[6] = y;
	    }

	    // closepath
	    if (command === 'z' || command === 'Z') {
	      cursor[0] = start[0];
	      cursor[1] = start[1];
	    }

	    pathItem.command = command;
	    pathItem.args = args;
	  }
	};
	return _applyTransforms;
}

var hasRequiredConvertPathData;

function requireConvertPathData () {
	if (hasRequiredConvertPathData) return convertPathData;
	hasRequiredConvertPathData = 1;

	const { collectStylesheet, computeStyle } = requireStyle();
	const { pathElems } = require_collections();
	const { path2js, js2path } = require_path();
	const { applyTransforms } = require_applyTransforms();
	const { cleanupOutData } = requireTools();

	convertPathData.name = 'convertPathData';
	convertPathData.type = 'visitor';
	convertPathData.active = true;
	convertPathData.description =
	  'optimizes path data: writes in shorter form, applies transformations';

	convertPathData.params = {
	  applyTransforms: true,
	  applyTransformsStroked: true,
	  makeArcs: {
	    threshold: 2.5, // coefficient of rounding error
	    tolerance: 0.5, // percentage of radius
	  },
	  straightCurves: true,
	  lineShorthands: true,
	  curveSmoothShorthands: true,
	  floatPrecision: 3,
	  transformPrecision: 5,
	  removeUseless: true,
	  collapseRepeated: true,
	  utilizeAbsolute: true,
	  leadingZero: true,
	  negativeExtraSpace: true,
	  noSpaceAfterFlags: false, // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20
	  forceAbsolutePath: false,
	};

	let roundData;
	let precision;
	let error;
	let arcThreshold;
	let arcTolerance;

	/**
	 * Convert absolute Path to relative,
	 * collapse repeated instructions,
	 * detect and convert Lineto shorthands,
	 * remove useless instructions like "l0,0",
	 * trim useless delimiters and leading zeros,
	 * decrease accuracy of floating-point numbers.
	 *
	 * @see https://www.w3.org/TR/SVG11/paths.html#PathData
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	convertPathData.fn = (root, params) => {
	  const stylesheet = collectStylesheet(root);
	  return {
	    element: {
	      enter: (node) => {
	        if (pathElems.includes(node.name) && node.attributes.d != null) {
	          const computedStyle = computeStyle(stylesheet, node);
	          precision = params.floatPrecision;
	          error =
	            precision !== false
	              ? +Math.pow(0.1, precision).toFixed(precision)
	              : 1e-2;
	          roundData = precision > 0 && precision < 20 ? strongRound : round;
	          if (params.makeArcs) {
	            arcThreshold = params.makeArcs.threshold;
	            arcTolerance = params.makeArcs.tolerance;
	          }
	          const hasMarkerMid = computedStyle['marker-mid'] != null;

	          const maybeHasStroke =
	            computedStyle.stroke &&
	            (computedStyle.stroke.type === 'dynamic' ||
	              computedStyle.stroke.value !== 'none');
	          const maybeHasLinecap =
	            computedStyle['stroke-linecap'] &&
	            (computedStyle['stroke-linecap'].type === 'dynamic' ||
	              computedStyle['stroke-linecap'].value !== 'butt');
	          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;

	          var data = path2js(node);

	          // TODO: get rid of functions returns
	          if (data.length) {
	            if (params.applyTransforms) {
	              applyTransforms(node, data, params);
	            }

	            convertToRelative(data);

	            data = filters(data, params, {
	              maybeHasStrokeAndLinecap,
	              hasMarkerMid,
	            });

	            if (params.utilizeAbsolute) {
	              data = convertToMixed(data, params);
	            }

	            js2path(node, data, params);
	          }
	        }
	      },
	    },
	  };
	};

	/**
	 * Convert absolute path data coordinates to relative.
	 *
	 * @param {Array} path input path data
	 * @param {Object} params plugin params
	 * @return {Array} output path data
	 */
	const convertToRelative = (pathData) => {
	  let start = [0, 0];
	  let cursor = [0, 0];
	  let prevCoords = [0, 0];

	  for (let i = 0; i < pathData.length; i += 1) {
	    const pathItem = pathData[i];
	    let { command, args } = pathItem;

	    // moveto (x y)
	    if (command === 'm') {
	      // update start and cursor
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	      start[0] = cursor[0];
	      start[1] = cursor[1];
	    }
	    if (command === 'M') {
	      // M â†’ m
	      // skip first moveto
	      if (i !== 0) {
	        command = 'm';
	      }
	      args[0] -= cursor[0];
	      args[1] -= cursor[1];
	      // update start and cursor
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	      start[0] = cursor[0];
	      start[1] = cursor[1];
	    }

	    // lineto (x y)
	    if (command === 'l') {
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	    }
	    if (command === 'L') {
	      // L â†’ l
	      command = 'l';
	      args[0] -= cursor[0];
	      args[1] -= cursor[1];
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	    }

	    // horizontal lineto (x)
	    if (command === 'h') {
	      cursor[0] += args[0];
	    }
	    if (command === 'H') {
	      // H â†’ h
	      command = 'h';
	      args[0] -= cursor[0];
	      cursor[0] += args[0];
	    }

	    // vertical lineto (y)
	    if (command === 'v') {
	      cursor[1] += args[0];
	    }
	    if (command === 'V') {
	      // V â†’ v
	      command = 'v';
	      args[0] -= cursor[1];
	      cursor[1] += args[0];
	    }

	    // curveto (x1 y1 x2 y2 x y)
	    if (command === 'c') {
	      cursor[0] += args[4];
	      cursor[1] += args[5];
	    }
	    if (command === 'C') {
	      // C â†’ c
	      command = 'c';
	      args[0] -= cursor[0];
	      args[1] -= cursor[1];
	      args[2] -= cursor[0];
	      args[3] -= cursor[1];
	      args[4] -= cursor[0];
	      args[5] -= cursor[1];
	      cursor[0] += args[4];
	      cursor[1] += args[5];
	    }

	    // smooth curveto (x2 y2 x y)
	    if (command === 's') {
	      cursor[0] += args[2];
	      cursor[1] += args[3];
	    }
	    if (command === 'S') {
	      // S â†’ s
	      command = 's';
	      args[0] -= cursor[0];
	      args[1] -= cursor[1];
	      args[2] -= cursor[0];
	      args[3] -= cursor[1];
	      cursor[0] += args[2];
	      cursor[1] += args[3];
	    }

	    // quadratic BÃ©zier curveto (x1 y1 x y)
	    if (command === 'q') {
	      cursor[0] += args[2];
	      cursor[1] += args[3];
	    }
	    if (command === 'Q') {
	      // Q â†’ q
	      command = 'q';
	      args[0] -= cursor[0];
	      args[1] -= cursor[1];
	      args[2] -= cursor[0];
	      args[3] -= cursor[1];
	      cursor[0] += args[2];
	      cursor[1] += args[3];
	    }

	    // smooth quadratic BÃ©zier curveto (x y)
	    if (command === 't') {
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	    }
	    if (command === 'T') {
	      // T â†’ t
	      command = 't';
	      args[0] -= cursor[0];
	      args[1] -= cursor[1];
	      cursor[0] += args[0];
	      cursor[1] += args[1];
	    }

	    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)
	    if (command === 'a') {
	      cursor[0] += args[5];
	      cursor[1] += args[6];
	    }
	    if (command === 'A') {
	      // A â†’ a
	      command = 'a';
	      args[5] -= cursor[0];
	      args[6] -= cursor[1];
	      cursor[0] += args[5];
	      cursor[1] += args[6];
	    }

	    // closepath
	    if (command === 'Z' || command === 'z') {
	      // reset cursor
	      cursor[0] = start[0];
	      cursor[1] = start[1];
	    }

	    pathItem.command = command;
	    pathItem.args = args;
	    // store absolute coordinates for later use
	    // base should preserve reference from other element
	    pathItem.base = prevCoords;
	    pathItem.coords = [cursor[0], cursor[1]];
	    prevCoords = pathItem.coords;
	  }

	  return pathData;
	};

	/**
	 * Main filters loop.
	 *
	 * @param {Array} path input path data
	 * @param {Object} params plugin params
	 * @return {Array} output path data
	 */
	function filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {
	  var stringify = data2Path.bind(null, params),
	    relSubpoint = [0, 0],
	    pathBase = [0, 0],
	    prev = {};

	  path = path.filter(function (item, index, path) {
	    let command = item.command;
	    let data = item.args;
	    let next = path[index + 1];

	    if (command !== 'Z' && command !== 'z') {
	      var sdata = data,
	        circle;

	      if (command === 's') {
	        sdata = [0, 0].concat(data);

	        if (command === 'c' || command === 's') {
	          var pdata = prev.args,
	            n = pdata.length;

	          // (-x, -y) of the prev tangent point relative to the current point
	          sdata[0] = pdata[n - 2] - pdata[n - 4];
	          sdata[1] = pdata[n - 1] - pdata[n - 3];
	        }
	      }

	      // convert curves to arcs if possible
	      if (
	        params.makeArcs &&
	        (command == 'c' || command == 's') &&
	        isConvex(sdata) &&
	        (circle = findCircle(sdata))
	      ) {
	        var r = roundData([circle.radius])[0],
	          angle = findArcAngle(sdata, circle),
	          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
	          arc = {
	            command: 'a',
	            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
	            coords: item.coords.slice(),
	            base: item.base,
	          },
	          output = [arc],
	          // relative coordinates to adjust the found circle
	          relCenter = [
	            circle.center[0] - sdata[4],
	            circle.center[1] - sdata[5],
	          ],
	          relCircle = { center: relCenter, radius: circle.radius },
	          arcCurves = [item],
	          hasPrev = 0,
	          suffix = '',
	          nextLonghand;

	        if (
	          (prev.command == 'c' &&
	            isConvex(prev.args) &&
	            isArcPrev(prev.args, circle)) ||
	          (prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle))
	        ) {
	          arcCurves.unshift(prev);
	          arc.base = prev.base;
	          arc.args[5] = arc.coords[0] - arc.base[0];
	          arc.args[6] = arc.coords[1] - arc.base[1];
	          var prevData = prev.command == 'a' ? prev.sdata : prev.args;
	          var prevAngle = findArcAngle(prevData, {
	            center: [
	              prevData[4] + circle.center[0],
	              prevData[5] + circle.center[1],
	            ],
	            radius: circle.radius,
	          });
	          angle += prevAngle;
	          if (angle > Math.PI) arc.args[3] = 1;
	          hasPrev = 1;
	        }

	        // check if next curves are fitting the arc
	        for (
	          var j = index;
	          (next = path[++j]) && ~'cs'.indexOf(next.command);

	        ) {
	          var nextData = next.args;
	          if (next.command == 's') {
	            nextLonghand = makeLonghand(
	              { command: 's', args: next.args.slice() },
	              path[j - 1].args
	            );
	            nextData = nextLonghand.args;
	            nextLonghand.args = nextData.slice(0, 2);
	            suffix = stringify([nextLonghand]);
	          }
	          if (isConvex(nextData) && isArc(nextData, relCircle)) {
	            angle += findArcAngle(nextData, relCircle);
	            if (angle - 2 * Math.PI > 1e-3) break; // more than 360Â°
	            if (angle > Math.PI) arc.args[3] = 1;
	            arcCurves.push(next);
	            if (2 * Math.PI - angle > 1e-3) {
	              // less than 360Â°
	              arc.coords = next.coords;
	              arc.args[5] = arc.coords[0] - arc.base[0];
	              arc.args[6] = arc.coords[1] - arc.base[1];
	            } else {
	              // full circle, make a half-circle arc and add a second one
	              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
	              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
	              arc.coords = [
	                arc.base[0] + arc.args[5],
	                arc.base[1] + arc.args[6],
	              ];
	              arc = {
	                command: 'a',
	                args: [
	                  r,
	                  r,
	                  0,
	                  0,
	                  sweep,
	                  next.coords[0] - arc.coords[0],
	                  next.coords[1] - arc.coords[1],
	                ],
	                coords: next.coords,
	                base: arc.coords,
	              };
	              output.push(arc);
	              j++;
	              break;
	            }
	            relCenter[0] -= nextData[4];
	            relCenter[1] -= nextData[5];
	          } else break;
	        }

	        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
	          if (path[j] && path[j].command == 's') {
	            makeLonghand(path[j], path[j - 1].args);
	          }
	          if (hasPrev) {
	            var prevArc = output.shift();
	            roundData(prevArc.args);
	            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
	            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
	            prev.command = 'a';
	            prev.args = prevArc.args;
	            item.base = prev.coords = prevArc.coords;
	          }
	          arc = output.shift();
	          if (arcCurves.length == 1) {
	            item.sdata = sdata.slice(); // preserve curve data for future checks
	          } else if (arcCurves.length - 1 - hasPrev > 0) {
	            // filter out consumed next items
	            path.splice.apply(
	              path,
	              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)
	            );
	          }
	          if (!arc) return false;
	          command = 'a';
	          data = arc.args;
	          item.coords = arc.coords;
	        }
	      }

	      // Rounding relative coordinates, taking in account accummulating error
	      // to get closer to absolute coordinates. Sum of rounded value remains same:
	      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2
	      if (precision !== false) {
	        if (
	          command === 'm' ||
	          command === 'l' ||
	          command === 't' ||
	          command === 'q' ||
	          command === 's' ||
	          command === 'c'
	        ) {
	          for (var i = data.length; i--; ) {
	            data[i] += item.base[i % 2] - relSubpoint[i % 2];
	          }
	        } else if (command == 'h') {
	          data[0] += item.base[0] - relSubpoint[0];
	        } else if (command == 'v') {
	          data[0] += item.base[1] - relSubpoint[1];
	        } else if (command == 'a') {
	          data[5] += item.base[0] - relSubpoint[0];
	          data[6] += item.base[1] - relSubpoint[1];
	        }
	        roundData(data);

	        if (command == 'h') relSubpoint[0] += data[0];
	        else if (command == 'v') relSubpoint[1] += data[0];
	        else {
	          relSubpoint[0] += data[data.length - 2];
	          relSubpoint[1] += data[data.length - 1];
	        }
	        roundData(relSubpoint);

	        if (command === 'M' || command === 'm') {
	          pathBase[0] = relSubpoint[0];
	          pathBase[1] = relSubpoint[1];
	        }
	      }

	      // convert straight curves into lines segments
	      if (params.straightCurves) {
	        if (
	          (command === 'c' && isCurveStraightLine(data)) ||
	          (command === 's' && isCurveStraightLine(sdata))
	        ) {
	          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve
	          command = 'l';
	          data = data.slice(-2);
	        } else if (command === 'q' && isCurveStraightLine(data)) {
	          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve
	          command = 'l';
	          data = data.slice(-2);
	        } else if (
	          command === 't' &&
	          prev.command !== 'q' &&
	          prev.command !== 't'
	        ) {
	          command = 'l';
	          data = data.slice(-2);
	        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {
	          command = 'l';
	          data = data.slice(-2);
	        }
	      }

	      // horizontal and vertical line shorthands
	      // l 50 0 â†’ h 50
	      // l 0 50 â†’ v 50
	      if (params.lineShorthands && command === 'l') {
	        if (data[1] === 0) {
	          command = 'h';
	          data.pop();
	        } else if (data[0] === 0) {
	          command = 'v';
	          data.shift();
	        }
	      }

	      // collapse repeated commands
	      // h 20 h 30 -> h 50
	      if (
	        params.collapseRepeated &&
	        hasMarkerMid === false &&
	        (command === 'm' || command === 'h' || command === 'v') &&
	        prev.command &&
	        command == prev.command.toLowerCase() &&
	        ((command != 'h' && command != 'v') ||
	          prev.args[0] >= 0 == data[0] >= 0)
	      ) {
	        prev.args[0] += data[0];
	        if (command != 'h' && command != 'v') {
	          prev.args[1] += data[1];
	        }
	        prev.coords = item.coords;
	        path[index] = prev;
	        return false;
	      }

	      // convert curves into smooth shorthands
	      if (params.curveSmoothShorthands && prev.command) {
	        // curveto
	        if (command === 'c') {
	          // c + c â†’ c + s
	          if (
	            prev.command === 'c' &&
	            data[0] === -(prev.args[2] - prev.args[4]) &&
	            data[1] === -(prev.args[3] - prev.args[5])
	          ) {
	            command = 's';
	            data = data.slice(2);
	          }

	          // s + c â†’ s + s
	          else if (
	            prev.command === 's' &&
	            data[0] === -(prev.args[0] - prev.args[2]) &&
	            data[1] === -(prev.args[1] - prev.args[3])
	          ) {
	            command = 's';
	            data = data.slice(2);
	          }

	          // [^cs] + c â†’ [^cs] + s
	          else if (
	            prev.command !== 'c' &&
	            prev.command !== 's' &&
	            data[0] === 0 &&
	            data[1] === 0
	          ) {
	            command = 's';
	            data = data.slice(2);
	          }
	        }

	        // quadratic BÃ©zier curveto
	        else if (command === 'q') {
	          // q + q â†’ q + t
	          if (
	            prev.command === 'q' &&
	            data[0] === prev.args[2] - prev.args[0] &&
	            data[1] === prev.args[3] - prev.args[1]
	          ) {
	            command = 't';
	            data = data.slice(2);
	          }

	          // t + q â†’ t + t
	          else if (
	            prev.command === 't' &&
	            data[2] === prev.args[0] &&
	            data[3] === prev.args[1]
	          ) {
	            command = 't';
	            data = data.slice(2);
	          }
	        }
	      }

	      // remove useless non-first path segments
	      if (params.removeUseless && !maybeHasStrokeAndLinecap) {
	        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0
	        if (
	          (command === 'l' ||
	            command === 'h' ||
	            command === 'v' ||
	            command === 'q' ||
	            command === 't' ||
	            command === 'c' ||
	            command === 's') &&
	          data.every(function (i) {
	            return i === 0;
	          })
	        ) {
	          path[index] = prev;
	          return false;
	        }

	        // a 25,25 -30 0,1 0,0
	        if (command === 'a' && data[5] === 0 && data[6] === 0) {
	          path[index] = prev;
	          return false;
	        }
	      }

	      item.command = command;
	      item.args = data;

	      prev = item;
	    } else {
	      // z resets coordinates
	      relSubpoint[0] = pathBase[0];
	      relSubpoint[1] = pathBase[1];
	      if (prev.command === 'Z' || prev.command === 'z') return false;
	      prev = item;
	    }

	    return true;
	  });

	  return path;
	}

	/**
	 * Writes data in shortest form using absolute or relative coordinates.
	 *
	 * @param {Array} data input path data
	 * @return {Boolean} output
	 */
	function convertToMixed(path, params) {
	  var prev = path[0];

	  path = path.filter(function (item, index) {
	    if (index == 0) return true;
	    if (item.command === 'Z' || item.command === 'z') {
	      prev = item;
	      return true;
	    }

	    var command = item.command,
	      data = item.args,
	      adata = data.slice();

	    if (
	      command === 'm' ||
	      command === 'l' ||
	      command === 't' ||
	      command === 'q' ||
	      command === 's' ||
	      command === 'c'
	    ) {
	      for (var i = adata.length; i--; ) {
	        adata[i] += item.base[i % 2];
	      }
	    } else if (command == 'h') {
	      adata[0] += item.base[0];
	    } else if (command == 'v') {
	      adata[0] += item.base[1];
	    } else if (command == 'a') {
	      adata[5] += item.base[0];
	      adata[6] += item.base[1];
	    }

	    roundData(adata);

	    var absoluteDataStr = cleanupOutData(adata, params),
	      relativeDataStr = cleanupOutData(data, params);

	    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.
	    // v-20 -> V0
	    // Don't convert if it fits following previous command.
	    // l20 30-10-50 instead of l20 30L20 30
	    if (
	      params.forceAbsolutePath ||
	      (absoluteDataStr.length < relativeDataStr.length &&
	        !(
	          params.negativeExtraSpace &&
	          command == prev.command &&
	          prev.command.charCodeAt(0) > 96 &&
	          absoluteDataStr.length == relativeDataStr.length - 1 &&
	          (data[0] < 0 ||
	            (/^0\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))
	        ))
	    ) {
	      item.command = command.toUpperCase();
	      item.args = adata;
	    }

	    prev = item;

	    return true;
	  });

	  return path;
	}

	/**
	 * Checks if curve is convex. Control points of such a curve must form
	 * a convex quadrilateral with diagonals crosspoint inside of it.
	 *
	 * @param {Array} data input path data
	 * @return {Boolean} output
	 */
	function isConvex(data) {
	  var center = getIntersection([
	    0,
	    0,
	    data[2],
	    data[3],
	    data[0],
	    data[1],
	    data[4],
	    data[5],
	  ]);

	  return (
	    center &&
	    data[2] < center[0] == center[0] < 0 &&
	    data[3] < center[1] == center[1] < 0 &&
	    data[4] < center[0] == center[0] < data[0] &&
	    data[5] < center[1] == center[1] < data[1]
	  );
	}

	/**
	 * Computes lines equations by two points and returns their intersection point.
	 *
	 * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)
	 * @return {Array|undefined} output coordinate of lines' crosspoint
	 */
	function getIntersection(coords) {
	  // Prev line equation parameters.
	  var a1 = coords[1] - coords[3], // y1 - y2
	    b1 = coords[2] - coords[0], // x2 - x1
	    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1
	    // Next line equation parameters
	    a2 = coords[5] - coords[7], // y1 - y2
	    b2 = coords[6] - coords[4], // x2 - x1
	    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1
	    denom = a1 * b2 - a2 * b1;

	  if (!denom) return; // parallel lines havn't an intersection

	  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
	  if (
	    !isNaN(cross[0]) &&
	    !isNaN(cross[1]) &&
	    isFinite(cross[0]) &&
	    isFinite(cross[1])
	  ) {
	    return cross;
	  }
	}

	/**
	 * Decrease accuracy of floating-point numbers
	 * in path data keeping a specified number of decimals.
	 * Smart rounds values like 2.3491 to 2.35 instead of 2.349.
	 * Doesn't apply "smartness" if the number precision fits already.
	 *
	 * @param {Array} data input data array
	 * @return {Array} output data array
	 */
	function strongRound(data) {
	  for (var i = data.length; i-- > 0; ) {
	    if (data[i].toFixed(precision) != data[i]) {
	      var rounded = +data[i].toFixed(precision - 1);
	      data[i] =
	        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error
	          ? +data[i].toFixed(precision)
	          : rounded;
	    }
	  }
	  return data;
	}

	/**
	 * Simple rounding function if precision is 0.
	 *
	 * @param {Array} data input data array
	 * @return {Array} output data array
	 */
	function round(data) {
	  for (var i = data.length; i-- > 0; ) {
	    data[i] = Math.round(data[i]);
	  }
	  return data;
	}

	/**
	 * Checks if a curve is a straight line by measuring distance
	 * from middle points to the line formed by end points.
	 *
	 * @param {Array} xs array of curve points x-coordinates
	 * @param {Array} ys array of curve points y-coordinates
	 * @return {Boolean}
	 */

	function isCurveStraightLine(data) {
	  // Get line equation aÂ·x + bÂ·y + c = 0 coefficients a, b (c = 0) by start and end points.
	  var i = data.length - 2,
	    a = -data[i + 1], // y1 âˆ’ y2 (y1 = 0)
	    b = data[i], // x2 âˆ’ x1 (x1 = 0)
	    d = 1 / (a * a + b * b); // same part for all points

	  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case

	  // Distance from point (x0, y0) to the line is sqrt((c âˆ’ aÂ·x0 âˆ’ bÂ·y0)Â² / (aÂ² + bÂ²))
	  while ((i -= 2) >= 0) {
	    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
	      return false;
	  }

	  return true;
	}

	/**
	 * Converts next curve from shorthand to full form using the current curve data.
	 *
	 * @param {Object} item curve to convert
	 * @param {Array} data current curve data
	 */

	function makeLonghand(item, data) {
	  switch (item.command) {
	    case 's':
	      item.command = 'c';
	      break;
	    case 't':
	      item.command = 'q';
	      break;
	  }
	  item.args.unshift(
	    data[data.length - 2] - data[data.length - 4],
	    data[data.length - 1] - data[data.length - 3]
	  );
	  return item;
	}

	/**
	 * Returns distance between two points
	 *
	 * @param {Array} point1 first point coordinates
	 * @param {Array} point2 second point coordinates
	 * @return {Number} distance
	 */

	function getDistance(point1, point2) {
	  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
	}

	/**
	 * Returns coordinates of the curve point corresponding to the certain t
	 * aÂ·(1 - t)Â³Â·p1 + bÂ·(1 - t)Â²Â·tÂ·p2 + cÂ·(1 - t)Â·tÂ²Â·p3 + dÂ·tÂ³Â·p4,
	 * where pN are control points and p1 is zero due to relative coordinates.
	 *
	 * @param {Array} curve array of curve points coordinates
	 * @param {Number} t parametric position from 0 to 1
	 * @return {Array} Point coordinates
	 */

	function getCubicBezierPoint(curve, t) {
	  var sqrT = t * t,
	    cubT = sqrT * t,
	    mt = 1 - t,
	    sqrMt = mt * mt;

	  return [
	    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
	    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],
	  ];
	}

	/**
	 * Finds circle by 3 points of the curve and checks if the curve fits the found circle.
	 *
	 * @param {Array} curve
	 * @return {Object|undefined} circle
	 */

	function findCircle(curve) {
	  var midPoint = getCubicBezierPoint(curve, 1 / 2),
	    m1 = [midPoint[0] / 2, midPoint[1] / 2],
	    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
	    center = getIntersection([
	      m1[0],
	      m1[1],
	      m1[0] + m1[1],
	      m1[1] - m1[0],
	      m2[0],
	      m2[1],
	      m2[0] + (m2[1] - midPoint[1]),
	      m2[1] - (m2[0] - midPoint[0]),
	    ]),
	    radius = center && getDistance([0, 0], center),
	    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);

	  if (
	    center &&
	    radius < 1e15 &&
	    [1 / 4, 3 / 4].every(function (point) {
	      return (
	        Math.abs(
	          getDistance(getCubicBezierPoint(curve, point), center) - radius
	        ) <= tolerance
	      );
	    })
	  )
	    return { center: center, radius: radius };
	}

	/**
	 * Checks if a curve fits the given circle.
	 *
	 * @param {Object} circle
	 * @param {Array} curve
	 * @return {Boolean}
	 */

	function isArc(curve, circle) {
	  var tolerance = Math.min(
	    arcThreshold * error,
	    (arcTolerance * circle.radius) / 100
	  );

	  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {
	    return (
	      Math.abs(
	        getDistance(getCubicBezierPoint(curve, point), circle.center) -
	          circle.radius
	      ) <= tolerance
	    );
	  });
	}

	/**
	 * Checks if a previous curve fits the given circle.
	 *
	 * @param {Object} circle
	 * @param {Array} curve
	 * @return {Boolean}
	 */

	function isArcPrev(curve, circle) {
	  return isArc(curve, {
	    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
	    radius: circle.radius,
	  });
	}

	/**
	 * Finds angle of a curve fitting the given arc.

	 * @param {Array} curve
	 * @param {Object} relCircle
	 * @return {Number} angle
	 */

	function findArcAngle(curve, relCircle) {
	  var x1 = -relCircle.center[0],
	    y1 = -relCircle.center[1],
	    x2 = curve[4] - relCircle.center[0],
	    y2 = curve[5] - relCircle.center[1];

	  return Math.acos(
	    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
	  );
	}

	/**
	 * Converts given path data to string.
	 *
	 * @param {Object} params
	 * @param {Array} pathData
	 * @return {String}
	 */

	function data2Path(params, pathData) {
	  return pathData.reduce(function (pathString, item) {
	    var strData = '';
	    if (item.args) {
	      strData = cleanupOutData(roundData(item.args.slice()), params);
	    }
	    return pathString + item.command + strData;
	  }, '');
	}
	return convertPathData;
}

var convertTransform = {};

var hasRequiredConvertTransform;

function requireConvertTransform () {
	if (hasRequiredConvertTransform) return convertTransform;
	hasRequiredConvertTransform = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 */

	const { cleanupOutData } = requireTools();
	const {
	  transform2js,
	  transformsMultiply,
	  matrixToTransform,
	} = require_transforms();

	convertTransform.type = 'visitor';
	convertTransform.name = 'convertTransform';
	convertTransform.active = true;
	convertTransform.description = 'collapses multiple transformations and optimizes it';

	/**
	 * Convert matrices to the short aliases,
	 * convert long translate, scale or rotate transform notations to the shorts ones,
	 * convert transforms to the matrices and multiply them all into one,
	 * remove useless transforms.
	 *
	 * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   convertToShorts?: boolean,
	 *   degPrecision?: number,
	 *   floatPrecision?: number,
	 *   transformPrecision?: number,
	 *   matrixToTransform?: boolean,
	 *   shortTranslate?: boolean,
	 *   shortScale?: boolean,
	 *   shortRotate?: boolean,
	 *   removeUseless?: boolean,
	 *   collapseIntoOne?: boolean,
	 *   leadingZero?: boolean,
	 *   negativeExtraSpace?: boolean,
	 * }>}
	 */
	convertTransform.fn = (_root, params) => {
	  const {
	    convertToShorts = true,
	    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default
	    degPrecision,
	    floatPrecision = 3,
	    transformPrecision = 5,
	    matrixToTransform = true,
	    shortTranslate = true,
	    shortScale = true,
	    shortRotate = true,
	    removeUseless = true,
	    collapseIntoOne = true,
	    leadingZero = true,
	    negativeExtraSpace = false,
	  } = params;
	  const newParams = {
	    convertToShorts,
	    degPrecision,
	    floatPrecision,
	    transformPrecision,
	    matrixToTransform,
	    shortTranslate,
	    shortScale,
	    shortRotate,
	    removeUseless,
	    collapseIntoOne,
	    leadingZero,
	    negativeExtraSpace,
	  };
	  return {
	    element: {
	      enter: (node) => {
	        // transform
	        if (node.attributes.transform != null) {
	          convertTransform$1(node, 'transform', newParams);
	        }
	        // gradientTransform
	        if (node.attributes.gradientTransform != null) {
	          convertTransform$1(node, 'gradientTransform', newParams);
	        }
	        // patternTransform
	        if (node.attributes.patternTransform != null) {
	          convertTransform$1(node, 'patternTransform', newParams);
	        }
	      },
	    },
	  };
	};

	/**
	 * @typedef {{
	 *   convertToShorts: boolean,
	 *   degPrecision?: number,
	 *   floatPrecision: number,
	 *   transformPrecision: number,
	 *   matrixToTransform: boolean,
	 *   shortTranslate: boolean,
	 *   shortScale: boolean,
	 *   shortRotate: boolean,
	 *   removeUseless: boolean,
	 *   collapseIntoOne: boolean,
	 *   leadingZero: boolean,
	 *   negativeExtraSpace: boolean,
	 * }} TransformParams
	 */

	/**
	 * @typedef {{ name: string, data: Array<number> }} TransformItem
	 */

	/**
	 * Main function.
	 *
	 * @type {(item: XastElement, attrName: string, params: TransformParams) => void}
	 */
	const convertTransform$1 = (item, attrName, params) => {
	  let data = transform2js(item.attributes[attrName]);
	  params = definePrecision(data, params);

	  if (params.collapseIntoOne && data.length > 1) {
	    data = [transformsMultiply(data)];
	  }

	  if (params.convertToShorts) {
	    data = convertToShorts(data, params);
	  } else {
	    data.forEach((item) => roundTransform(item, params));
	  }

	  if (params.removeUseless) {
	    data = removeUseless(data);
	  }

	  if (data.length) {
	    item.attributes[attrName] = js2transform(data, params);
	  } else {
	    delete item.attributes[attrName];
	  }
	};

	/**
	 * Defines precision to work with certain parts.
	 * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),
	 * floatPrecision - for translate including two last matrix and rotate parameters,
	 * degPrecision - for rotate and skew. By default it's equal to (rougly)
	 * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.
	 *
	 * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}
	 *
	 * clone params so it don't affect other elements transformations.
	 */
	const definePrecision = (data, { ...newParams }) => {
	  const matrixData = [];
	  for (const item of data) {
	    if (item.name == 'matrix') {
	      matrixData.push(...item.data.slice(0, 4));
	    }
	  }
	  let significantDigits = newParams.transformPrecision;
	  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
	  if (matrixData.length) {
	    newParams.transformPrecision = Math.min(
	      newParams.transformPrecision,
	      Math.max.apply(Math, matrixData.map(floatDigits)) ||
	        newParams.transformPrecision
	    );
	    significantDigits = Math.max.apply(
	      Math,
	      matrixData.map(
	        (n) => n.toString().replace(/\D+/g, '').length // Number of digits in a number. 123.45 â†’ 5
	      )
	    );
	  }
	  // No sense in angle precision more then number of significant digits in matrix.
	  if (newParams.degPrecision == null) {
	    newParams.degPrecision = Math.max(
	      0,
	      Math.min(newParams.floatPrecision, significantDigits - 2)
	    );
	  }
	  return newParams;
	};

	/**
	 * @type {(data: Array<number>, params: TransformParams) => Array<number>}
	 */
	const degRound = (data, params) => {
	  if (
	    params.degPrecision != null &&
	    params.degPrecision >= 1 &&
	    params.floatPrecision < 20
	  ) {
	    return smartRound(params.degPrecision, data);
	  } else {
	    return round(data);
	  }
	};
	/**
	 * @type {(data: Array<number>, params: TransformParams) => Array<number>}
	 */
	const floatRound = (data, params) => {
	  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
	    return smartRound(params.floatPrecision, data);
	  } else {
	    return round(data);
	  }
	};

	/**
	 * @type {(data: Array<number>, params: TransformParams) => Array<number>}
	 */
	const transformRound = (data, params) => {
	  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
	    return smartRound(params.transformPrecision, data);
	  } else {
	    return round(data);
	  }
	};

	/**
	 * Returns number of digits after the point. 0.125 â†’ 3
	 *
	 * @type {(n: number) => number}
	 */
	const floatDigits = (n) => {
	  const str = n.toString();
	  return str.slice(str.indexOf('.')).length - 1;
	};

	/**
	 * Convert transforms to the shorthand alternatives.
	 *
	 * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}
	 */
	const convertToShorts = (transforms, params) => {
	  for (var i = 0; i < transforms.length; i++) {
	    var transform = transforms[i];

	    // convert matrix to the short aliases
	    if (params.matrixToTransform && transform.name === 'matrix') {
	      var decomposed = matrixToTransform(transform, params);
	      if (
	        js2transform(decomposed, params).length <=
	        js2transform([transform], params).length
	      ) {
	        transforms.splice(i, 1, ...decomposed);
	      }
	      transform = transforms[i];
	    }

	    // fixed-point numbers
	    // 12.754997 â†’ 12.755
	    roundTransform(transform, params);

	    // convert long translate transform notation to the shorts one
	    // translate(10 0) â†’ translate(10)
	    if (
	      params.shortTranslate &&
	      transform.name === 'translate' &&
	      transform.data.length === 2 &&
	      !transform.data[1]
	    ) {
	      transform.data.pop();
	    }

	    // convert long scale transform notation to the shorts one
	    // scale(2 2) â†’ scale(2)
	    if (
	      params.shortScale &&
	      transform.name === 'scale' &&
	      transform.data.length === 2 &&
	      transform.data[0] === transform.data[1]
	    ) {
	      transform.data.pop();
	    }

	    // convert long rotate transform notation to the short one
	    // translate(cx cy) rotate(a) translate(-cx -cy) â†’ rotate(a cx cy)
	    if (
	      params.shortRotate &&
	      transforms[i - 2] &&
	      transforms[i - 2].name === 'translate' &&
	      transforms[i - 1].name === 'rotate' &&
	      transforms[i].name === 'translate' &&
	      transforms[i - 2].data[0] === -transforms[i].data[0] &&
	      transforms[i - 2].data[1] === -transforms[i].data[1]
	    ) {
	      transforms.splice(i - 2, 3, {
	        name: 'rotate',
	        data: [
	          transforms[i - 1].data[0],
	          transforms[i - 2].data[0],
	          transforms[i - 2].data[1],
	        ],
	      });

	      // splice compensation
	      i -= 2;
	    }
	  }

	  return transforms;
	};

	/**
	 * Remove useless transforms.
	 *
	 * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}
	 */
	const removeUseless = (transforms) => {
	  return transforms.filter((transform) => {
	    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)
	    if (
	      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&
	        (transform.data.length == 1 || transform.name == 'rotate') &&
	        !transform.data[0]) ||
	      // translate(0, 0)
	      (transform.name == 'translate' &&
	        !transform.data[0] &&
	        !transform.data[1]) ||
	      // scale(1)
	      (transform.name == 'scale' &&
	        transform.data[0] == 1 &&
	        (transform.data.length < 2 || transform.data[1] == 1)) ||
	      // matrix(1 0 0 1 0 0)
	      (transform.name == 'matrix' &&
	        transform.data[0] == 1 &&
	        transform.data[3] == 1 &&
	        !(
	          transform.data[1] ||
	          transform.data[2] ||
	          transform.data[4] ||
	          transform.data[5]
	        ))
	    ) {
	      return false;
	    }

	    return true;
	  });
	};

	/**
	 * Convert transforms JS representation to string.
	 *
	 * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}
	 */
	const js2transform = (transformJS, params) => {
	  var transformString = '';

	  // collect output value string
	  transformJS.forEach((transform) => {
	    roundTransform(transform, params);
	    transformString +=
	      (transformString && ' ') +
	      transform.name +
	      '(' +
	      cleanupOutData(transform.data, params) +
	      ')';
	  });

	  return transformString;
	};

	/**
	 * @type {(transform: TransformItem, params: TransformParams) => TransformItem}
	 */
	const roundTransform = (transform, params) => {
	  switch (transform.name) {
	    case 'translate':
	      transform.data = floatRound(transform.data, params);
	      break;
	    case 'rotate':
	      transform.data = [
	        ...degRound(transform.data.slice(0, 1), params),
	        ...floatRound(transform.data.slice(1), params),
	      ];
	      break;
	    case 'skewX':
	    case 'skewY':
	      transform.data = degRound(transform.data, params);
	      break;
	    case 'scale':
	      transform.data = transformRound(transform.data, params);
	      break;
	    case 'matrix':
	      transform.data = [
	        ...transformRound(transform.data.slice(0, 4), params),
	        ...floatRound(transform.data.slice(4), params),
	      ];
	      break;
	  }
	  return transform;
	};

	/**
	 * Rounds numbers in array.
	 *
	 * @type {(data: Array<number>) => Array<number>}
	 */
	const round = (data) => {
	  return data.map(Math.round);
	};

	/**
	 * Decrease accuracy of floating-point numbers
	 * in transforms keeping a specified number of decimals.
	 * Smart rounds values like 2.349 to 2.35.
	 *
	 * @type {(precision: number, data: Array<number>) => Array<number>}
	 */
	const smartRound = (precision, data) => {
	  for (
	    var i = data.length,
	      tolerance = +Math.pow(0.1, precision).toFixed(precision);
	    i--;

	  ) {
	    if (Number(data[i].toFixed(precision)) !== data[i]) {
	      var rounded = +data[i].toFixed(precision - 1);
	      data[i] =
	        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance
	          ? +data[i].toFixed(precision)
	          : rounded;
	    }
	  }
	  return data;
	};
	return convertTransform;
}

var removeEmptyAttrs = {};

var hasRequiredRemoveEmptyAttrs;

function requireRemoveEmptyAttrs () {
	if (hasRequiredRemoveEmptyAttrs) return removeEmptyAttrs;
	hasRequiredRemoveEmptyAttrs = 1;

	const { attrsGroups } = require_collections();

	removeEmptyAttrs.type = 'visitor';
	removeEmptyAttrs.name = 'removeEmptyAttrs';
	removeEmptyAttrs.active = true;
	removeEmptyAttrs.description = 'removes empty attributes';

	/**
	 * Remove attributes with empty values.
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeEmptyAttrs.fn = () => {
	  return {
	    element: {
	      enter: (node) => {
	        for (const [name, value] of Object.entries(node.attributes)) {
	          if (
	            value === '' &&
	            // empty conditional processing attributes prevents elements from rendering
	            attrsGroups.conditionalProcessing.includes(name) === false
	          ) {
	            delete node.attributes[name];
	          }
	        }
	      },
	    },
	  };
	};
	return removeEmptyAttrs;
}

var removeEmptyContainers = {};

var hasRequiredRemoveEmptyContainers;

function requireRemoveEmptyContainers () {
	if (hasRequiredRemoveEmptyContainers) return removeEmptyContainers;
	hasRequiredRemoveEmptyContainers = 1;

	const { detachNodeFromParent } = requireXast();
	const { elemsGroups } = require_collections();

	removeEmptyContainers.type = 'visitor';
	removeEmptyContainers.name = 'removeEmptyContainers';
	removeEmptyContainers.active = true;
	removeEmptyContainers.description = 'removes empty container elements';

	/**
	 * Remove empty containers.
	 *
	 * @see https://www.w3.org/TR/SVG11/intro.html#TermContainerElement
	 *
	 * @example
	 * <defs/>
	 *
	 * @example
	 * <g><marker><a/></marker></g>
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeEmptyContainers.fn = () => {
	  return {
	    element: {
	      exit: (node, parentNode) => {
	        // remove only empty non-svg containers
	        if (
	          node.name === 'svg' ||
	          elemsGroups.container.includes(node.name) === false ||
	          node.children.length !== 0
	        ) {
	          return;
	        }
	        // empty patterns may contain reusable configuration
	        if (
	          node.name === 'pattern' &&
	          Object.keys(node.attributes).length !== 0
	        ) {
	          return;
	        }
	        // The <g> may not have content, but the filter may cause a rectangle
	        // to be created and filled with pattern.
	        if (node.name === 'g' && node.attributes.filter != null) {
	          return;
	        }
	        // empty <mask> hides masked element
	        if (node.name === 'mask' && node.attributes.id != null) {
	          return;
	        }
	        detachNodeFromParent(node, parentNode);
	      },
	    },
	  };
	};
	return removeEmptyContainers;
}

var mergePaths = {};

var hasRequiredMergePaths;

function requireMergePaths () {
	if (hasRequiredMergePaths) return mergePaths;
	hasRequiredMergePaths = 1;

	const { detachNodeFromParent } = requireXast();
	const { collectStylesheet, computeStyle } = requireStyle();
	const { path2js, js2path, intersects } = require_path();

	mergePaths.type = 'visitor';
	mergePaths.name = 'mergePaths';
	mergePaths.active = true;
	mergePaths.description = 'merges multiple paths in one if possible';

	/**
	 * Merge multiple Paths into one.
	 *
	 * @author Kir Belevich, Lev Solntsev
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   force?: boolean,
	 *   floatPrecision?: number,
	 *   noSpaceAfterFlags?: boolean
	 * }>}
	 */
	mergePaths.fn = (root, params) => {
	  const {
	    force = false,
	    floatPrecision,
	    noSpaceAfterFlags = false, // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20
	  } = params;
	  const stylesheet = collectStylesheet(root);

	  return {
	    element: {
	      enter: (node) => {
	        let prevChild = null;

	        for (const child of node.children) {
	          // skip if previous element is not path or contains animation elements
	          if (
	            prevChild == null ||
	            prevChild.type !== 'element' ||
	            prevChild.name !== 'path' ||
	            prevChild.children.length !== 0 ||
	            prevChild.attributes.d == null
	          ) {
	            prevChild = child;
	            continue;
	          }

	          // skip if element is not path or contains animation elements
	          if (
	            child.type !== 'element' ||
	            child.name !== 'path' ||
	            child.children.length !== 0 ||
	            child.attributes.d == null
	          ) {
	            prevChild = child;
	            continue;
	          }

	          // preserve paths with markers
	          const computedStyle = computeStyle(stylesheet, child);
	          if (
	            computedStyle['marker-start'] ||
	            computedStyle['marker-mid'] ||
	            computedStyle['marker-end']
	          ) {
	            prevChild = child;
	            continue;
	          }

	          const prevChildAttrs = Object.keys(prevChild.attributes);
	          const childAttrs = Object.keys(child.attributes);
	          let attributesAreEqual = prevChildAttrs.length === childAttrs.length;
	          for (const name of childAttrs) {
	            if (name !== 'd') {
	              if (
	                prevChild.attributes[name] == null ||
	                prevChild.attributes[name] !== child.attributes[name]
	              ) {
	                attributesAreEqual = false;
	              }
	            }
	          }
	          const prevPathJS = path2js(prevChild);
	          const curPathJS = path2js(child);

	          if (
	            attributesAreEqual &&
	            (force || !intersects(prevPathJS, curPathJS))
	          ) {
	            js2path(prevChild, prevPathJS.concat(curPathJS), {
	              floatPrecision,
	              noSpaceAfterFlags,
	            });
	            detachNodeFromParent(child, node);
	            continue;
	          }

	          prevChild = child;
	        }
	      },
	    },
	  };
	};
	return mergePaths;
}

var removeUnusedNS = {};

var hasRequiredRemoveUnusedNS;

function requireRemoveUnusedNS () {
	if (hasRequiredRemoveUnusedNS) return removeUnusedNS;
	hasRequiredRemoveUnusedNS = 1;

	removeUnusedNS.type = 'visitor';
	removeUnusedNS.name = 'removeUnusedNS';
	removeUnusedNS.active = true;
	removeUnusedNS.description = 'removes unused namespaces declaration';

	/**
	 * Remove unused namespaces declaration from svg element
	 * which are not used in elements or attributes
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeUnusedNS.fn = () => {
	  /**
	   * @type {Set<string>}
	   */
	  const unusedNamespaces = new Set();
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // collect all namespaces from svg element
	        // (such as xmlns:xlink="http://www.w3.org/1999/xlink")
	        if (node.name === 'svg' && parentNode.type === 'root') {
	          for (const name of Object.keys(node.attributes)) {
	            if (name.startsWith('xmlns:')) {
	              const local = name.slice('xmlns:'.length);
	              unusedNamespaces.add(local);
	            }
	          }
	        }
	        if (unusedNamespaces.size !== 0) {
	          // preserve namespace used in nested elements names
	          if (node.name.includes(':')) {
	            const [ns] = node.name.split(':');
	            if (unusedNamespaces.has(ns)) {
	              unusedNamespaces.delete(ns);
	            }
	          }
	          // preserve namespace used in nested elements attributes
	          for (const name of Object.keys(node.attributes)) {
	            if (name.includes(':')) {
	              const [ns] = name.split(':');
	              unusedNamespaces.delete(ns);
	            }
	          }
	        }
	      },
	      exit: (node, parentNode) => {
	        // remove unused namespace attributes from svg element
	        if (node.name === 'svg' && parentNode.type === 'root') {
	          for (const name of unusedNamespaces) {
	            delete node.attributes[`xmlns:${name}`];
	          }
	        }
	      },
	    },
	  };
	};
	return removeUnusedNS;
}

var sortDefsChildren = {};

var hasRequiredSortDefsChildren;

function requireSortDefsChildren () {
	if (hasRequiredSortDefsChildren) return sortDefsChildren;
	hasRequiredSortDefsChildren = 1;

	sortDefsChildren.type = 'visitor';
	sortDefsChildren.name = 'sortDefsChildren';
	sortDefsChildren.active = true;
	sortDefsChildren.description = 'Sorts children of <defs> to improve compression';

	/**
	 * Sorts children of defs in order to improve compression.
	 * Sorted first by frequency then by element name length then by element name (to ensure grouping).
	 *
	 * @author David Leston
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	sortDefsChildren.fn = () => {
	  return {
	    element: {
	      enter: (node) => {
	        if (node.name === 'defs') {
	          /**
	           * @type {Map<string, number>}
	           */
	          const frequencies = new Map();
	          for (const child of node.children) {
	            if (child.type === 'element') {
	              const frequency = frequencies.get(child.name);
	              if (frequency == null) {
	                frequencies.set(child.name, 1);
	              } else {
	                frequencies.set(child.name, frequency + 1);
	              }
	            }
	          }
	          node.children.sort((a, b) => {
	            if (a.type !== 'element' || b.type !== 'element') {
	              return 0;
	            }
	            const aFrequency = frequencies.get(a.name);
	            const bFrequency = frequencies.get(b.name);
	            if (aFrequency != null && bFrequency != null) {
	              const frequencyComparison = bFrequency - aFrequency;
	              if (frequencyComparison !== 0) {
	                return frequencyComparison;
	              }
	            }
	            const lengthComparison = b.name.length - a.name.length;
	            if (lengthComparison !== 0) {
	              return lengthComparison;
	            }
	            if (a.name !== b.name) {
	              return a.name > b.name ? -1 : 1;
	            }
	            return 0;
	          });
	        }
	      },
	    },
	  };
	};
	return sortDefsChildren;
}

var removeTitle = {};

var hasRequiredRemoveTitle;

function requireRemoveTitle () {
	if (hasRequiredRemoveTitle) return removeTitle;
	hasRequiredRemoveTitle = 1;

	const { detachNodeFromParent } = requireXast();

	removeTitle.name = 'removeTitle';
	removeTitle.type = 'visitor';
	removeTitle.active = true;
	removeTitle.description = 'removes <title>';

	/**
	 * Remove <title>.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title
	 *
	 * @author Igor Kalashnikov
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeTitle.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'title') {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeTitle;
}

var removeDesc = {};

var hasRequiredRemoveDesc;

function requireRemoveDesc () {
	if (hasRequiredRemoveDesc) return removeDesc;
	hasRequiredRemoveDesc = 1;

	const { detachNodeFromParent } = requireXast();

	removeDesc.name = 'removeDesc';
	removeDesc.type = 'visitor';
	removeDesc.active = true;
	removeDesc.description = 'removes <desc>';

	const standardDescs = /^(Created with|Created using)/;

	/**
	 * Removes <desc>.
	 * Removes only standard editors content or empty elements 'cause it can be used for accessibility.
	 * Enable parameter 'removeAny' to remove any description.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/desc
	 *
	 * @author Daniel Wabyick
	 *
	 * @type {import('../lib/types').Plugin<{ removeAny?: boolean }>}
	 */
	removeDesc.fn = (root, params) => {
	  const { removeAny = true } = params;
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'desc') {
	          if (
	            removeAny ||
	            node.children.length === 0 ||
	            (node.children[0].type === 'text' &&
	              standardDescs.test(node.children[0].value))
	          ) {
	            detachNodeFromParent(node, parentNode);
	          }
	        }
	      },
	    },
	  };
	};
	return removeDesc;
}

var presetDefault_1;
var hasRequiredPresetDefault;

function requirePresetDefault () {
	if (hasRequiredPresetDefault) return presetDefault_1;
	hasRequiredPresetDefault = 1;

	const { createPreset } = requirePlugins$1();

	const removeDoctype = requireRemoveDoctype();
	const removeXMLProcInst = requireRemoveXMLProcInst();
	const removeComments = requireRemoveComments();
	const removeMetadata = requireRemoveMetadata();
	const removeEditorsNSData = requireRemoveEditorsNSData();
	const cleanupAttrs = requireCleanupAttrs();
	const mergeStyles = requireMergeStyles();
	const inlineStyles = requireInlineStyles();
	const minifyStyles = requireMinifyStyles();
	const cleanupIDs = requireCleanupIDs();
	const removeUselessDefs = requireRemoveUselessDefs();
	const cleanupNumericValues = requireCleanupNumericValues();
	const convertColors = requireConvertColors();
	const removeUnknownsAndDefaults = requireRemoveUnknownsAndDefaults();
	const removeNonInheritableGroupAttrs = requireRemoveNonInheritableGroupAttrs();
	const removeUselessStrokeAndFill = requireRemoveUselessStrokeAndFill();
	const removeViewBox = requireRemoveViewBox();
	const cleanupEnableBackground = requireCleanupEnableBackground();
	const removeHiddenElems = requireRemoveHiddenElems();
	const removeEmptyText = requireRemoveEmptyText();
	const convertShapeToPath = requireConvertShapeToPath();
	const convertEllipseToCircle = requireConvertEllipseToCircle();
	const moveElemsAttrsToGroup = requireMoveElemsAttrsToGroup();
	const moveGroupAttrsToElems = requireMoveGroupAttrsToElems();
	const collapseGroups = requireCollapseGroups();
	const convertPathData = requireConvertPathData();
	const convertTransform = requireConvertTransform();
	const removeEmptyAttrs = requireRemoveEmptyAttrs();
	const removeEmptyContainers = requireRemoveEmptyContainers();
	const mergePaths = requireMergePaths();
	const removeUnusedNS = requireRemoveUnusedNS();
	const sortDefsChildren = requireSortDefsChildren();
	const removeTitle = requireRemoveTitle();
	const removeDesc = requireRemoveDesc();

	const presetDefault = createPreset({
	  name: 'presetDefault',
	  plugins: [
	    removeDoctype,
	    removeXMLProcInst,
	    removeComments,
	    removeMetadata,
	    removeEditorsNSData,
	    cleanupAttrs,
	    mergeStyles,
	    inlineStyles,
	    minifyStyles,
	    cleanupIDs,
	    removeUselessDefs,
	    cleanupNumericValues,
	    convertColors,
	    removeUnknownsAndDefaults,
	    removeNonInheritableGroupAttrs,
	    removeUselessStrokeAndFill,
	    removeViewBox,
	    cleanupEnableBackground,
	    removeHiddenElems,
	    removeEmptyText,
	    convertShapeToPath,
	    convertEllipseToCircle,
	    moveElemsAttrsToGroup,
	    moveGroupAttrsToElems,
	    collapseGroups,
	    convertPathData,
	    convertTransform,
	    removeEmptyAttrs,
	    removeEmptyContainers,
	    mergePaths,
	    removeUnusedNS,
	    sortDefsChildren,
	    removeTitle,
	    removeDesc,
	  ],
	});

	presetDefault_1 = presetDefault;
	return presetDefault_1;
}

var addAttributesToSVGElement = {};

var hasRequiredAddAttributesToSVGElement;

function requireAddAttributesToSVGElement () {
	if (hasRequiredAddAttributesToSVGElement) return addAttributesToSVGElement;
	hasRequiredAddAttributesToSVGElement = 1;

	addAttributesToSVGElement.name = 'addAttributesToSVGElement';
	addAttributesToSVGElement.type = 'visitor';
	addAttributesToSVGElement.active = false;
	addAttributesToSVGElement.description = 'adds attributes to an outer <svg> element';

	var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;

	/**
	 * Add attributes to an outer <svg> element. Example config:
	 *
	 * @author April Arcus
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   attribute?: string | Record<string, null | string>,
	 *   attributes?: Array<string | Record<string, null | string>>
	 * }>}
	 */
	addAttributesToSVGElement.fn = (root, params) => {
	  if (!Array.isArray(params.attributes) && !params.attribute) {
	    console.error(ENOCLS);
	    return null;
	  }
	  const attributes = params.attributes || [params.attribute];
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'svg' && parentNode.type === 'root') {
	          for (const attribute of attributes) {
	            if (typeof attribute === 'string') {
	              if (node.attributes[attribute] == null) {
	                // @ts-ignore disallow explicit nullable attribute value
	                node.attributes[attribute] = undefined;
	              }
	            }
	            if (typeof attribute === 'object') {
	              for (const key of Object.keys(attribute)) {
	                if (node.attributes[key] == null) {
	                  // @ts-ignore disallow explicit nullable attribute value
	                  node.attributes[key] = attribute[key];
	                }
	              }
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return addAttributesToSVGElement;
}

var addClassesToSVGElement = {};

var hasRequiredAddClassesToSVGElement;

function requireAddClassesToSVGElement () {
	if (hasRequiredAddClassesToSVGElement) return addClassesToSVGElement;
	hasRequiredAddClassesToSVGElement = 1;

	addClassesToSVGElement.name = 'addClassesToSVGElement';
	addClassesToSVGElement.type = 'visitor';
	addClassesToSVGElement.active = false;
	addClassesToSVGElement.description = 'adds classnames to an outer <svg> element';

	var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;

	/**
	 * Add classnames to an outer <svg> element. Example config:
	 *
	 * plugins: [
	 *   {
	 *     name: "addClassesToSVGElement",
	 *     params: {
	 *       className: "mySvg"
	 *     }
	 *   }
	 * ]
	 *
	 * plugins: [
	 *   {
	 *     name: "addClassesToSVGElement",
	 *     params: {
	 *       classNames: ["mySvg", "size-big"]
	 *     }
	 *   }
	 * ]
	 *
	 * @author April Arcus
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   className?: string,
	 *   classNames?: Array<string>
	 * }>}
	 */
	addClassesToSVGElement.fn = (root, params) => {
	  if (
	    !(Array.isArray(params.classNames) && params.classNames.some(String)) &&
	    !params.className
	  ) {
	    console.error(ENOCLS);
	    return null;
	  }
	  const classNames = params.classNames || [params.className];
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'svg' && parentNode.type === 'root') {
	          const classList = new Set(
	            node.attributes.class == null
	              ? null
	              : node.attributes.class.split(' ')
	          );
	          for (const className of classNames) {
	            if (className != null) {
	              classList.add(className);
	            }
	          }
	          node.attributes.class = Array.from(classList).join(' ');
	        }
	      },
	    },
	  };
	};
	return addClassesToSVGElement;
}

var cleanupListOfValues = {};

var hasRequiredCleanupListOfValues;

function requireCleanupListOfValues () {
	if (hasRequiredCleanupListOfValues) return cleanupListOfValues;
	hasRequiredCleanupListOfValues = 1;

	const { removeLeadingZero } = requireTools();

	cleanupListOfValues.name = 'cleanupListOfValues';
	cleanupListOfValues.type = 'visitor';
	cleanupListOfValues.active = false;
	cleanupListOfValues.description = 'rounds list of values to the fixed precision';

	const regNumericValues =
	  /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
	const regSeparator = /\s+,?\s*|,\s*/;
	const absoluteLengths = {
	  // relative to px
	  cm: 96 / 2.54,
	  mm: 96 / 25.4,
	  in: 96,
	  pt: 4 / 3,
	  pc: 16,
	  px: 1,
	};

	/**
	 * Round list of values to the fixed precision.
	 *
	 * @example
	 * <svg viewBox="0 0 200.28423 200.28423" enable-background="new 0 0 200.28423 200.28423">
	 *         â¬‡
	 * <svg viewBox="0 0 200.284 200.284" enable-background="new 0 0 200.284 200.284">
	 *
	 * <polygon points="208.250977 77.1308594 223.069336 ... "/>
	 *         â¬‡
	 * <polygon points="208.251 77.131 223.069 ... "/>
	 *
	 * @author kiyopikko
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   floatPrecision?: number,
	 *   leadingZero?: boolean,
	 *   defaultPx?: boolean,
	 *   convertToPx?: boolean
	 * }>}
	 */
	cleanupListOfValues.fn = (_root, params) => {
	  const {
	    floatPrecision = 3,
	    leadingZero = true,
	    defaultPx = true,
	    convertToPx = true,
	  } = params;

	  /**
	   * @type {(lists: string) => string}
	   */
	  const roundValues = (lists) => {
	    const roundedList = [];

	    for (const elem of lists.split(regSeparator)) {
	      const match = elem.match(regNumericValues);
	      const matchNew = elem.match(/new/);

	      // if attribute value matches regNumericValues
	      if (match) {
	        // round it to the fixed precision
	        let num = Number(Number(match[1]).toFixed(floatPrecision));
	        /**
	         * @type {any}
	         */
	        let matchedUnit = match[3] || '';
	        /**
	         * @type{'' | keyof typeof absoluteLengths}
	         */
	        let units = matchedUnit;

	        // convert absolute values to pixels
	        if (convertToPx && units && units in absoluteLengths) {
	          const pxNum = Number(
	            (absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision)
	          );

	          if (pxNum.toString().length < match[0].length) {
	            num = pxNum;
	            units = 'px';
	          }
	        }

	        // and remove leading zero
	        let str;
	        if (leadingZero) {
	          str = removeLeadingZero(num);
	        } else {
	          str = num.toString();
	        }

	        // remove default 'px' units
	        if (defaultPx && units === 'px') {
	          units = '';
	        }

	        roundedList.push(str + units);
	      }
	      // if attribute value is "new"(only enable-background).
	      else if (matchNew) {
	        roundedList.push('new');
	      } else if (elem) {
	        roundedList.push(elem);
	      }
	    }

	    return roundedList.join(' ');
	  };

	  return {
	    element: {
	      enter: (node) => {
	        if (node.attributes.points != null) {
	          node.attributes.points = roundValues(node.attributes.points);
	        }

	        if (node.attributes['enable-background'] != null) {
	          node.attributes['enable-background'] = roundValues(
	            node.attributes['enable-background']
	          );
	        }

	        if (node.attributes.viewBox != null) {
	          node.attributes.viewBox = roundValues(node.attributes.viewBox);
	        }

	        if (node.attributes['stroke-dasharray'] != null) {
	          node.attributes['stroke-dasharray'] = roundValues(
	            node.attributes['stroke-dasharray']
	          );
	        }

	        if (node.attributes.dx != null) {
	          node.attributes.dx = roundValues(node.attributes.dx);
	        }

	        if (node.attributes.dy != null) {
	          node.attributes.dy = roundValues(node.attributes.dy);
	        }

	        if (node.attributes.x != null) {
	          node.attributes.x = roundValues(node.attributes.x);
	        }

	        if (node.attributes.y != null) {
	          node.attributes.y = roundValues(node.attributes.y);
	        }
	      },
	    },
	  };
	};
	return cleanupListOfValues;
}

var convertStyleToAttrs = {};

var hasRequiredConvertStyleToAttrs;

function requireConvertStyleToAttrs () {
	if (hasRequiredConvertStyleToAttrs) return convertStyleToAttrs;
	hasRequiredConvertStyleToAttrs = 1;

	convertStyleToAttrs.name = 'convertStyleToAttrs';

	convertStyleToAttrs.type = 'perItem';

	convertStyleToAttrs.active = false;

	convertStyleToAttrs.description = 'converts style to attributes';

	convertStyleToAttrs.params = {
	  keepImportant: false,
	};

	var stylingProps = require_collections().attrsGroups.presentation,
	  rEscape = '\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)', // Like \" or \2051. Code points consume one space.
	  rAttr = '\\s*(' + g('[^:;\\\\]', rEscape) + '*?)\\s*', // attribute name like â€˜fillâ€™
	  rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)", // string in single quotes: 'smth'
	  rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)', // string in double quotes: "smth"
	  rQuotedString = new RegExp('^' + g(rSingleQuotes, rQuotes) + '$'),
	  // Parentheses, E.g.: url(data:image/png;base64,iVBO...).
	  // ':' and ';' inside of it should be threated as is. (Just like in strings.)
	  rParenthesis =
	    '\\(' + g('[^\'"()\\\\]+', rEscape, rSingleQuotes, rQuotes) + '*?' + '\\)',
	  // The value. It can have strings and parentheses (see above). Fallbacks to anything in case of unexpected input.
	  rValue =
	    '\\s*(' +
	    g(
	      '[^!\'"();\\\\]+?',
	      rEscape,
	      rSingleQuotes,
	      rQuotes,
	      rParenthesis,
	      '[^;]*?'
	    ) +
	    '*?' +
	    ')',
	  // End of declaration. Spaces outside of capturing groups help to do natural trimming.
	  rDeclEnd = '\\s*(?:;\\s*|$)',
	  // Important rule
	  rImportant = '(\\s*!important(?![-(\\w]))?',
	  // Final RegExp to parse CSS declarations.
	  regDeclarationBlock = new RegExp(
	    rAttr + ':' + rValue + rImportant + rDeclEnd,
	    'ig'
	  ),
	  // Comments expression. Honors escape sequences and strings.
	  regStripComments = new RegExp(
	    g(rEscape, rSingleQuotes, rQuotes, '/\\*[^]*?\\*/'),
	    'ig'
	  );

	/**
	 * Convert style in attributes. Cleanups comments and illegal declarations (without colon) as a side effect.
	 *
	 * @example
	 * <g style="fill:#000; color: #fff;">
	 *             â¬‡
	 * <g fill="#000" color="#fff">
	 *
	 * @example
	 * <g style="fill:#000; color: #fff; -webkit-blah: blah">
	 *             â¬‡
	 * <g fill="#000" color="#fff" style="-webkit-blah: blah">
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	convertStyleToAttrs.fn = function (item, params) {
	  if (item.type === 'element' && item.attributes.style != null) {
	    // ['opacity: 1', 'color: #000']
	    let styles = [];
	    const newAttributes = {};

	    // Strip CSS comments preserving escape sequences and strings.
	    const styleValue = item.attributes.style.replace(
	      regStripComments,
	      (match) => {
	        return match[0] == '/'
	          ? ''
	          : match[0] == '\\' && /[-g-z]/i.test(match[1])
	          ? match[1]
	          : match;
	      }
	    );

	    regDeclarationBlock.lastIndex = 0;
	    // eslint-disable-next-line no-cond-assign
	    for (var rule; (rule = regDeclarationBlock.exec(styleValue)); ) {
	      if (!params.keepImportant || !rule[3]) {
	        styles.push([rule[1], rule[2]]);
	      }
	    }

	    if (styles.length) {
	      styles = styles.filter(function (style) {
	        if (style[0]) {
	          var prop = style[0].toLowerCase(),
	            val = style[1];

	          if (rQuotedString.test(val)) {
	            val = val.slice(1, -1);
	          }

	          if (stylingProps.includes(prop)) {
	            newAttributes[prop] = val;

	            return false;
	          }
	        }

	        return true;
	      });

	      Object.assign(item.attributes, newAttributes);

	      if (styles.length) {
	        item.attributes.style = styles
	          .map((declaration) => declaration.join(':'))
	          .join(';');
	      } else {
	        delete item.attributes.style;
	      }
	    }
	  }
	};

	function g() {
	  return '(?:' + Array.prototype.join.call(arguments, '|') + ')';
	}
	return convertStyleToAttrs;
}

var prefixIds = {};

var hasRequiredPrefixIds;

function requirePrefixIds () {
	if (hasRequiredPrefixIds) return prefixIds;
	hasRequiredPrefixIds = 1;

	const csstree = requireLib$1();
	const { referencesProps } = require_collections();

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 * @typedef {import('../lib/types').PluginInfo} PluginInfo
	 */

	prefixIds.type = 'visitor';
	prefixIds.name = 'prefixIds';
	prefixIds.active = false;
	prefixIds.description = 'prefix IDs';

	/**
	 * extract basename from path
	 * @type {(path: string) => string}
	 */
	const getBasename = (path) => {
	  // extract everything after latest slash or backslash
	  const matched = path.match(/[/\\]?([^/\\]+)$/);
	  if (matched) {
	    return matched[1];
	  }
	  return '';
	};

	/**
	 * escapes a string for being used as ID
	 * @type {(string: string) => string}
	 */
	const escapeIdentifierName = (str) => {
	  return str.replace(/[. ]/g, '_');
	};

	/**
	 * @type {(string: string) => string}
	 */
	const unquote = (string) => {
	  if (
	    (string.startsWith('"') && string.endsWith('"')) ||
	    (string.startsWith("'") && string.endsWith("'"))
	  ) {
	    return string.slice(1, -1);
	  }
	  return string;
	};

	/**
	 * prefix an ID
	 * @type {(prefix: string, name: string) => string}
	 */
	const prefixId = (prefix, value) => {
	  if (value.startsWith(prefix)) {
	    return value;
	  }
	  return prefix + value;
	};

	/**
	 * prefix an #ID
	 * @type {(prefix: string, name: string) => string | null}
	 */
	const prefixReference = (prefix, value) => {
	  if (value.startsWith('#')) {
	    return '#' + prefixId(prefix, value.slice(1));
	  }
	  return null;
	};

	/**
	 * Prefixes identifiers
	 *
	 * @author strarsis <strarsis@gmail.com>
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   prefix?: boolean | string | ((node: XastElement, info: PluginInfo) => string),
	 *   delim?: string,
	 *   prefixIds?: boolean,
	 *   prefixClassNames?: boolean,
	 * }>}
	 */
	prefixIds.fn = (_root, params, info) => {
	  const { delim = '__', prefixIds = true, prefixClassNames = true } = params;

	  return {
	    element: {
	      enter: (node) => {
	        /**
	         * prefix, from file name or option
	         * @type {string}
	         */
	        let prefix = 'prefix' + delim;
	        if (typeof params.prefix === 'function') {
	          prefix = params.prefix(node, info) + delim;
	        } else if (typeof params.prefix === 'string') {
	          prefix = params.prefix + delim;
	        } else if (params.prefix === false) {
	          prefix = '';
	        } else if (info.path != null && info.path.length > 0) {
	          prefix = escapeIdentifierName(getBasename(info.path)) + delim;
	        }

	        // prefix id/class selectors and url() references in styles
	        if (node.name === 'style') {
	          // skip empty <style/> elements
	          if (node.children.length === 0) {
	            return;
	          }

	          // parse styles
	          let cssText = '';
	          if (
	            node.children[0].type === 'text' ||
	            node.children[0].type === 'cdata'
	          ) {
	            cssText = node.children[0].value;
	          }
	          /**
	           * @type {null | csstree.CssNode}
	           */
	          let cssAst = null;
	          try {
	            cssAst = csstree.parse(cssText, {
	              parseValue: true,
	              parseCustomProperty: false,
	            });
	          } catch {
	            return;
	          }

	          csstree.walk(cssAst, (node) => {
	            // #ID, .class selectors
	            if (
	              (prefixIds && node.type === 'IdSelector') ||
	              (prefixClassNames && node.type === 'ClassSelector')
	            ) {
	              node.name = prefixId(prefix, node.name);
	              return;
	            }
	            // url(...) references
	            if (
	              node.type === 'Url' &&
	              node.value.value &&
	              node.value.value.length > 0
	            ) {
	              const prefixed = prefixReference(
	                prefix,
	                unquote(node.value.value)
	              );
	              if (prefixed != null) {
	                node.value.value = prefixed;
	              }
	            }
	          });

	          // update styles
	          if (
	            node.children[0].type === 'text' ||
	            node.children[0].type === 'cdata'
	          ) {
	            node.children[0].value = csstree.generate(cssAst);
	          }
	          return;
	        }

	        // prefix an ID attribute value
	        if (
	          prefixIds &&
	          node.attributes.id != null &&
	          node.attributes.id.length !== 0
	        ) {
	          node.attributes.id = prefixId(prefix, node.attributes.id);
	        }

	        // prefix a class attribute value
	        if (
	          prefixClassNames &&
	          node.attributes.class != null &&
	          node.attributes.class.length !== 0
	        ) {
	          node.attributes.class = node.attributes.class
	            .split(/\s+/)
	            .map((name) => prefixId(prefix, name))
	            .join(' ');
	        }

	        // prefix a href attribute value
	        // xlink:href is deprecated, must be still supported
	        for (const name of ['href', 'xlink:href']) {
	          if (
	            node.attributes[name] != null &&
	            node.attributes[name].length !== 0
	          ) {
	            const prefixed = prefixReference(prefix, node.attributes[name]);
	            if (prefixed != null) {
	              node.attributes[name] = prefixed;
	            }
	          }
	        }

	        // prefix an URL attribute value
	        for (const name of referencesProps) {
	          if (
	            node.attributes[name] != null &&
	            node.attributes[name].length !== 0
	          ) {
	            node.attributes[name] = node.attributes[name].replace(
	              /url\((.*?)\)/gi,
	              (match, url) => {
	                const prefixed = prefixReference(prefix, url);
	                if (prefixed == null) {
	                  return match;
	                }
	                return `url(${prefixed})`;
	              }
	            );
	          }
	        }

	        // prefix begin/end attribute value
	        for (const name of ['begin', 'end']) {
	          if (
	            node.attributes[name] != null &&
	            node.attributes[name].length !== 0
	          ) {
	            const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
	              if (val.endsWith('.end') || val.endsWith('.start')) {
	                const [id, postfix] = val.split('.');
	                return `${prefixId(prefix, id)}.${postfix}`;
	              }
	              return val;
	            });
	            node.attributes[name] = parts.join('; ');
	          }
	        }
	      },
	    },
	  };
	};
	return prefixIds;
}

var removeAttributesBySelector = {};

var hasRequiredRemoveAttributesBySelector;

function requireRemoveAttributesBySelector () {
	if (hasRequiredRemoveAttributesBySelector) return removeAttributesBySelector;
	hasRequiredRemoveAttributesBySelector = 1;

	const { querySelectorAll } = requireXast();

	removeAttributesBySelector.name = 'removeAttributesBySelector';
	removeAttributesBySelector.type = 'visitor';
	removeAttributesBySelector.active = false;
	removeAttributesBySelector.description =
	  'removes attributes of elements that match a css selector';

	/**
	 * Removes attributes of elements that match a css selector.
	 *
	 * @example
	 * <caption>A selector removing a single attribute</caption>
	 * plugins: [
	 *   {
	 *     name: "removeAttributesBySelector",
	 *     params: {
	 *       selector: "[fill='#00ff00']"
	 *       attributes: "fill"
	 *     }
	 *   }
	 * ]
	 *
	 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
	 *   â†“
	 * <rect x="0" y="0" width="100" height="100" stroke="#00ff00"/>
	 *
	 * <caption>A selector removing multiple attributes</caption>
	 * plugins: [
	 *   {
	 *     name: "removeAttributesBySelector",
	 *     params: {
	 *       selector: "[fill='#00ff00']",
	 *       attributes: [
	 *         "fill",
	 *         "stroke"
	 *       ]
	 *     }
	 *   }
	 * ]
	 *
	 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
	 *   â†“
	 * <rect x="0" y="0" width="100" height="100"/>
	 *
	 * <caption>Multiple selectors removing attributes</caption>
	 * plugins: [
	 *   {
	 *     name: "removeAttributesBySelector",
	 *     params: {
	 *       selectors: [
	 *         {
	 *           selector: "[fill='#00ff00']",
	 *           attributes: "fill"
	 *         },
	 *         {
	 *           selector: "#remove",
	 *           attributes: [
	 *             "stroke",
	 *             "id"
	 *           ]
	 *         }
	 *       ]
	 *     }
	 *   }
	 * ]
	 *
	 * <rect x="0" y="0" width="100" height="100" fill="#00ff00" stroke="#00ff00"/>
	 *   â†“
	 * <rect x="0" y="0" width="100" height="100"/>
	 *
	 * @link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|MDN CSS Selectors
	 *
	 * @author Bradley Mease
	 *
	 * @type {import('../lib/types').Plugin<any>}
	 */
	removeAttributesBySelector.fn = (root, params) => {
	  const selectors = Array.isArray(params.selectors)
	    ? params.selectors
	    : [params];
	  for (const { selector, attributes } of selectors) {
	    const nodes = querySelectorAll(root, selector);
	    for (const node of nodes) {
	      if (node.type === 'element') {
	        if (Array.isArray(attributes)) {
	          for (const name of attributes) {
	            delete node.attributes[name];
	          }
	        } else {
	          delete node.attributes[attributes];
	        }
	      }
	    }
	  }
	  return {};
	};
	return removeAttributesBySelector;
}

var removeAttrs = {};

var hasRequiredRemoveAttrs;

function requireRemoveAttrs () {
	if (hasRequiredRemoveAttrs) return removeAttrs;
	hasRequiredRemoveAttrs = 1;

	removeAttrs.name = 'removeAttrs';
	removeAttrs.type = 'visitor';
	removeAttrs.active = false;
	removeAttrs.description = 'removes specified attributes';

	const DEFAULT_SEPARATOR = ':';
	const ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;

	/**
	 * Remove attributes
	 *
	 * @example elemSeparator
	 *   format: string
	 *
	 * @example preserveCurrentColor
	 *   format: boolean
	 *
	 * @example attrs:
	 *
	 *   format: [ element* : attribute* : value* ]
	 *
	 *   element   : regexp (wrapped into ^...$), single * or omitted > all elements (must be present when value is used)
	 *   attribute : regexp (wrapped into ^...$)
	 *   value     : regexp (wrapped into ^...$), single * or omitted > all values
	 *
	 *   examples:
	 *
	 *     > basic: remove fill attribute
	 *     ---
	 *     removeAttrs:
	 *       attrs: 'fill'
	 *
	 *     > remove fill attribute on path element
	 *     ---
	 *       attrs: 'path:fill'
	 *
	 *     > remove fill attribute on path element where value is none
	 *     ---
	 *       attrs: 'path:fill:none'
	 *
	 *
	 *     > remove all fill and stroke attribute
	 *     ---
	 *       attrs:
	 *         - 'fill'
	 *         - 'stroke'
	 *
	 *     [is same as]
	 *
	 *       attrs: '(fill|stroke)'
	 *
	 *     [is same as]
	 *
	 *       attrs: '*:(fill|stroke)'
	 *
	 *     [is same as]
	 *
	 *       attrs: '.*:(fill|stroke)'
	 *
	 *     [is same as]
	 *
	 *       attrs: '.*:(fill|stroke):.*'
	 *
	 *
	 *     > remove all stroke related attributes
	 *     ----
	 *     attrs: 'stroke.*'
	 *
	 *
	 * @author Benny Schudel
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   elemSeparator?: string,
	 *   preserveCurrentColor?: boolean,
	 *   attrs: string | Array<string>
	 * }>}
	 */
	removeAttrs.fn = (root, params) => {
	  if (typeof params.attrs == 'undefined') {
	    console.warn(ENOATTRS);
	    return null;
	  }

	  const elemSeparator =
	    typeof params.elemSeparator == 'string'
	      ? params.elemSeparator
	      : DEFAULT_SEPARATOR;
	  const preserveCurrentColor =
	    typeof params.preserveCurrentColor == 'boolean'
	      ? params.preserveCurrentColor
	      : false;
	  const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];

	  return {
	    element: {
	      enter: (node) => {
	        for (let pattern of attrs) {
	          // if no element separators (:), assume it's attribute name, and apply to all elements *regardless of value*
	          if (pattern.includes(elemSeparator) === false) {
	            pattern = ['.*', elemSeparator, pattern, elemSeparator, '.*'].join(
	              ''
	            );
	            // if only 1 separator, assume it's element and attribute name, and apply regardless of attribute value
	          } else if (pattern.split(elemSeparator).length < 3) {
	            pattern = [pattern, elemSeparator, '.*'].join('');
	          }

	          // create regexps for element, attribute name, and attribute value
	          const list = pattern.split(elemSeparator).map((value) => {
	            // adjust single * to match anything
	            if (value === '*') {
	              value = '.*';
	            }
	            return new RegExp(['^', value, '$'].join(''), 'i');
	          });

	          // matches element
	          if (list[0].test(node.name)) {
	            // loop attributes
	            for (const [name, value] of Object.entries(node.attributes)) {
	              const isFillCurrentColor =
	                preserveCurrentColor &&
	                name == 'fill' &&
	                value == 'currentColor';
	              const isStrokeCurrentColor =
	                preserveCurrentColor &&
	                name == 'stroke' &&
	                value == 'currentColor';
	              if (
	                !isFillCurrentColor &&
	                !isStrokeCurrentColor &&
	                // matches attribute name
	                list[1].test(name) &&
	                // matches attribute value
	                list[2].test(value)
	              ) {
	                delete node.attributes[name];
	              }
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return removeAttrs;
}

var removeDimensions = {};

var hasRequiredRemoveDimensions;

function requireRemoveDimensions () {
	if (hasRequiredRemoveDimensions) return removeDimensions;
	hasRequiredRemoveDimensions = 1;

	removeDimensions.name = 'removeDimensions';

	removeDimensions.type = 'perItem';

	removeDimensions.active = false;

	removeDimensions.description =
	  'removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)';

	/**
	 * Remove width/height attributes and add the viewBox attribute if it's missing
	 *
	 * @example
	 * <svg width="100" height="50" />
	 *   â†“
	 * <svg viewBox="0 0 100 50" />
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if true, with and height will be filtered out
	 *
	 * @author Benny Schudel
	 */
	removeDimensions.fn = function (item) {
	  if (item.type === 'element' && item.name === 'svg') {
	    if (item.attributes.viewBox != null) {
	      delete item.attributes.width;
	      delete item.attributes.height;
	    } else if (
	      item.attributes.width != null &&
	      item.attributes.height != null &&
	      Number.isNaN(Number(item.attributes.width)) === false &&
	      Number.isNaN(Number(item.attributes.height)) === false
	    ) {
	      const width = Number(item.attributes.width);
	      const height = Number(item.attributes.height);
	      item.attributes.viewBox = `0 0 ${width} ${height}`;
	      delete item.attributes.width;
	      delete item.attributes.height;
	    }
	  }
	};
	return removeDimensions;
}

var removeElementsByAttr = {};

var hasRequiredRemoveElementsByAttr;

function requireRemoveElementsByAttr () {
	if (hasRequiredRemoveElementsByAttr) return removeElementsByAttr;
	hasRequiredRemoveElementsByAttr = 1;

	const { detachNodeFromParent } = requireXast();

	removeElementsByAttr.name = 'removeElementsByAttr';
	removeElementsByAttr.type = 'visitor';
	removeElementsByAttr.active = false;
	removeElementsByAttr.description =
	  'removes arbitrary elements by ID or className (disabled by default)';

	/**
	 * Remove arbitrary SVG elements by ID or className.
	 *
	 * @example id
	 *     > single: remove element with ID of `elementID`
	 *     ---
	 *     removeElementsByAttr:
	 *       id: 'elementID'
	 *
	 *     > list: remove multiple elements by ID
	 *     ---
	 *     removeElementsByAttr:
	 *       id:
	 *         - 'elementID'
	 *         - 'anotherID'
	 *
	 * @example class
	 *     > single: remove all elements with class of `elementClass`
	 *     ---
	 *     removeElementsByAttr:
	 *       class: 'elementClass'
	 *
	 *     > list: remove all elements with class of `elementClass` or `anotherClass`
	 *     ---
	 *     removeElementsByAttr:
	 *       class:
	 *         - 'elementClass'
	 *         - 'anotherClass'
	 *
	 * @author Eli Dupuis (@elidupuis)
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   id?: string | Array<string>,
	 *   class?: string | Array<string>
	 * }>}
	 */
	removeElementsByAttr.fn = (root, params) => {
	  const ids =
	    params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
	  const classes =
	    params.class == null
	      ? []
	      : Array.isArray(params.class)
	      ? params.class
	      : [params.class];
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        // remove element if it's `id` matches configured `id` params
	        if (node.attributes.id != null && ids.length !== 0) {
	          if (ids.includes(node.attributes.id)) {
	            detachNodeFromParent(node, parentNode);
	          }
	        }
	        // remove element if it's `class` contains any of the configured `class` params
	        if (node.attributes.class && classes.length !== 0) {
	          const classList = node.attributes.class.split(' ');
	          for (const item of classes) {
	            if (classList.includes(item)) {
	              detachNodeFromParent(node, parentNode);
	              break;
	            }
	          }
	        }
	      },
	    },
	  };
	};
	return removeElementsByAttr;
}

var removeOffCanvasPaths = {};

var hasRequiredRemoveOffCanvasPaths;

function requireRemoveOffCanvasPaths () {
	if (hasRequiredRemoveOffCanvasPaths) return removeOffCanvasPaths;
	hasRequiredRemoveOffCanvasPaths = 1;

	/**
	 * @typedef {import('../lib/types').PathDataItem} PathDataItem
	 */

	const { visitSkip, detachNodeFromParent } = requireXast();
	const { parsePathData } = requirePath();
	const { intersects } = require_path();

	removeOffCanvasPaths.type = 'visitor';
	removeOffCanvasPaths.name = 'removeOffCanvasPaths';
	removeOffCanvasPaths.active = false;
	removeOffCanvasPaths.description =
	  'removes elements that are drawn outside of the viewbox (disabled by default)';

	/**
	 * Remove elements that are drawn outside of the viewbox.
	 *
	 * @author JoshyPHP
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeOffCanvasPaths.fn = () => {
	  /**
	   * @type {null | {
	   *   top: number,
	   *   right: number,
	   *   bottom: number,
	   *   left: number,
	   *   width: number,
	   *   height: number
	   * }}
	   */
	  let viewBoxData = null;

	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'svg' && parentNode.type === 'root') {
	          let viewBox = '';
	          // find viewbox
	          if (node.attributes.viewBox != null) {
	            // remove commas and plus signs, normalize and trim whitespace
	            viewBox = node.attributes.viewBox;
	          } else if (
	            node.attributes.height != null &&
	            node.attributes.width != null
	          ) {
	            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
	          }

	          // parse viewbox
	          // remove commas and plus signs, normalize and trim whitespace
	          viewBox = viewBox
	            .replace(/[,+]|px/g, ' ')
	            .replace(/\s+/g, ' ')
	            .replace(/^\s*|\s*$/g, '');
	          // ensure that the dimensions are 4 values separated by space
	          const m =
	            /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
	              viewBox
	            );
	          if (m == null) {
	            return;
	          }
	          const left = Number.parseFloat(m[1]);
	          const top = Number.parseFloat(m[2]);
	          const width = Number.parseFloat(m[3]);
	          const height = Number.parseFloat(m[4]);

	          // store the viewBox boundaries
	          viewBoxData = {
	            left,
	            top,
	            right: left + width,
	            bottom: top + height,
	            width,
	            height,
	          };
	        }

	        // consider that any item with a transform attribute is visible
	        if (node.attributes.transform != null) {
	          return visitSkip;
	        }

	        if (
	          node.name === 'path' &&
	          node.attributes.d != null &&
	          viewBoxData != null
	        ) {
	          const pathData = parsePathData(node.attributes.d);

	          // consider that a M command within the viewBox is visible
	          let visible = false;
	          for (const pathDataItem of pathData) {
	            if (pathDataItem.command === 'M') {
	              const [x, y] = pathDataItem.args;
	              if (
	                x >= viewBoxData.left &&
	                x <= viewBoxData.right &&
	                y >= viewBoxData.top &&
	                y <= viewBoxData.bottom
	              ) {
	                visible = true;
	              }
	            }
	          }
	          if (visible) {
	            return;
	          }

	          if (pathData.length === 2) {
	            // close the path too short for intersects()
	            pathData.push({ command: 'z', args: [] });
	          }

	          const { left, top, width, height } = viewBoxData;
	          /**
	           * @type {Array<PathDataItem>}
	           */
	          const viewBoxPathData = [
	            { command: 'M', args: [left, top] },
	            { command: 'h', args: [width] },
	            { command: 'v', args: [height] },
	            { command: 'H', args: [left] },
	            { command: 'z', args: [] },
	          ];

	          if (intersects(viewBoxPathData, pathData) === false) {
	            detachNodeFromParent(node, parentNode);
	          }
	        }
	      },
	    },
	  };
	};
	return removeOffCanvasPaths;
}

var removeRasterImages = {};

var hasRequiredRemoveRasterImages;

function requireRemoveRasterImages () {
	if (hasRequiredRemoveRasterImages) return removeRasterImages;
	hasRequiredRemoveRasterImages = 1;

	const { detachNodeFromParent } = requireXast();

	removeRasterImages.name = 'removeRasterImages';
	removeRasterImages.type = 'visitor';
	removeRasterImages.active = false;
	removeRasterImages.description = 'removes raster images (disabled by default)';

	/**
	 * Remove raster images references in <image>.
	 *
	 * @see https://bugs.webkit.org/show_bug.cgi?id=63548
	 *
	 * @author Kir Belevich
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeRasterImages.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (
	          node.name === 'image' &&
	          node.attributes['xlink:href'] != null &&
	          /(\.|image\/)(jpg|png|gif)/.test(node.attributes['xlink:href'])
	        ) {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeRasterImages;
}

var removeScriptElement = {};

var hasRequiredRemoveScriptElement;

function requireRemoveScriptElement () {
	if (hasRequiredRemoveScriptElement) return removeScriptElement;
	hasRequiredRemoveScriptElement = 1;

	const { detachNodeFromParent } = requireXast();

	removeScriptElement.name = 'removeScriptElement';
	removeScriptElement.type = 'visitor';
	removeScriptElement.active = false;
	removeScriptElement.description = 'removes <script> elements (disabled by default)';

	/**
	 * Remove <script>.
	 *
	 * https://www.w3.org/TR/SVG11/script.html
	 *
	 * @author Patrick Klingemann
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeScriptElement.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'script') {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeScriptElement;
}

var removeStyleElement = {};

var hasRequiredRemoveStyleElement;

function requireRemoveStyleElement () {
	if (hasRequiredRemoveStyleElement) return removeStyleElement;
	hasRequiredRemoveStyleElement = 1;

	const { detachNodeFromParent } = requireXast();

	removeStyleElement.name = 'removeStyleElement';
	removeStyleElement.type = 'visitor';
	removeStyleElement.active = false;
	removeStyleElement.description = 'removes <style> element (disabled by default)';

	/**
	 * Remove <style>.
	 *
	 * https://www.w3.org/TR/SVG11/styling.html#StyleElement
	 *
	 * @author Betsy Dupuis
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	removeStyleElement.fn = () => {
	  return {
	    element: {
	      enter: (node, parentNode) => {
	        if (node.name === 'style') {
	          detachNodeFromParent(node, parentNode);
	        }
	      },
	    },
	  };
	};
	return removeStyleElement;
}

var removeXMLNS = {};

var hasRequiredRemoveXMLNS;

function requireRemoveXMLNS () {
	if (hasRequiredRemoveXMLNS) return removeXMLNS;
	hasRequiredRemoveXMLNS = 1;

	removeXMLNS.name = 'removeXMLNS';

	removeXMLNS.type = 'perItem';

	removeXMLNS.active = false;

	removeXMLNS.description =
	  'removes xmlns attribute (for inline svg, disabled by default)';

	/**
	 * Remove the xmlns attribute when present.
	 *
	 * @example
	 * <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
	 *   â†“
	 * <svg viewBox="0 0 100 50">
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if true, xmlns will be filtered out
	 *
	 * @author Ricardo Tomasi
	 */
	removeXMLNS.fn = function (item) {
	  if (item.type === 'element' && item.name === 'svg') {
	    delete item.attributes.xmlns;
	    delete item.attributes['xmlns:xlink'];
	  }
	};
	return removeXMLNS;
}

var reusePaths = {};

var hasRequiredReusePaths;

function requireReusePaths () {
	if (hasRequiredReusePaths) return reusePaths;
	hasRequiredReusePaths = 1;

	/**
	 * @typedef {import('../lib/types').XastElement} XastElement
	 * @typedef {import('../lib/types').XastParent} XastParent
	 * @typedef {import('../lib/types').XastNode} XastNode
	 */

	const JSAPI = requireJsAPI();

	reusePaths.type = 'visitor';
	reusePaths.name = 'reusePaths';
	reusePaths.active = false;
	reusePaths.description =
	  'Finds <path> elements with the same d, fill, and ' +
	  'stroke, and converts them to <use> elements ' +
	  'referencing a single <path> def.';

	/**
	 * Finds <path> elements with the same d, fill, and stroke, and converts them to
	 * <use> elements referencing a single <path> def.
	 *
	 * @author Jacob Howcroft
	 *
	 * @type {import('../lib/types').Plugin<void>}
	 */
	reusePaths.fn = () => {
	  /**
	   * @type {Map<string, Array<XastElement>>}
	   */
	  const paths = new Map();

	  return {
	    element: {
	      enter: (node) => {
	        if (node.name === 'path' && node.attributes.d != null) {
	          const d = node.attributes.d;
	          const fill = node.attributes.fill || '';
	          const stroke = node.attributes.stroke || '';
	          const key = d + ';s:' + stroke + ';f:' + fill;
	          let list = paths.get(key);
	          if (list == null) {
	            list = [];
	            paths.set(key, list);
	          }
	          list.push(node);
	        }
	      },

	      exit: (node, parentNode) => {
	        if (node.name === 'svg' && parentNode.type === 'root') {
	          /**
	           * @type {XastElement}
	           */
	          const rawDefs = {
	            type: 'element',
	            name: 'defs',
	            attributes: {},
	            children: [],
	          };
	          /**
	           * @type {XastElement}
	           */
	          const defsTag = new JSAPI(rawDefs, node);
	          let index = 0;
	          for (const list of paths.values()) {
	            if (list.length > 1) {
	              // add reusable path to defs
	              /**
	               * @type {XastElement}
	               */
	              const rawPath = {
	                type: 'element',
	                name: 'path',
	                attributes: { ...list[0].attributes },
	                children: [],
	              };
	              delete rawPath.attributes.transform;
	              let id;
	              if (rawPath.attributes.id == null) {
	                id = 'reuse-' + index;
	                index += 1;
	                rawPath.attributes.id = id;
	              } else {
	                id = rawPath.attributes.id;
	                delete list[0].attributes.id;
	              }
	              /**
	               * @type {XastElement}
	               */
	              const reusablePath = new JSAPI(rawPath, defsTag);
	              defsTag.children.push(reusablePath);
	              // convert paths to <use>
	              for (const pathNode of list) {
	                pathNode.name = 'use';
	                pathNode.attributes['xlink:href'] = '#' + id;
	                delete pathNode.attributes.d;
	                delete pathNode.attributes.stroke;
	                delete pathNode.attributes.fill;
	              }
	            }
	          }
	          if (defsTag.children.length !== 0) {
	            if (node.attributes['xmlns:xlink'] == null) {
	              node.attributes['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
	            }
	            node.children.unshift(defsTag);
	          }
	        }
	      },
	    },
	  };
	};
	return reusePaths;
}

var sortAttrs = {};

var hasRequiredSortAttrs;

function requireSortAttrs () {
	if (hasRequiredSortAttrs) return sortAttrs;
	hasRequiredSortAttrs = 1;

	sortAttrs.type = 'visitor';
	sortAttrs.name = 'sortAttrs';
	sortAttrs.active = false;
	sortAttrs.description = 'Sort element attributes for better compression';

	/**
	 * Sort element attributes for better compression
	 *
	 * @author Nikolay Frantsev
	 *
	 * @type {import('../lib/types').Plugin<{
	 *   order?: Array<string>
	 *   xmlnsOrder?: 'front' | 'alphabetical'
	 * }>}
	 */
	sortAttrs.fn = (_root, params) => {
	  const {
	    order = [
	      'id',
	      'width',
	      'height',
	      'x',
	      'x1',
	      'x2',
	      'y',
	      'y1',
	      'y2',
	      'cx',
	      'cy',
	      'r',
	      'fill',
	      'stroke',
	      'marker',
	      'd',
	      'points',
	    ],
	    xmlnsOrder = 'front',
	  } = params;

	  /**
	   * @type {(name: string) => number}
	   */
	  const getNsPriority = (name) => {
	    if (xmlnsOrder === 'front') {
	      // put xmlns first
	      if (name === 'xmlns') {
	        return 3;
	      }
	      // xmlns:* attributes second
	      if (name.startsWith('xmlns:')) {
	        return 2;
	      }
	    }
	    // other namespaces after and sort them alphabetically
	    if (name.includes(':')) {
	      return 1;
	    }
	    // other attributes
	    return 0;
	  };

	  /**
	   * @type {(a: [string, string], b: [string, string]) => number}
	   */
	  const compareAttrs = ([aName], [bName]) => {
	    // sort namespaces
	    const aPriority = getNsPriority(aName);
	    const bPriority = getNsPriority(bName);
	    const priorityNs = bPriority - aPriority;
	    if (priorityNs !== 0) {
	      return priorityNs;
	    }
	    // extract the first part from attributes
	    // for example "fill" from "fill" and "fill-opacity"
	    const [aPart] = aName.split('-');
	    const [bPart] = bName.split('-');
	    // rely on alphabetical sort when the first part is the same
	    if (aPart !== bPart) {
	      const aInOrderFlag = order.includes(aPart) ? 1 : 0;
	      const bInOrderFlag = order.includes(bPart) ? 1 : 0;
	      // sort by position in order param
	      if (aInOrderFlag === 1 && bInOrderFlag === 1) {
	        return order.indexOf(aPart) - order.indexOf(bPart);
	      }
	      // put attributes from order param before others
	      const priorityOrder = bInOrderFlag - aInOrderFlag;
	      if (priorityOrder !== 0) {
	        return priorityOrder;
	      }
	    }
	    // sort alphabetically
	    return aName < bName ? -1 : 1;
	  };

	  return {
	    element: {
	      enter: (node) => {
	        const attrs = Object.entries(node.attributes);
	        attrs.sort(compareAttrs);
	        /**
	         * @type {Record<string, string>}
	         */
	        const sortedAttributes = {};
	        for (const [name, value] of attrs) {
	          sortedAttributes[name] = value;
	        }
	        node.attributes = sortedAttributes;
	      },
	    },
	  };
	};
	return sortAttrs;
}

var hasRequiredPlugins;

function requirePlugins () {
	if (hasRequiredPlugins) return plugins$1;
	hasRequiredPlugins = 1;
	(function (exports) {

		// builtin presets
		exports['preset-default'] = requirePresetDefault();

		// builtin plugins
		exports.addAttributesToSVGElement = requireAddAttributesToSVGElement();
		exports.addClassesToSVGElement = requireAddClassesToSVGElement();
		exports.cleanupAttrs = requireCleanupAttrs();
		exports.cleanupEnableBackground = requireCleanupEnableBackground();
		exports.cleanupIDs = requireCleanupIDs();
		exports.cleanupListOfValues = requireCleanupListOfValues();
		exports.cleanupNumericValues = requireCleanupNumericValues();
		exports.collapseGroups = requireCollapseGroups();
		exports.convertColors = requireConvertColors();
		exports.convertEllipseToCircle = requireConvertEllipseToCircle();
		exports.convertPathData = requireConvertPathData();
		exports.convertShapeToPath = requireConvertShapeToPath();
		exports.convertStyleToAttrs = requireConvertStyleToAttrs();
		exports.convertTransform = requireConvertTransform();
		exports.mergeStyles = requireMergeStyles();
		exports.inlineStyles = requireInlineStyles();
		exports.mergePaths = requireMergePaths();
		exports.minifyStyles = requireMinifyStyles();
		exports.moveElemsAttrsToGroup = requireMoveElemsAttrsToGroup();
		exports.moveGroupAttrsToElems = requireMoveGroupAttrsToElems();
		exports.prefixIds = requirePrefixIds();
		exports.removeAttributesBySelector = requireRemoveAttributesBySelector();
		exports.removeAttrs = requireRemoveAttrs();
		exports.removeComments = requireRemoveComments();
		exports.removeDesc = requireRemoveDesc();
		exports.removeDimensions = requireRemoveDimensions();
		exports.removeDoctype = requireRemoveDoctype();
		exports.removeEditorsNSData = requireRemoveEditorsNSData();
		exports.removeElementsByAttr = requireRemoveElementsByAttr();
		exports.removeEmptyAttrs = requireRemoveEmptyAttrs();
		exports.removeEmptyContainers = requireRemoveEmptyContainers();
		exports.removeEmptyText = requireRemoveEmptyText();
		exports.removeHiddenElems = requireRemoveHiddenElems();
		exports.removeMetadata = requireRemoveMetadata();
		exports.removeNonInheritableGroupAttrs = requireRemoveNonInheritableGroupAttrs();
		exports.removeOffCanvasPaths = requireRemoveOffCanvasPaths();
		exports.removeRasterImages = requireRemoveRasterImages();
		exports.removeScriptElement = requireRemoveScriptElement();
		exports.removeStyleElement = requireRemoveStyleElement();
		exports.removeTitle = requireRemoveTitle();
		exports.removeUnknownsAndDefaults = requireRemoveUnknownsAndDefaults();
		exports.removeUnusedNS = requireRemoveUnusedNS();
		exports.removeUselessDefs = requireRemoveUselessDefs();
		exports.removeUselessStrokeAndFill = requireRemoveUselessStrokeAndFill();
		exports.removeViewBox = requireRemoveViewBox();
		exports.removeXMLNS = requireRemoveXMLNS();
		exports.removeXMLProcInst = requireRemoveXMLProcInst();
		exports.reusePaths = requireReusePaths();
		exports.sortAttrs = requireSortAttrs();
		exports.sortDefsChildren = requireSortDefsChildren(); 
	} (plugins$1));
	return plugins$1;
}

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;

	const pluginsMap = requirePlugins();

	const pluginsOrder = [
	  'removeDoctype',
	  'removeXMLProcInst',
	  'removeComments',
	  'removeMetadata',
	  'removeXMLNS',
	  'removeEditorsNSData',
	  'cleanupAttrs',
	  'mergeStyles',
	  'inlineStyles',
	  'minifyStyles',
	  'convertStyleToAttrs',
	  'cleanupIDs',
	  'prefixIds',
	  'removeRasterImages',
	  'removeUselessDefs',
	  'cleanupNumericValues',
	  'cleanupListOfValues',
	  'convertColors',
	  'removeUnknownsAndDefaults',
	  'removeNonInheritableGroupAttrs',
	  'removeUselessStrokeAndFill',
	  'removeViewBox',
	  'cleanupEnableBackground',
	  'removeHiddenElems',
	  'removeEmptyText',
	  'convertShapeToPath',
	  'convertEllipseToCircle',
	  'moveElemsAttrsToGroup',
	  'moveGroupAttrsToElems',
	  'collapseGroups',
	  'convertPathData',
	  'convertTransform',
	  'removeEmptyAttrs',
	  'removeEmptyContainers',
	  'mergePaths',
	  'removeUnusedNS',
	  'sortAttrs',
	  'sortDefsChildren',
	  'removeTitle',
	  'removeDesc',
	  'removeDimensions',
	  'removeAttrs',
	  'removeAttributesBySelector',
	  'removeElementsByAttr',
	  'addClassesToSVGElement',
	  'removeStyleElement',
	  'removeScriptElement',
	  'addAttributesToSVGElement',
	  'removeOffCanvasPaths',
	  'reusePaths',
	];
	const defaultPlugins = pluginsOrder.filter((name) => pluginsMap[name].active);
	config.defaultPlugins = defaultPlugins;

	const extendDefaultPlugins = (plugins) => {
	  console.warn(
	    '\n"extendDefaultPlugins" utility is deprecated.\n' +
	      'Use "preset-default" plugin with overrides instead.\n' +
	      'For example:\n' +
	      `{\n` +
	      `  name: 'preset-default',\n` +
	      `  params: {\n` +
	      `    overrides: {\n` +
	      `      // customize plugin options\n` +
	      `      convertShapeToPath: {\n` +
	      `        convertArcs: true\n` +
	      `      },\n` +
	      `      // disable plugins\n` +
	      `      convertPathData: false\n` +
	      `    }\n` +
	      `  }\n` +
	      `}\n`
	  );
	  const extendedPlugins = pluginsOrder.map((name) => ({
	    name,
	    active: pluginsMap[name].active,
	  }));
	  for (const plugin of plugins) {
	    const resolvedPlugin = resolvePluginConfig(plugin);
	    const index = pluginsOrder.indexOf(resolvedPlugin.name);
	    if (index === -1) {
	      extendedPlugins.push(plugin);
	    } else {
	      extendedPlugins[index] = plugin;
	    }
	  }
	  return extendedPlugins;
	};
	config.extendDefaultPlugins = extendDefaultPlugins;

	const resolvePluginConfig = (plugin) => {
	  let configParams = {};
	  if (typeof plugin === 'string') {
	    // resolve builtin plugin specified as string
	    const pluginConfig = pluginsMap[plugin];
	    if (pluginConfig == null) {
	      throw Error(`Unknown builtin plugin "${plugin}" specified.`);
	    }
	    return {
	      ...pluginConfig,
	      name: plugin,
	      active: true,
	      params: { ...pluginConfig.params, ...configParams },
	    };
	  }
	  if (typeof plugin === 'object' && plugin != null) {
	    if (plugin.name == null) {
	      throw Error(`Plugin name should be specified`);
	    }
	    if (plugin.fn) {
	      // resolve custom plugin with implementation
	      return {
	        active: true,
	        ...plugin,
	        params: { ...configParams, ...plugin.params },
	      };
	    } else {
	      // resolve builtin plugin specified as object without implementation
	      const pluginConfig = pluginsMap[plugin.name];
	      if (pluginConfig == null) {
	        throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
	      }
	      return {
	        ...pluginConfig,
	        active: true,
	        ...plugin,
	        params: { ...pluginConfig.params, ...configParams, ...plugin.params },
	      };
	    }
	  }
	  return null;
	};
	config.resolvePluginConfig = resolvePluginConfig;
	return config;
}

var parser = {};

var sax = {};

var hasRequiredSax;

function requireSax () {
	if (hasRequiredSax) return sax;
	hasRequiredSax = 1;
	(function (exports) {
(function (sax) { // wrapper for non-node envs
		  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) };
		  sax.SAXParser = SAXParser;

		  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
		  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
		  // since that's the earliest that a buffer overrun could occur.  This way, checks are
		  // as rare as required, but as often as necessary to ensure never crossing this bound.
		  // Furthermore, buffers are only tested at most once per write(), so passing a very
		  // large string into write() might have undesirable effects, but this is manageable by
		  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
		  // edge case, result in creating at most one complete copy of the string passed in.
		  // Set to Infinity to have unlimited buffers.
		  sax.MAX_BUFFER_LENGTH = 64 * 1024;

		  var buffers = [
		    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
		    'procInstName', 'procInstBody', 'entity', 'attribName',
		    'attribValue', 'cdata', 'script'
		  ];

		  sax.EVENTS = [
		    'text',
		    'processinginstruction',
		    'sgmldeclaration',
		    'doctype',
		    'comment',
		    'opentagstart',
		    'attribute',
		    'opentag',
		    'closetag',
		    'opencdata',
		    'cdata',
		    'closecdata',
		    'error',
		    'end',
		    'ready',
		    'script',
		    'opennamespace',
		    'closenamespace'
		  ];

		  function SAXParser (strict, opt) {
		    if (!(this instanceof SAXParser)) {
		      return new SAXParser(strict, opt)
		    }

		    var parser = this;
		    clearBuffers(parser);
		    parser.q = parser.c = '';
		    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
		    parser.opt = opt || {};
		    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
		    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
		    parser.tags = [];
		    parser.closed = parser.closedRoot = parser.sawRoot = false;
		    parser.tag = parser.error = null;
		    parser.strict = !!strict;
		    parser.noscript = !!(strict || parser.opt.noscript);
		    parser.state = S.BEGIN;
		    parser.strictEntities = parser.opt.strictEntities;
		    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
		    parser.attribList = [];

		    // namespaces form a prototype chain.
		    // it always points at the current tag,
		    // which protos to its parent tag.
		    if (parser.opt.xmlns) {
		      parser.ns = Object.create(rootNS);
		    }

		    // mostly just for error reporting
		    parser.trackPosition = parser.opt.position !== false;
		    if (parser.trackPosition) {
		      parser.position = parser.line = parser.column = 0;
		    }
		    emit(parser, 'onready');
		  }

		  if (!Object.create) {
		    Object.create = function (o) {
		      function F () {}
		      F.prototype = o;
		      var newf = new F();
		      return newf
		    };
		  }

		  if (!Object.keys) {
		    Object.keys = function (o) {
		      var a = [];
		      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
		      return a
		    };
		  }

		  function checkBufferLength (parser) {
		    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
		    var maxActual = 0;
		    for (var i = 0, l = buffers.length; i < l; i++) {
		      var len = parser[buffers[i]].length;
		      if (len > maxAllowed) {
		        // Text/cdata nodes can get big, and since they're buffered,
		        // we can get here under normal conditions.
		        // Avoid issues by emitting the text node now,
		        // so at least it won't get any bigger.
		        switch (buffers[i]) {
		          case 'textNode':
		            closeText(parser);
		            break

		          case 'cdata':
		            emitNode(parser, 'oncdata', parser.cdata);
		            parser.cdata = '';
		            break

		          case 'script':
		            emitNode(parser, 'onscript', parser.script);
		            parser.script = '';
		            break

		          default:
		            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
		        }
		      }
		      maxActual = Math.max(maxActual, len);
		    }
		    // schedule the next check for the earliest possible buffer overrun.
		    var m = sax.MAX_BUFFER_LENGTH - maxActual;
		    parser.bufferCheckPosition = m + parser.position;
		  }

		  function clearBuffers (parser) {
		    for (var i = 0, l = buffers.length; i < l; i++) {
		      parser[buffers[i]] = '';
		    }
		  }

		  function flushBuffers (parser) {
		    closeText(parser);
		    if (parser.cdata !== '') {
		      emitNode(parser, 'oncdata', parser.cdata);
		      parser.cdata = '';
		    }
		    if (parser.script !== '') {
		      emitNode(parser, 'onscript', parser.script);
		      parser.script = '';
		    }
		  }

		  SAXParser.prototype = {
		    end: function () { end(this); },
		    write: write,
		    resume: function () { this.error = null; return this },
		    close: function () { return this.write(null) },
		    flush: function () { flushBuffers(this); }
		  };

		  // this really needs to be replaced with character classes.
		  // XML allows all manner of ridiculous numbers and digits.
		  var CDATA = '[CDATA[';
		  var DOCTYPE = 'DOCTYPE';
		  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
		  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
		  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };

		  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
		  // This implementation works on strings, a single character at a time
		  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
		  // without a significant breaking change to either this  parser, or the
		  // JavaScript language.  Implementation of an emoji-capable xml parser
		  // is left as an exercise for the reader.
		  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

		  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

		  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
		  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

		  function isWhitespace (c) {
		    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
		  }

		  function isQuote (c) {
		    return c === '"' || c === '\''
		  }

		  function isAttribEnd (c) {
		    return c === '>' || isWhitespace(c)
		  }

		  function isMatch (regex, c) {
		    return regex.test(c)
		  }

		  function notMatch (regex, c) {
		    return !isMatch(regex, c)
		  }

		  var S = 0;
		  sax.STATE = {
		    BEGIN: S++, // leading byte order mark or whitespace
		    BEGIN_WHITESPACE: S++, // leading whitespace
		    TEXT: S++, // general stuff
		    TEXT_ENTITY: S++, // &amp and such.
		    OPEN_WAKA: S++, // <
		    SGML_DECL: S++, // <!BLARG
		    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
		    DOCTYPE: S++, // <!DOCTYPE
		    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
		    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
		    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
		    COMMENT_STARTING: S++, // <!-
		    COMMENT: S++, // <!--
		    COMMENT_ENDING: S++, // <!-- blah -
		    COMMENT_ENDED: S++, // <!-- blah --
		    CDATA: S++, // <![CDATA[ something
		    CDATA_ENDING: S++, // ]
		    CDATA_ENDING_2: S++, // ]]
		    PROC_INST: S++, // <?hi
		    PROC_INST_BODY: S++, // <?hi there
		    PROC_INST_ENDING: S++, // <?hi "there" ?
		    OPEN_TAG: S++, // <strong
		    OPEN_TAG_SLASH: S++, // <strong /
		    ATTRIB: S++, // <a
		    ATTRIB_NAME: S++, // <a foo
		    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
		    ATTRIB_VALUE: S++, // <a foo=
		    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
		    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
		    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
		    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
		    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
		    CLOSE_TAG: S++, // </a
		    CLOSE_TAG_SAW_WHITE: S++, // </a   >
		    SCRIPT: S++, // <script> ...
		    SCRIPT_ENDING: S++ // <script> ... <
		  };

		  sax.XML_ENTITIES = {
		    'amp': '&',
		    'gt': '>',
		    'lt': '<',
		    'quot': '"',
		    'apos': "'"
		  };

		  sax.ENTITIES = {
		    'amp': '&',
		    'gt': '>',
		    'lt': '<',
		    'quot': '"',
		    'apos': "'",
		    'AElig': 198,
		    'Aacute': 193,
		    'Acirc': 194,
		    'Agrave': 192,
		    'Aring': 197,
		    'Atilde': 195,
		    'Auml': 196,
		    'Ccedil': 199,
		    'ETH': 208,
		    'Eacute': 201,
		    'Ecirc': 202,
		    'Egrave': 200,
		    'Euml': 203,
		    'Iacute': 205,
		    'Icirc': 206,
		    'Igrave': 204,
		    'Iuml': 207,
		    'Ntilde': 209,
		    'Oacute': 211,
		    'Ocirc': 212,
		    'Ograve': 210,
		    'Oslash': 216,
		    'Otilde': 213,
		    'Ouml': 214,
		    'THORN': 222,
		    'Uacute': 218,
		    'Ucirc': 219,
		    'Ugrave': 217,
		    'Uuml': 220,
		    'Yacute': 221,
		    'aacute': 225,
		    'acirc': 226,
		    'aelig': 230,
		    'agrave': 224,
		    'aring': 229,
		    'atilde': 227,
		    'auml': 228,
		    'ccedil': 231,
		    'eacute': 233,
		    'ecirc': 234,
		    'egrave': 232,
		    'eth': 240,
		    'euml': 235,
		    'iacute': 237,
		    'icirc': 238,
		    'igrave': 236,
		    'iuml': 239,
		    'ntilde': 241,
		    'oacute': 243,
		    'ocirc': 244,
		    'ograve': 242,
		    'oslash': 248,
		    'otilde': 245,
		    'ouml': 246,
		    'szlig': 223,
		    'thorn': 254,
		    'uacute': 250,
		    'ucirc': 251,
		    'ugrave': 249,
		    'uuml': 252,
		    'yacute': 253,
		    'yuml': 255,
		    'copy': 169,
		    'reg': 174,
		    'nbsp': 160,
		    'iexcl': 161,
		    'cent': 162,
		    'pound': 163,
		    'curren': 164,
		    'yen': 165,
		    'brvbar': 166,
		    'sect': 167,
		    'uml': 168,
		    'ordf': 170,
		    'laquo': 171,
		    'not': 172,
		    'shy': 173,
		    'macr': 175,
		    'deg': 176,
		    'plusmn': 177,
		    'sup1': 185,
		    'sup2': 178,
		    'sup3': 179,
		    'acute': 180,
		    'micro': 181,
		    'para': 182,
		    'middot': 183,
		    'cedil': 184,
		    'ordm': 186,
		    'raquo': 187,
		    'frac14': 188,
		    'frac12': 189,
		    'frac34': 190,
		    'iquest': 191,
		    'times': 215,
		    'divide': 247,
		    'OElig': 338,
		    'oelig': 339,
		    'Scaron': 352,
		    'scaron': 353,
		    'Yuml': 376,
		    'fnof': 402,
		    'circ': 710,
		    'tilde': 732,
		    'Alpha': 913,
		    'Beta': 914,
		    'Gamma': 915,
		    'Delta': 916,
		    'Epsilon': 917,
		    'Zeta': 918,
		    'Eta': 919,
		    'Theta': 920,
		    'Iota': 921,
		    'Kappa': 922,
		    'Lambda': 923,
		    'Mu': 924,
		    'Nu': 925,
		    'Xi': 926,
		    'Omicron': 927,
		    'Pi': 928,
		    'Rho': 929,
		    'Sigma': 931,
		    'Tau': 932,
		    'Upsilon': 933,
		    'Phi': 934,
		    'Chi': 935,
		    'Psi': 936,
		    'Omega': 937,
		    'alpha': 945,
		    'beta': 946,
		    'gamma': 947,
		    'delta': 948,
		    'epsilon': 949,
		    'zeta': 950,
		    'eta': 951,
		    'theta': 952,
		    'iota': 953,
		    'kappa': 954,
		    'lambda': 955,
		    'mu': 956,
		    'nu': 957,
		    'xi': 958,
		    'omicron': 959,
		    'pi': 960,
		    'rho': 961,
		    'sigmaf': 962,
		    'sigma': 963,
		    'tau': 964,
		    'upsilon': 965,
		    'phi': 966,
		    'chi': 967,
		    'psi': 968,
		    'omega': 969,
		    'thetasym': 977,
		    'upsih': 978,
		    'piv': 982,
		    'ensp': 8194,
		    'emsp': 8195,
		    'thinsp': 8201,
		    'zwnj': 8204,
		    'zwj': 8205,
		    'lrm': 8206,
		    'rlm': 8207,
		    'ndash': 8211,
		    'mdash': 8212,
		    'lsquo': 8216,
		    'rsquo': 8217,
		    'sbquo': 8218,
		    'ldquo': 8220,
		    'rdquo': 8221,
		    'bdquo': 8222,
		    'dagger': 8224,
		    'Dagger': 8225,
		    'bull': 8226,
		    'hellip': 8230,
		    'permil': 8240,
		    'prime': 8242,
		    'Prime': 8243,
		    'lsaquo': 8249,
		    'rsaquo': 8250,
		    'oline': 8254,
		    'frasl': 8260,
		    'euro': 8364,
		    'image': 8465,
		    'weierp': 8472,
		    'real': 8476,
		    'trade': 8482,
		    'alefsym': 8501,
		    'larr': 8592,
		    'uarr': 8593,
		    'rarr': 8594,
		    'darr': 8595,
		    'harr': 8596,
		    'crarr': 8629,
		    'lArr': 8656,
		    'uArr': 8657,
		    'rArr': 8658,
		    'dArr': 8659,
		    'hArr': 8660,
		    'forall': 8704,
		    'part': 8706,
		    'exist': 8707,
		    'empty': 8709,
		    'nabla': 8711,
		    'isin': 8712,
		    'notin': 8713,
		    'ni': 8715,
		    'prod': 8719,
		    'sum': 8721,
		    'minus': 8722,
		    'lowast': 8727,
		    'radic': 8730,
		    'prop': 8733,
		    'infin': 8734,
		    'ang': 8736,
		    'and': 8743,
		    'or': 8744,
		    'cap': 8745,
		    'cup': 8746,
		    'int': 8747,
		    'there4': 8756,
		    'sim': 8764,
		    'cong': 8773,
		    'asymp': 8776,
		    'ne': 8800,
		    'equiv': 8801,
		    'le': 8804,
		    'ge': 8805,
		    'sub': 8834,
		    'sup': 8835,
		    'nsub': 8836,
		    'sube': 8838,
		    'supe': 8839,
		    'oplus': 8853,
		    'otimes': 8855,
		    'perp': 8869,
		    'sdot': 8901,
		    'lceil': 8968,
		    'rceil': 8969,
		    'lfloor': 8970,
		    'rfloor': 8971,
		    'lang': 9001,
		    'rang': 9002,
		    'loz': 9674,
		    'spades': 9824,
		    'clubs': 9827,
		    'hearts': 9829,
		    'diams': 9830
		  };

		  Object.keys(sax.ENTITIES).forEach(function (key) {
		    var e = sax.ENTITIES[key];
		    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
		    sax.ENTITIES[key] = s;
		  });

		  for (var s in sax.STATE) {
		    sax.STATE[sax.STATE[s]] = s;
		  }

		  // shorthand
		  S = sax.STATE;

		  function emit (parser, event, data) {
		    parser[event] && parser[event](data);
		  }

		  function emitNode (parser, nodeType, data) {
		    if (parser.textNode) closeText(parser);
		    emit(parser, nodeType, data);
		  }

		  function closeText (parser) {
		    parser.textNode = textopts(parser.opt, parser.textNode);
		    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
		    parser.textNode = '';
		  }

		  function textopts (opt, text) {
		    if (opt.trim) text = text.trim();
		    if (opt.normalize) text = text.replace(/\s+/g, ' ');
		    return text
		  }

		  function error (parser, reason) {
		    closeText(parser);
		    const message = reason +
		      '\nLine: ' + parser.line +
		      '\nColumn: ' + parser.column +
		      '\nChar: ' + parser.c;
		    const error = new Error(message);
		    error.reason = reason;
		    error.line = parser.line;
		    error.column = parser.column;
		    parser.error = error;
		    emit(parser, 'onerror', error);
		    return parser
		  }

		  function end (parser) {
		    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
		    if ((parser.state !== S.BEGIN) &&
		      (parser.state !== S.BEGIN_WHITESPACE) &&
		      (parser.state !== S.TEXT)) {
		      error(parser, 'Unexpected end');
		    }
		    closeText(parser);
		    parser.c = '';
		    parser.closed = true;
		    emit(parser, 'onend');
		    SAXParser.call(parser, parser.strict, parser.opt);
		    return parser
		  }

		  function strictFail (parser, message) {
		    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
		      throw new Error('bad call to strictFail')
		    }
		    if (parser.strict) {
		      error(parser, message);
		    }
		  }

		  function newTag (parser) {
		    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
		    var parent = parser.tags[parser.tags.length - 1] || parser;
		    var tag = parser.tag = { name: parser.tagName, attributes: {} };

		    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
		    if (parser.opt.xmlns) {
		      tag.ns = parent.ns;
		    }
		    parser.attribList.length = 0;
		    emitNode(parser, 'onopentagstart', tag);
		  }

		  function qname (name, attribute) {
		    var i = name.indexOf(':');
		    var qualName = i < 0 ? [ '', name ] : name.split(':');
		    var prefix = qualName[0];
		    var local = qualName[1];

		    // <x "xmlns"="http://foo">
		    if (attribute && name === 'xmlns') {
		      prefix = 'xmlns';
		      local = '';
		    }

		    return { prefix: prefix, local: local }
		  }

		  function attrib (parser) {
		    if (!parser.strict) {
		      parser.attribName = parser.attribName[parser.looseCase]();
		    }

		    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
		      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
		      parser.attribName = parser.attribValue = '';
		      return
		    }

		    if (parser.opt.xmlns) {
		      var qn = qname(parser.attribName, true);
		      var prefix = qn.prefix;
		      var local = qn.local;

		      if (prefix === 'xmlns') {
		        // namespace binding attribute. push the binding into scope
		        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
		          strictFail(parser,
		            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
		            'Actual: ' + parser.attribValue);
		        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
		          strictFail(parser,
		            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
		            'Actual: ' + parser.attribValue);
		        } else {
		          var tag = parser.tag;
		          var parent = parser.tags[parser.tags.length - 1] || parser;
		          if (tag.ns === parent.ns) {
		            tag.ns = Object.create(parent.ns);
		          }
		          tag.ns[local] = parser.attribValue;
		        }
		      }

		      // defer onattribute events until all attributes have been seen
		      // so any new bindings can take effect. preserve attribute order
		      // so deferred events can be emitted in document order
		      parser.attribList.push([parser.attribName, parser.attribValue]);
		    } else {
		      // in non-xmlns mode, we can emit the event right away
		      parser.tag.attributes[parser.attribName] = parser.attribValue;
		      emitNode(parser, 'onattribute', {
		        name: parser.attribName,
		        value: parser.attribValue
		      });
		    }

		    parser.attribName = parser.attribValue = '';
		  }

		  function openTag (parser, selfClosing) {
		    if (parser.opt.xmlns) {
		      // emit namespace binding events
		      var tag = parser.tag;

		      // add namespace info to tag
		      var qn = qname(parser.tagName);
		      tag.prefix = qn.prefix;
		      tag.local = qn.local;
		      tag.uri = tag.ns[qn.prefix] || '';

		      if (tag.prefix && !tag.uri) {
		        strictFail(parser, 'Unbound namespace prefix: ' +
		          JSON.stringify(parser.tagName));
		        tag.uri = qn.prefix;
		      }

		      var parent = parser.tags[parser.tags.length - 1] || parser;
		      if (tag.ns && parent.ns !== tag.ns) {
		        Object.keys(tag.ns).forEach(function (p) {
		          emitNode(parser, 'onopennamespace', {
		            prefix: p,
		            uri: tag.ns[p]
		          });
		        });
		      }

		      // handle deferred onattribute events
		      // Note: do not apply default ns to attributes:
		      //   http://www.w3.org/TR/REC-xml-names/#defaulting
		      for (var i = 0, l = parser.attribList.length; i < l; i++) {
		        var nv = parser.attribList[i];
		        var name = nv[0];
		        var value = nv[1];
		        var qualName = qname(name, true);
		        var prefix = qualName.prefix;
		        var local = qualName.local;
		        var uri = prefix === '' ? '' : (tag.ns[prefix] || '');
		        var a = {
		          name: name,
		          value: value,
		          prefix: prefix,
		          local: local,
		          uri: uri
		        };

		        // if there's any attributes with an undefined namespace,
		        // then fail on them now.
		        if (prefix && prefix !== 'xmlns' && !uri) {
		          strictFail(parser, 'Unbound namespace prefix: ' +
		            JSON.stringify(prefix));
		          a.uri = prefix;
		        }
		        parser.tag.attributes[name] = a;
		        emitNode(parser, 'onattribute', a);
		      }
		      parser.attribList.length = 0;
		    }

		    parser.tag.isSelfClosing = !!selfClosing;

		    // process the tag
		    parser.sawRoot = true;
		    parser.tags.push(parser.tag);
		    emitNode(parser, 'onopentag', parser.tag);
		    if (!selfClosing) {
		      // special case for <script> in non-strict mode.
		      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
		        parser.state = S.SCRIPT;
		      } else {
		        parser.state = S.TEXT;
		      }
		      parser.tag = null;
		      parser.tagName = '';
		    }
		    parser.attribName = parser.attribValue = '';
		    parser.attribList.length = 0;
		  }

		  function closeTag (parser) {
		    if (!parser.tagName) {
		      strictFail(parser, 'Weird empty close tag.');
		      parser.textNode += '</>';
		      parser.state = S.TEXT;
		      return
		    }

		    if (parser.script) {
		      if (parser.tagName !== 'script') {
		        parser.script += '</' + parser.tagName + '>';
		        parser.tagName = '';
		        parser.state = S.SCRIPT;
		        return
		      }
		      emitNode(parser, 'onscript', parser.script);
		      parser.script = '';
		    }

		    // first make sure that the closing tag actually exists.
		    // <a><b></c></b></a> will close everything, otherwise.
		    var t = parser.tags.length;
		    var tagName = parser.tagName;
		    if (!parser.strict) {
		      tagName = tagName[parser.looseCase]();
		    }
		    var closeTo = tagName;
		    while (t--) {
		      var close = parser.tags[t];
		      if (close.name !== closeTo) {
		        // fail the first time in strict mode
		        strictFail(parser, 'Unexpected close tag');
		      } else {
		        break
		      }
		    }

		    // didn't find it.  we already failed for strict, so just abort.
		    if (t < 0) {
		      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
		      parser.textNode += '</' + parser.tagName + '>';
		      parser.state = S.TEXT;
		      return
		    }
		    parser.tagName = tagName;
		    var s = parser.tags.length;
		    while (s-- > t) {
		      var tag = parser.tag = parser.tags.pop();
		      parser.tagName = parser.tag.name;
		      emitNode(parser, 'onclosetag', parser.tagName);

		      var x = {};
		      for (var i in tag.ns) {
		        x[i] = tag.ns[i];
		      }

		      var parent = parser.tags[parser.tags.length - 1] || parser;
		      if (parser.opt.xmlns && tag.ns !== parent.ns) {
		        // remove namespace bindings introduced by tag
		        Object.keys(tag.ns).forEach(function (p) {
		          var n = tag.ns[p];
		          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
		        });
		      }
		    }
		    if (t === 0) parser.closedRoot = true;
		    parser.tagName = parser.attribValue = parser.attribName = '';
		    parser.attribList.length = 0;
		    parser.state = S.TEXT;
		  }

		  function parseEntity (parser) {
		    var entity = parser.entity;
		    var entityLC = entity.toLowerCase();
		    var num;
		    var numStr = '';

		    if (parser.ENTITIES[entity]) {
		      return parser.ENTITIES[entity]
		    }
		    if (parser.ENTITIES[entityLC]) {
		      return parser.ENTITIES[entityLC]
		    }
		    entity = entityLC;
		    if (entity.charAt(0) === '#') {
		      if (entity.charAt(1) === 'x') {
		        entity = entity.slice(2);
		        num = parseInt(entity, 16);
		        numStr = num.toString(16);
		      } else {
		        entity = entity.slice(1);
		        num = parseInt(entity, 10);
		        numStr = num.toString(10);
		      }
		    }
		    entity = entity.replace(/^0+/, '');
		    if (isNaN(num) || numStr.toLowerCase() !== entity) {
		      strictFail(parser, 'Invalid character entity');
		      return '&' + parser.entity + ';'
		    }

		    return String.fromCodePoint(num)
		  }

		  function beginWhiteSpace (parser, c) {
		    if (c === '<') {
		      parser.state = S.OPEN_WAKA;
		      parser.startTagPosition = parser.position;
		    } else if (!isWhitespace(c)) {
		      // have to process this as a text node.
		      // weird, but happens.
		      strictFail(parser, 'Non-whitespace before first tag.');
		      parser.textNode = c;
		      parser.state = S.TEXT;
		    }
		  }

		  function charAt (chunk, i) {
		    var result = '';
		    if (i < chunk.length) {
		      result = chunk.charAt(i);
		    }
		    return result
		  }

		  function write (chunk) {
		    var parser = this;
		    if (this.error) {
		      throw this.error
		    }
		    if (parser.closed) {
		      return error(parser,
		        'Cannot write after close. Assign an onready handler.')
		    }
		    if (chunk === null) {
		      return end(parser)
		    }
		    if (typeof chunk === 'object') {
		      chunk = chunk.toString();
		    }
		    var i = 0;
		    var c = '';
		    while (true) {
		      c = charAt(chunk, i++);
		      parser.c = c;

		      if (!c) {
		        break
		      }

		      if (parser.trackPosition) {
		        parser.position++;
		        if (c === '\n') {
		          parser.line++;
		          parser.column = 0;
		        } else {
		          parser.column++;
		        }
		      }

		      switch (parser.state) {
		        case S.BEGIN:
		          parser.state = S.BEGIN_WHITESPACE;
		          if (c === '\uFEFF') {
		            continue
		          }
		          beginWhiteSpace(parser, c);
		          continue

		        case S.BEGIN_WHITESPACE:
		          beginWhiteSpace(parser, c);
		          continue

		        case S.TEXT:
		          if (parser.sawRoot && !parser.closedRoot) {
		            var starti = i - 1;
		            while (c && c !== '<' && c !== '&') {
		              c = charAt(chunk, i++);
		              if (c && parser.trackPosition) {
		                parser.position++;
		                if (c === '\n') {
		                  parser.line++;
		                  parser.column = 0;
		                } else {
		                  parser.column++;
		                }
		              }
		            }
		            parser.textNode += chunk.substring(starti, i - 1);
		          }
		          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
		            parser.state = S.OPEN_WAKA;
		            parser.startTagPosition = parser.position;
		          } else {
		            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
		              strictFail(parser, 'Text data outside of root node.');
		            }
		            if (c === '&') {
		              parser.state = S.TEXT_ENTITY;
		            } else {
		              parser.textNode += c;
		            }
		          }
		          continue

		        case S.SCRIPT:
		          // only non-strict
		          if (c === '<') {
		            parser.state = S.SCRIPT_ENDING;
		          } else {
		            parser.script += c;
		          }
		          continue

		        case S.SCRIPT_ENDING:
		          if (c === '/') {
		            parser.state = S.CLOSE_TAG;
		          } else {
		            parser.script += '<' + c;
		            parser.state = S.SCRIPT;
		          }
		          continue

		        case S.OPEN_WAKA:
		          // either a /, ?, !, or text is coming next.
		          if (c === '!') {
		            parser.state = S.SGML_DECL;
		            parser.sgmlDecl = '';
		          } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {
		            parser.state = S.OPEN_TAG;
		            parser.tagName = c;
		          } else if (c === '/') {
		            parser.state = S.CLOSE_TAG;
		            parser.tagName = '';
		          } else if (c === '?') {
		            parser.state = S.PROC_INST;
		            parser.procInstName = parser.procInstBody = '';
		          } else {
		            strictFail(parser, 'Unencoded <');
		            // if there was some whitespace, then add that in.
		            if (parser.startTagPosition + 1 < parser.position) {
		              var pad = parser.position - parser.startTagPosition;
		              c = new Array(pad).join(' ') + c;
		            }
		            parser.textNode += '<' + c;
		            parser.state = S.TEXT;
		          }
		          continue

		        case S.SGML_DECL:
		          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
		            emitNode(parser, 'onopencdata');
		            parser.state = S.CDATA;
		            parser.sgmlDecl = '';
		            parser.cdata = '';
		          } else if (parser.sgmlDecl + c === '--') {
		            parser.state = S.COMMENT;
		            parser.comment = '';
		            parser.sgmlDecl = '';
		          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
		            parser.state = S.DOCTYPE;
		            if (parser.doctype || parser.sawRoot) {
		              strictFail(parser,
		                'Inappropriately located doctype declaration');
		            }
		            parser.doctype = '';
		            parser.sgmlDecl = '';
		          } else if (c === '>') {
		            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
		            parser.sgmlDecl = '';
		            parser.state = S.TEXT;
		          } else if (isQuote(c)) {
		            parser.state = S.SGML_DECL_QUOTED;
		            parser.sgmlDecl += c;
		          } else {
		            parser.sgmlDecl += c;
		          }
		          continue

		        case S.SGML_DECL_QUOTED:
		          if (c === parser.q) {
		            parser.state = S.SGML_DECL;
		            parser.q = '';
		          }
		          parser.sgmlDecl += c;
		          continue

		        case S.DOCTYPE:
		          if (c === '>') {
		            parser.state = S.TEXT;
		            emitNode(parser, 'ondoctype', parser.doctype);
		            parser.doctype = true; // just remember that we saw it.
		          } else {
		            parser.doctype += c;
		            if (c === '[') {
		              parser.state = S.DOCTYPE_DTD;
		            } else if (isQuote(c)) {
		              parser.state = S.DOCTYPE_QUOTED;
		              parser.q = c;
		            }
		          }
		          continue

		        case S.DOCTYPE_QUOTED:
		          parser.doctype += c;
		          if (c === parser.q) {
		            parser.q = '';
		            parser.state = S.DOCTYPE;
		          }
		          continue

		        case S.DOCTYPE_DTD:
		          parser.doctype += c;
		          if (c === ']') {
		            parser.state = S.DOCTYPE;
		          } else if (isQuote(c)) {
		            parser.state = S.DOCTYPE_DTD_QUOTED;
		            parser.q = c;
		          }
		          continue

		        case S.DOCTYPE_DTD_QUOTED:
		          parser.doctype += c;
		          if (c === parser.q) {
		            parser.state = S.DOCTYPE_DTD;
		            parser.q = '';
		          }
		          continue

		        case S.COMMENT:
		          if (c === '-') {
		            parser.state = S.COMMENT_ENDING;
		          } else {
		            parser.comment += c;
		          }
		          continue

		        case S.COMMENT_ENDING:
		          if (c === '-') {
		            parser.state = S.COMMENT_ENDED;
		            parser.comment = textopts(parser.opt, parser.comment);
		            if (parser.comment) {
		              emitNode(parser, 'oncomment', parser.comment);
		            }
		            parser.comment = '';
		          } else {
		            parser.comment += '-' + c;
		            parser.state = S.COMMENT;
		          }
		          continue

		        case S.COMMENT_ENDED:
		          if (c !== '>') {
		            strictFail(parser, 'Malformed comment');
		            // allow <!-- blah -- bloo --> in non-strict mode,
		            // which is a comment of " blah -- bloo "
		            parser.comment += '--' + c;
		            parser.state = S.COMMENT;
		          } else {
		            parser.state = S.TEXT;
		          }
		          continue

		        case S.CDATA:
		          if (c === ']') {
		            parser.state = S.CDATA_ENDING;
		          } else {
		            parser.cdata += c;
		          }
		          continue

		        case S.CDATA_ENDING:
		          if (c === ']') {
		            parser.state = S.CDATA_ENDING_2;
		          } else {
		            parser.cdata += ']' + c;
		            parser.state = S.CDATA;
		          }
		          continue

		        case S.CDATA_ENDING_2:
		          if (c === '>') {
		            if (parser.cdata) {
		              emitNode(parser, 'oncdata', parser.cdata);
		            }
		            emitNode(parser, 'onclosecdata');
		            parser.cdata = '';
		            parser.state = S.TEXT;
		          } else if (c === ']') {
		            parser.cdata += ']';
		          } else {
		            parser.cdata += ']]' + c;
		            parser.state = S.CDATA;
		          }
		          continue

		        case S.PROC_INST:
		          if (c === '?') {
		            parser.state = S.PROC_INST_ENDING;
		          } else if (isWhitespace(c)) {
		            parser.state = S.PROC_INST_BODY;
		          } else {
		            parser.procInstName += c;
		          }
		          continue

		        case S.PROC_INST_BODY:
		          if (!parser.procInstBody && isWhitespace(c)) {
		            continue
		          } else if (c === '?') {
		            parser.state = S.PROC_INST_ENDING;
		          } else {
		            parser.procInstBody += c;
		          }
		          continue

		        case S.PROC_INST_ENDING:
		          if (c === '>') {
		            emitNode(parser, 'onprocessinginstruction', {
		              name: parser.procInstName,
		              body: parser.procInstBody
		            });
		            parser.procInstName = parser.procInstBody = '';
		            parser.state = S.TEXT;
		          } else {
		            parser.procInstBody += '?' + c;
		            parser.state = S.PROC_INST_BODY;
		          }
		          continue

		        case S.OPEN_TAG:
		          if (isMatch(nameBody, c)) {
		            parser.tagName += c;
		          } else {
		            newTag(parser);
		            if (c === '>') {
		              openTag(parser);
		            } else if (c === '/') {
		              parser.state = S.OPEN_TAG_SLASH;
		            } else {
		              if (!isWhitespace(c)) {
		                strictFail(parser, 'Invalid character in tag name');
		              }
		              parser.state = S.ATTRIB;
		            }
		          }
		          continue

		        case S.OPEN_TAG_SLASH:
		          if (c === '>') {
		            openTag(parser, true);
		            closeTag(parser);
		          } else {
		            strictFail(parser, 'Forward-slash in opening tag not followed by >');
		            parser.state = S.ATTRIB;
		          }
		          continue

		        case S.ATTRIB:
		          // haven't read the attribute name yet.
		          if (isWhitespace(c)) {
		            continue
		          } else if (c === '>') {
		            openTag(parser);
		          } else if (c === '/') {
		            parser.state = S.OPEN_TAG_SLASH;
		          } else if (isMatch(nameStart, c)) {
		            parser.attribName = c;
		            parser.attribValue = '';
		            parser.state = S.ATTRIB_NAME;
		          } else {
		            strictFail(parser, 'Invalid attribute name');
		          }
		          continue

		        case S.ATTRIB_NAME:
		          if (c === '=') {
		            parser.state = S.ATTRIB_VALUE;
		          } else if (c === '>') {
		            strictFail(parser, 'Attribute without value');
		            parser.attribValue = parser.attribName;
		            attrib(parser);
		            openTag(parser);
		          } else if (isWhitespace(c)) {
		            parser.state = S.ATTRIB_NAME_SAW_WHITE;
		          } else if (isMatch(nameBody, c)) {
		            parser.attribName += c;
		          } else {
		            strictFail(parser, 'Invalid attribute name');
		          }
		          continue

		        case S.ATTRIB_NAME_SAW_WHITE:
		          if (c === '=') {
		            parser.state = S.ATTRIB_VALUE;
		          } else if (isWhitespace(c)) {
		            continue
		          } else {
		            strictFail(parser, 'Attribute without value');
		            parser.tag.attributes[parser.attribName] = '';
		            parser.attribValue = '';
		            emitNode(parser, 'onattribute', {
		              name: parser.attribName,
		              value: ''
		            });
		            parser.attribName = '';
		            if (c === '>') {
		              openTag(parser);
		            } else if (isMatch(nameStart, c)) {
		              parser.attribName = c;
		              parser.state = S.ATTRIB_NAME;
		            } else {
		              strictFail(parser, 'Invalid attribute name');
		              parser.state = S.ATTRIB;
		            }
		          }
		          continue

		        case S.ATTRIB_VALUE:
		          if (isWhitespace(c)) {
		            continue
		          } else if (isQuote(c)) {
		            parser.q = c;
		            parser.state = S.ATTRIB_VALUE_QUOTED;
		          } else {
		            strictFail(parser, 'Unquoted attribute value');
		            parser.state = S.ATTRIB_VALUE_UNQUOTED;
		            parser.attribValue = c;
		          }
		          continue

		        case S.ATTRIB_VALUE_QUOTED:
		          if (c !== parser.q) {
		            if (c === '&') {
		              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
		            } else {
		              parser.attribValue += c;
		            }
		            continue
		          }
		          attrib(parser);
		          parser.q = '';
		          parser.state = S.ATTRIB_VALUE_CLOSED;
		          continue

		        case S.ATTRIB_VALUE_CLOSED:
		          if (isWhitespace(c)) {
		            parser.state = S.ATTRIB;
		          } else if (c === '>') {
		            openTag(parser);
		          } else if (c === '/') {
		            parser.state = S.OPEN_TAG_SLASH;
		          } else if (isMatch(nameStart, c)) {
		            strictFail(parser, 'No whitespace between attributes');
		            parser.attribName = c;
		            parser.attribValue = '';
		            parser.state = S.ATTRIB_NAME;
		          } else {
		            strictFail(parser, 'Invalid attribute name');
		          }
		          continue

		        case S.ATTRIB_VALUE_UNQUOTED:
		          if (!isAttribEnd(c)) {
		            if (c === '&') {
		              parser.state = S.ATTRIB_VALUE_ENTITY_U;
		            } else {
		              parser.attribValue += c;
		            }
		            continue
		          }
		          attrib(parser);
		          if (c === '>') {
		            openTag(parser);
		          } else {
		            parser.state = S.ATTRIB;
		          }
		          continue

		        case S.CLOSE_TAG:
		          if (!parser.tagName) {
		            if (isWhitespace(c)) {
		              continue
		            } else if (notMatch(nameStart, c)) {
		              if (parser.script) {
		                parser.script += '</' + c;
		                parser.state = S.SCRIPT;
		              } else {
		                strictFail(parser, 'Invalid tagname in closing tag.');
		              }
		            } else {
		              parser.tagName = c;
		            }
		          } else if (c === '>') {
		            closeTag(parser);
		          } else if (isMatch(nameBody, c)) {
		            parser.tagName += c;
		          } else if (parser.script) {
		            parser.script += '</' + parser.tagName;
		            parser.tagName = '';
		            parser.state = S.SCRIPT;
		          } else {
		            if (!isWhitespace(c)) {
		              strictFail(parser, 'Invalid tagname in closing tag');
		            }
		            parser.state = S.CLOSE_TAG_SAW_WHITE;
		          }
		          continue

		        case S.CLOSE_TAG_SAW_WHITE:
		          if (isWhitespace(c)) {
		            continue
		          }
		          if (c === '>') {
		            closeTag(parser);
		          } else {
		            strictFail(parser, 'Invalid characters in closing tag');
		          }
		          continue

		        case S.TEXT_ENTITY:
		        case S.ATTRIB_VALUE_ENTITY_Q:
		        case S.ATTRIB_VALUE_ENTITY_U:
		          var returnState;
		          var buffer;
		          switch (parser.state) {
		            case S.TEXT_ENTITY:
		              returnState = S.TEXT;
		              buffer = 'textNode';
		              break

		            case S.ATTRIB_VALUE_ENTITY_Q:
		              returnState = S.ATTRIB_VALUE_QUOTED;
		              buffer = 'attribValue';
		              break

		            case S.ATTRIB_VALUE_ENTITY_U:
		              returnState = S.ATTRIB_VALUE_UNQUOTED;
		              buffer = 'attribValue';
		              break
		          }

		          if (c === ';') {
		            var parsedEntity = parseEntity(parser);

		            // Custom entities can contain tags, so we potentially need to parse the result
		            if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== '&' + parser.entity + ';') {
		              chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
		            } else {
		              parser[buffer] += parsedEntity;
		            }

		            parser.entity = '';
		            parser.state = returnState;
		          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
		            parser.entity += c;
		          } else {
		            strictFail(parser, 'Invalid character in entity name');
		            parser[buffer] += '&' + parser.entity + c;
		            parser.entity = '';
		            parser.state = returnState;
		          }

		          continue

		        default:
		          throw new Error(parser, 'Unknown state: ' + parser.state)
		      }
		    } // while

		    if (parser.position >= parser.bufferCheckPosition) {
		      checkBufferLength(parser);
		    }
		    return parser
		  }
		})(exports); 
	} (sax));
	return sax;
}

var hasRequiredParser;

function requireParser () {
	if (hasRequiredParser) return parser;
	hasRequiredParser = 1;

	/**
	 * @typedef {import('./types').XastNode} XastNode
	 * @typedef {import('./types').XastInstruction} XastInstruction
	 * @typedef {import('./types').XastDoctype} XastDoctype
	 * @typedef {import('./types').XastComment} XastComment
	 * @typedef {import('./types').XastRoot} XastRoot
	 * @typedef {import('./types').XastElement} XastElement
	 * @typedef {import('./types').XastCdata} XastCdata
	 * @typedef {import('./types').XastText} XastText
	 * @typedef {import('./types').XastParent} XastParent
	 */

	// @ts-ignore sax will be replaced with something else later
	const SAX = requireSax();
	const JSAPI = requireJsAPI();
	const { textElems } = require_collections();

	class SvgoParserError extends Error {
	  /**
	   * @param message {string}
	   * @param line {number}
	   * @param column {number}
	   * @param source {string}
	   * @param file {void | string}
	   */
	  constructor(message, line, column, source, file) {
	    super(message);
	    this.name = 'SvgoParserError';
	    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;
	    this.reason = message;
	    this.line = line;
	    this.column = column;
	    this.source = source;
	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, SvgoParserError);
	    }
	  }
	  toString() {
	    const lines = this.source.split(/\r?\n/);
	    const startLine = Math.max(this.line - 3, 0);
	    const endLine = Math.min(this.line + 2, lines.length);
	    const lineNumberWidth = String(endLine).length;
	    const startColumn = Math.max(this.column - 54, 0);
	    const endColumn = Math.max(this.column + 20, 80);
	    const code = lines
	      .slice(startLine, endLine)
	      .map((line, index) => {
	        const lineSlice = line.slice(startColumn, endColumn);
	        let ellipsisPrefix = '';
	        let ellipsisSuffix = '';
	        if (startColumn !== 0) {
	          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : 'â€¦';
	        }
	        if (endColumn < line.length - 1) {
	          ellipsisSuffix = 'â€¦';
	        }
	        const number = startLine + 1 + index;
	        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
	        if (number === this.line) {
	          const gutterSpacing = gutter.replace(/[^|]/g, ' ');
	          const lineSpacing = (
	            ellipsisPrefix + line.slice(startColumn, this.column - 1)
	          ).replace(/[^\t]/g, ' ');
	          const spacing = gutterSpacing + lineSpacing;
	          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\n ${spacing}^`;
	        }
	        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
	      })
	      .join('\n');
	    return `${this.name}: ${this.message}\n\n${code}\n`;
	  }
	}

	const entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;

	const config = {
	  strict: true,
	  trim: false,
	  normalize: false,
	  lowercase: true,
	  xmlns: true,
	  position: true,
	};

	/**
	 * Convert SVG (XML) string to SVG-as-JS object.
	 *
	 * @type {(data: string, from?: string) => XastRoot}
	 */
	const parseSvg = (data, from) => {
	  const sax = SAX.parser(config.strict, config);
	  /**
	   * @type {XastRoot}
	   */
	  const root = new JSAPI({ type: 'root', children: [] });
	  /**
	   * @type {XastParent}
	   */
	  let current = root;
	  /**
	   * @type {Array<XastParent>}
	   */
	  const stack = [root];

	  /**
	   * @type {<T extends XastNode>(node: T) => T}
	   */
	  const pushToContent = (node) => {
	    const wrapped = new JSAPI(node, current);
	    current.children.push(wrapped);
	    return wrapped;
	  };

	  /**
	   * @type {(doctype: string) => void}
	   */
	  sax.ondoctype = (doctype) => {
	    /**
	     * @type {XastDoctype}
	     */
	    const node = {
	      type: 'doctype',
	      // TODO parse doctype for name, public and system to match xast
	      name: 'svg',
	      data: {
	        doctype,
	      },
	    };
	    pushToContent(node);
	    const subsetStart = doctype.indexOf('[');
	    if (subsetStart >= 0) {
	      entityDeclaration.lastIndex = subsetStart;
	      let entityMatch = entityDeclaration.exec(data);
	      while (entityMatch != null) {
	        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
	        entityMatch = entityDeclaration.exec(data);
	      }
	    }
	  };

	  /**
	   * @type {(data: { name: string, body: string }) => void}
	   */
	  sax.onprocessinginstruction = (data) => {
	    /**
	     * @type {XastInstruction}
	     */
	    const node = {
	      type: 'instruction',
	      name: data.name,
	      value: data.body,
	    };
	    pushToContent(node);
	  };

	  /**
	   * @type {(comment: string) => void}
	   */
	  sax.oncomment = (comment) => {
	    /**
	     * @type {XastComment}
	     */
	    const node = {
	      type: 'comment',
	      value: comment.trim(),
	    };
	    pushToContent(node);
	  };

	  /**
	   * @type {(cdata: string) => void}
	   */
	  sax.oncdata = (cdata) => {
	    /**
	     * @type {XastCdata}
	     */
	    const node = {
	      type: 'cdata',
	      value: cdata,
	    };
	    pushToContent(node);
	  };

	  /**
	   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}
	   */
	  sax.onopentag = (data) => {
	    /**
	     * @type {XastElement}
	     */
	    let element = {
	      type: 'element',
	      name: data.name,
	      attributes: {},
	      children: [],
	    };
	    for (const [name, attr] of Object.entries(data.attributes)) {
	      element.attributes[name] = attr.value;
	    }
	    element = pushToContent(element);
	    current = element;
	    stack.push(element);
	  };

	  /**
	   * @type {(text: string) => void}
	   */
	  sax.ontext = (text) => {
	    if (current.type === 'element') {
	      // prevent trimming of meaningful whitespace inside textual tags
	      if (textElems.includes(current.name)) {
	        /**
	         * @type {XastText}
	         */
	        const node = {
	          type: 'text',
	          value: text,
	        };
	        pushToContent(node);
	      } else if (/\S/.test(text)) {
	        /**
	         * @type {XastText}
	         */
	        const node = {
	          type: 'text',
	          value: text.trim(),
	        };
	        pushToContent(node);
	      }
	    }
	  };

	  sax.onclosetag = () => {
	    stack.pop();
	    current = stack[stack.length - 1];
	  };

	  /**
	   * @type {(e: any) => void}
	   */
	  sax.onerror = (e) => {
	    const error = new SvgoParserError(
	      e.reason,
	      e.line + 1,
	      e.column,
	      data,
	      from
	    );
	    if (e.message.indexOf('Unexpected end') === -1) {
	      throw error;
	    }
	  };

	  sax.write(data).close();
	  return root;
	};
	parser.parseSvg = parseSvg;
	return parser;
}

var stringifier = {};

var hasRequiredStringifier;

function requireStringifier () {
	if (hasRequiredStringifier) return stringifier;
	hasRequiredStringifier = 1;

	/**
	 * @typedef {import('./types').XastParent} XastParent
	 * @typedef {import('./types').XastRoot} XastRoot
	 * @typedef {import('./types').XastElement} XastElement
	 * @typedef {import('./types').XastInstruction} XastInstruction
	 * @typedef {import('./types').XastDoctype} XastDoctype
	 * @typedef {import('./types').XastText} XastText
	 * @typedef {import('./types').XastCdata} XastCdata
	 * @typedef {import('./types').XastComment} XastComment
	 * @typedef {import('./types').StringifyOptions} StringifyOptions
	 */

	const { textElems } = require_collections();

	/**
	 * @typedef {{
	 *   width: void | string,
	 *   height: void | string,
	 *   indent: string,
	 *   textContext: null | XastElement,
	 *   indentLevel: number,
	 * }} State
	 */

	/**
	 * @typedef {Required<StringifyOptions>} Options
	 */

	/**
	 * @type {(char: string) => string}
	 */
	const encodeEntity = (char) => {
	  return entities[char];
	};

	/**
	 * @type {Options}
	 */
	const defaults = {
	  doctypeStart: '<!DOCTYPE',
	  doctypeEnd: '>',
	  procInstStart: '<?',
	  procInstEnd: '?>',
	  tagOpenStart: '<',
	  tagOpenEnd: '>',
	  tagCloseStart: '</',
	  tagCloseEnd: '>',
	  tagShortStart: '<',
	  tagShortEnd: '/>',
	  attrStart: '="',
	  attrEnd: '"',
	  commentStart: '<!--',
	  commentEnd: '-->',
	  cdataStart: '<![CDATA[',
	  cdataEnd: ']]>',
	  textStart: '',
	  textEnd: '',
	  indent: 4,
	  regEntities: /[&'"<>]/g,
	  regValEntities: /[&"<>]/g,
	  encodeEntity: encodeEntity,
	  pretty: false,
	  useShortTags: true,
	  eol: 'lf',
	  finalNewline: false,
	};

	/**
	 * @type {Record<string, string>}
	 */
	const entities = {
	  '&': '&amp;',
	  "'": '&apos;',
	  '"': '&quot;',
	  '>': '&gt;',
	  '<': '&lt;',
	};

	/**
	 * convert XAST to SVG string
	 *
	 * @type {(data: XastRoot, config: StringifyOptions) => {
	 *   data: string,
	 *   info: {
	 *     width: void | string,
	 *     height: void | string
	 *   }
	 * }}
	 */
	const stringifySvg = (data, userOptions = {}) => {
	  /**
	   * @type {Options}
	   */
	  const config = { ...defaults, ...userOptions };
	  const indent = config.indent;
	  let newIndent = '    ';
	  if (typeof indent === 'number' && Number.isNaN(indent) === false) {
	    newIndent = indent < 0 ? '\t' : ' '.repeat(indent);
	  } else if (typeof indent === 'string') {
	    newIndent = indent;
	  }
	  /**
	   * @type {State}
	   */
	  const state = {
	    // TODO remove width and height in v3
	    width: undefined,
	    height: undefined,
	    indent: newIndent,
	    textContext: null,
	    indentLevel: 0,
	  };
	  const eol = config.eol === 'crlf' ? '\r\n' : '\n';
	  if (config.pretty) {
	    config.doctypeEnd += eol;
	    config.procInstEnd += eol;
	    config.commentEnd += eol;
	    config.cdataEnd += eol;
	    config.tagShortEnd += eol;
	    config.tagOpenEnd += eol;
	    config.tagCloseEnd += eol;
	    config.textEnd += eol;
	  }
	  let svg = stringifyNode(data, config, state);
	  if (config.finalNewline && svg.length > 0 && svg[svg.length - 1] !== '\n') {
	    svg += eol;
	  }
	  return {
	    data: svg,
	    info: {
	      width: state.width,
	      height: state.height,
	    },
	  };
	};
	stringifier.stringifySvg = stringifySvg;

	/**
	 * @type {(node: XastParent, config: Options, state: State) => string}
	 */
	const stringifyNode = (data, config, state) => {
	  let svg = '';
	  state.indentLevel += 1;
	  for (const item of data.children) {
	    if (item.type === 'element') {
	      svg += stringifyElement(item, config, state);
	    }
	    if (item.type === 'text') {
	      svg += stringifyText(item, config, state);
	    }
	    if (item.type === 'doctype') {
	      svg += stringifyDoctype(item, config);
	    }
	    if (item.type === 'instruction') {
	      svg += stringifyInstruction(item, config);
	    }
	    if (item.type === 'comment') {
	      svg += stringifyComment(item, config);
	    }
	    if (item.type === 'cdata') {
	      svg += stringifyCdata(item, config, state);
	    }
	  }
	  state.indentLevel -= 1;
	  return svg;
	};

	/**
	 * create indent string in accordance with the current node level.
	 *
	 * @type {(config: Options, state: State) => string}
	 */
	const createIndent = (config, state) => {
	  let indent = '';
	  if (config.pretty && state.textContext == null) {
	    indent = state.indent.repeat(state.indentLevel - 1);
	  }
	  return indent;
	};

	/**
	 * @type {(node: XastDoctype, config: Options) => string}
	 */
	const stringifyDoctype = (node, config) => {
	  return config.doctypeStart + node.data.doctype + config.doctypeEnd;
	};

	/**
	 * @type {(node: XastInstruction, config: Options) => string}
	 */
	const stringifyInstruction = (node, config) => {
	  return (
	    config.procInstStart + node.name + ' ' + node.value + config.procInstEnd
	  );
	};

	/**
	 * @type {(node: XastComment, config: Options) => string}
	 */
	const stringifyComment = (node, config) => {
	  return config.commentStart + node.value + config.commentEnd;
	};

	/**
	 * @type {(node: XastCdata, config: Options, state: State) => string}
	 */
	const stringifyCdata = (node, config, state) => {
	  return (
	    createIndent(config, state) +
	    config.cdataStart +
	    node.value +
	    config.cdataEnd
	  );
	};

	/**
	 * @type {(node: XastElement, config: Options, state: State) => string}
	 */
	const stringifyElement = (node, config, state) => {
	  // beautiful injection for obtaining SVG information :)
	  if (
	    node.name === 'svg' &&
	    node.attributes.width != null &&
	    node.attributes.height != null
	  ) {
	    state.width = node.attributes.width;
	    state.height = node.attributes.height;
	  }

	  // empty element and short tag
	  if (node.children.length === 0) {
	    if (config.useShortTags) {
	      return (
	        createIndent(config, state) +
	        config.tagShortStart +
	        node.name +
	        stringifyAttributes(node, config) +
	        config.tagShortEnd
	      );
	    } else {
	      return (
	        createIndent(config, state) +
	        config.tagShortStart +
	        node.name +
	        stringifyAttributes(node, config) +
	        config.tagOpenEnd +
	        config.tagCloseStart +
	        node.name +
	        config.tagCloseEnd
	      );
	    }
	    // non-empty element
	  } else {
	    let tagOpenStart = config.tagOpenStart;
	    let tagOpenEnd = config.tagOpenEnd;
	    let tagCloseStart = config.tagCloseStart;
	    let tagCloseEnd = config.tagCloseEnd;
	    let openIndent = createIndent(config, state);
	    let closeIndent = createIndent(config, state);

	    if (state.textContext) {
	      tagOpenStart = defaults.tagOpenStart;
	      tagOpenEnd = defaults.tagOpenEnd;
	      tagCloseStart = defaults.tagCloseStart;
	      tagCloseEnd = defaults.tagCloseEnd;
	      openIndent = '';
	    } else if (textElems.includes(node.name)) {
	      tagOpenEnd = defaults.tagOpenEnd;
	      tagCloseStart = defaults.tagCloseStart;
	      closeIndent = '';
	      state.textContext = node;
	    }

	    const children = stringifyNode(node, config, state);

	    if (state.textContext === node) {
	      state.textContext = null;
	    }

	    return (
	      openIndent +
	      tagOpenStart +
	      node.name +
	      stringifyAttributes(node, config) +
	      tagOpenEnd +
	      children +
	      closeIndent +
	      tagCloseStart +
	      node.name +
	      tagCloseEnd
	    );
	  }
	};

	/**
	 * @type {(node: XastElement, config: Options) => string}
	 */
	const stringifyAttributes = (node, config) => {
	  let attrs = '';
	  for (const [name, value] of Object.entries(node.attributes)) {
	    // TODO remove attributes without values support in v3
	    if (value !== undefined) {
	      const encodedValue = value
	        .toString()
	        .replace(config.regValEntities, config.encodeEntity);
	      attrs += ' ' + name + config.attrStart + encodedValue + config.attrEnd;
	    } else {
	      attrs += ' ' + name;
	    }
	  }
	  return attrs;
	};

	/**
	 * @type {(node: XastText, config: Options, state: State) => string}
	 */
	const stringifyText = (node, config, state) => {
	  return (
	    createIndent(config, state) +
	    config.textStart +
	    node.value.replace(config.regEntities, config.encodeEntity) +
	    (state.textContext ? '' : config.textEnd)
	  );
	};
	return stringifier;
}

var hasRequiredSvgo;

function requireSvgo () {
	if (hasRequiredSvgo) return svgo;
	hasRequiredSvgo = 1;

	const {
	  defaultPlugins,
	  resolvePluginConfig,
	  extendDefaultPlugins,
	} = requireConfig();
	const { parseSvg } = requireParser();
	const { stringifySvg } = requireStringifier();
	const { invokePlugins } = requirePlugins$1();
	const JSAPI = requireJsAPI();
	const { encodeSVGDatauri } = requireTools();

	svgo.extendDefaultPlugins = extendDefaultPlugins;

	const optimize = (input, config) => {
	  if (config == null) {
	    config = {};
	  }
	  if (typeof config !== 'object') {
	    throw Error('Config should be an object');
	  }
	  const maxPassCount = config.multipass ? 10 : 1;
	  let prevResultSize = Number.POSITIVE_INFINITY;
	  let svgjs = null;
	  const info = {};
	  if (config.path != null) {
	    info.path = config.path;
	  }
	  for (let i = 0; i < maxPassCount; i += 1) {
	    info.multipassCount = i;
	    // TODO throw this error in v3
	    try {
	      svgjs = parseSvg(input, config.path);
	    } catch (error) {
	      return { error: error.toString(), modernError: error };
	    }
	    if (svgjs.error != null) {
	      if (config.path != null) {
	        svgjs.path = config.path;
	      }
	      return svgjs;
	    }
	    const plugins = config.plugins || defaultPlugins;
	    if (Array.isArray(plugins) === false) {
	      throw Error(
	        "Invalid plugins list. Provided 'plugins' in config should be an array."
	      );
	    }
	    const resolvedPlugins = plugins.map(resolvePluginConfig);
	    const globalOverrides = {};
	    if (config.floatPrecision != null) {
	      globalOverrides.floatPrecision = config.floatPrecision;
	    }
	    svgjs = invokePlugins(svgjs, info, resolvedPlugins, null, globalOverrides);
	    svgjs = stringifySvg(svgjs, config.js2svg);
	    if (svgjs.data.length < prevResultSize) {
	      input = svgjs.data;
	      prevResultSize = svgjs.data.length;
	    } else {
	      if (config.datauri) {
	        svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
	      }
	      if (config.path != null) {
	        svgjs.path = config.path;
	      }
	      return svgjs;
	    }
	  }
	  return svgjs;
	};
	svgo.optimize = optimize;

	/**
	 * The factory that creates a content item with the helper methods.
	 *
	 * @param {Object} data which is passed to jsAPI constructor
	 * @returns {JSAPI} content item
	 */
	const createContentItem = (data) => {
	  return new JSAPI(data);
	};
	svgo.createContentItem = createContentItem;
	return svgo;
}

var hasRequiredSvgoNode;

function requireSvgoNode () {
	if (hasRequiredSvgoNode) return svgoNode;
	hasRequiredSvgoNode = 1;

	const os = require$$1$3;
	const fs = nativeFs;
	const { pathToFileURL } = require$$0$4;
	const path = path$1;
	const {
	  extendDefaultPlugins,
	  optimize: optimizeAgnostic,
	  createContentItem,
	} = requireSvgo();

	svgoNode.extendDefaultPlugins = extendDefaultPlugins;
	svgoNode.createContentItem = createContentItem;

	const importConfig = async (configFile) => {
	  let config;
	  // at the moment dynamic import may randomly fail with segfault
	  // to workaround this for some users .cjs extension is loaded
	  // exclusively with require
	  if (configFile.endsWith('.cjs')) {
	    config = commonjsRequire(configFile);
	  } else {
	    try {
	      // dynamic import expects file url instead of path and may fail
	      // when windows path is provided
	      const { default: imported } = await import(pathToFileURL(configFile));
	      config = imported;
	    } catch (importError) {
	      // TODO remove require in v3
	      try {
	        config = commonjsRequire(configFile);
	      } catch (requireError) {
	        // throw original error if es module is detected
	        if (requireError.code === 'ERR_REQUIRE_ESM') {
	          throw importError;
	        } else {
	          throw requireError;
	        }
	      }
	    }
	  }
	  if (config == null || typeof config !== 'object' || Array.isArray(config)) {
	    throw Error(`Invalid config file "${configFile}"`);
	  }
	  return config;
	};

	const isFile = async (file) => {
	  try {
	    const stats = await fs.promises.stat(file);
	    return stats.isFile();
	  } catch {
	    return false;
	  }
	};

	const loadConfig = async (configFile, cwd = process.cwd()) => {
	  if (configFile != null) {
	    if (path.isAbsolute(configFile)) {
	      return await importConfig(configFile);
	    } else {
	      return await importConfig(path.join(cwd, configFile));
	    }
	  }
	  let dir = cwd;
	  // eslint-disable-next-line no-constant-condition
	  while (true) {
	    const js = path.join(dir, 'svgo.config.js');
	    if (await isFile(js)) {
	      return await importConfig(js);
	    }
	    const mjs = path.join(dir, 'svgo.config.mjs');
	    if (await isFile(mjs)) {
	      return await importConfig(mjs);
	    }
	    const cjs = path.join(dir, 'svgo.config.cjs');
	    if (await isFile(cjs)) {
	      return await importConfig(cjs);
	    }
	    const parent = path.dirname(dir);
	    if (dir === parent) {
	      return null;
	    }
	    dir = parent;
	  }
	};
	svgoNode.loadConfig = loadConfig;

	const optimize = (input, config) => {
	  if (config == null) {
	    config = {};
	  }
	  if (typeof config !== 'object') {
	    throw Error('Config should be an object');
	  }
	  return optimizeAgnostic(input, {
	    ...config,
	    js2svg: {
	      // platform specific default for end of line
	      eol: os.EOL === '\r\n' ? 'crlf' : 'lf',
	      ...config.js2svg,
	    },
	  });
	};
	svgoNode.optimize = optimize;
	return svgoNode;
}

var svgoNodeExports = requireSvgoNode();

const splitAttrsTokenizer = /([a-z0-9_\:\-]*)\s*?=\s*?(['"]?)(.*?)\2\s+/gim;
const domParserTokenizer = /(?:<(\/?)([a-zA-Z][a-zA-Z0-9\:]*)(?:\s([^>]*?))?((?:\s*\/)?)>|(<\!\-\-)([\s\S]*?)(\-\->)|(<\!\[CDATA\[)([\s\S]*?)(\]\]>))/gm;
const splitAttrs = (str) => {
  let res = {};
  let token;
  if (str) {
    splitAttrsTokenizer.lastIndex = 0;
    str = " " + (str || "") + " ";
    while (token = splitAttrsTokenizer.exec(str)) {
      res[token[1]] = token[3];
    }
  }
  return res;
};
function optimizeSvg(contents, name, options) {
  return svgoNodeExports.optimize(contents, {
    plugins: [
      "removeDoctype",
      "removeXMLProcInst",
      "removeComments",
      "removeMetadata",
      "removeXMLNS",
      "removeEditorsNSData",
      "cleanupAttrs",
      "minifyStyles",
      "convertStyleToAttrs",
      {
        name: "cleanupIDs",
        params: { prefix: `${SPRITESHEET_NAMESPACE}:${name}` }
      },
      "removeRasterImages",
      "removeUselessDefs",
      "cleanupNumericValues",
      "cleanupListOfValues",
      "convertColors",
      "removeUnknownsAndDefaults",
      "removeNonInheritableGroupAttrs",
      "removeUselessStrokeAndFill",
      "removeViewBox",
      "cleanupEnableBackground",
      "removeHiddenElems",
      "removeEmptyText",
      "convertShapeToPath",
      "moveElemsAttrsToGroup",
      "moveGroupAttrsToElems",
      "collapseGroups",
      "convertPathData",
      "convertTransform",
      "removeEmptyAttrs",
      "removeEmptyContainers",
      "mergePaths",
      "removeUnusedNS",
      "sortAttrs",
      "removeTitle",
      "removeDesc",
      "removeDimensions",
      "removeStyleElement",
      "removeScriptElement"
    ]
  }).data;
}
const preprocessCache = /* @__PURE__ */ new Map();
function preprocess(contents, name, { optimize }) {
  if (preprocessCache.has(contents)) {
    return preprocessCache.get(contents);
  }
  if (optimize) {
    contents = optimizeSvg(contents, name);
  }
  domParserTokenizer.lastIndex = 0;
  let result = contents;
  let token;
  if (contents) {
    while (token = domParserTokenizer.exec(contents)) {
      const tag = token[2];
      if (tag === "svg") {
        const attrs = splitAttrs(token[3]);
        result = contents.slice(domParserTokenizer.lastIndex).replace(/<\/svg>/gim, "").trim();
        const value = { innerHTML: result, defaultProps: attrs };
        preprocessCache.set(contents, value);
        return value;
      }
    }
  }
}
function normalizeProps(inputProps) {
  const size = inputProps.size;
  delete inputProps.size;
  const w = inputProps.width ?? size;
  const h = inputProps.height ?? size;
  const width = w ? toAttributeSize(w) : void 0;
  const height = h ? toAttributeSize(h) : void 0;
  return { ...inputProps, width, height };
}
const toAttributeSize = (size) => String(size).replace(/(?<=[0-9])x$/, "em");
async function load(name, inputProps, optimize) {
  const key = name;
  if (!name) {
    throw new Error("<Icon> requires a name!");
  }
  let svg = "";
  let filepath = "";
  if (name.includes(":")) {
    const [pack, ..._name] = name.split(":");
    name = _name.join(":");
    filepath = `/src/icons/${pack}`;
    let get$1;
    try {
      const files = /* #__PURE__ */ Object.assign({


});
      const keys = Object.fromEntries(
        Object.keys(files).map((key2) => [key2.replace(/\.[cm]?[jt]s$/, ""), key2])
      );
      if (!(filepath in keys)) {
        throw new Error(`Could not find the file "${filepath}"`);
      }
      const mod = files[keys[filepath]];
      if (typeof mod.default !== "function") {
        throw new Error(
          `[astro-icon] "${filepath}" did not export a default function!`
        );
      }
      get$1 = mod.default;
    } catch (e) {
    }
    if (typeof get$1 === "undefined") {
      get$1 = get.bind(null, pack);
    }
    const contents = await get$1(name, inputProps);
    if (!contents) {
      throw new Error(
        `<Icon pack="${pack}" name="${name}" /> did not return an icon!`
      );
    }
    if (!/<svg/gim.test(contents)) {
      throw new Error(
        `Unable to process "<Icon pack="${pack}" name="${name}" />" because an SVG string was not returned!

Recieved the following content:
${contents}`
      );
    }
    svg = contents;
  } else {
    filepath = `/src/icons/${name}.svg`;
    try {
      const files = /* #__PURE__ */ Object.assign({


});
      if (!(filepath in files)) {
        throw new Error(`Could not find the file "${filepath}"`);
      }
      const contents = files[filepath];
      if (!/<svg/gim.test(contents)) {
        throw new Error(
          `Unable to process "${filepath}" because it is not an SVG!

Recieved the following content:
${contents}`
        );
      }
      svg = contents;
    } catch (e) {
      throw new Error(
        `[astro-icon] Unable to load "${filepath}". Does the file exist?`
      );
    }
  }
  const { innerHTML, defaultProps } = preprocess(svg, key, { optimize });
  if (!innerHTML.trim()) {
    throw new Error(`Unable to parse "${filepath}"!`);
  }
  return {
    innerHTML,
    props: { ...defaultProps, ...normalizeProps(inputProps) }
  };
}

const $$Astro$4 = createAstro("https://willcarkner.com");
const $$Icon = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$4, $$props, $$slots);
  Astro2.self = $$Icon;
  let { name, pack, title, optimize = true, class: className, ...inputProps } = Astro2.props;
  let props = {};
  if (pack) {
    name = `${pack}:${name}`;
  }
  let innerHTML = "";
  try {
    const svg = await load(name, { ...inputProps, class: className }, optimize);
    innerHTML = svg.innerHTML;
    props = svg.props;
  } catch (e) {
    {
      throw new Error(`[astro-icon] Unable to load icon "${name}"!
${e}`);
    }
  }
  return renderTemplate`${maybeRenderHead()}<svg${spreadAttributes(props)}${addAttribute(name, "astro-icon")}>${unescapeHTML((title ? `<title>${title}</title>` : "") + innerHTML)}</svg>`;
}, "/Users/williamcarkner/coding/will-carkner-com/node_modules/.pnpm/astro-icon@0.8.2/node_modules/astro-icon/lib/Icon.astro", void 0);

const sprites = /* @__PURE__ */ new WeakMap();
function trackSprite(request, name) {
  let currentSet = sprites.get(request);
  if (!currentSet) {
    currentSet = /* @__PURE__ */ new Set([name]);
  } else {
    currentSet.add(name);
  }
  sprites.set(request, currentSet);
}
const warned = /* @__PURE__ */ new Set();
async function getUsedSprites(request) {
  const currentSet = sprites.get(request);
  if (currentSet) {
    return Array.from(currentSet);
  }
  if (!warned.has(request)) {
    const { pathname } = new URL(request.url);
    console.log(`[astro-icon] No sprites found while rendering "${pathname}"`);
    warned.add(request);
  }
  return [];
}

const $$Astro$3 = createAstro("https://willcarkner.com");
const $$Spritesheet = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$3, $$props, $$slots);
  Astro2.self = $$Spritesheet;
  const { optimize = true, style, ...props } = Astro2.props;
  const names = await getUsedSprites(Astro2.request);
  const icons = await Promise.all(names.map((name) => {
    return load(name, {}, optimize).then((res) => ({ ...res, name })).catch((e) => {
      {
        throw new Error(`[astro-icon] Unable to load icon "${name}"!
${e}`);
      }
    });
  }));
  return renderTemplate`${maybeRenderHead()}<svg${addAttribute(`position: absolute; width: 0; height: 0; overflow: hidden; ${style ?? ""}`.trim(), "style")}${spreadAttributes({ "aria-hidden": true, ...props })} astro-icon-spritesheet> ${icons.map((icon) => renderTemplate`<symbol${spreadAttributes(icon.props)}${addAttribute(`${SPRITESHEET_NAMESPACE}:${icon.name}`, "id")}>${unescapeHTML(icon.innerHTML)}</symbol>`)} </svg>`;
}, "/Users/williamcarkner/coding/will-carkner-com/node_modules/.pnpm/astro-icon@0.8.2/node_modules/astro-icon/lib/Spritesheet.astro", void 0);

const $$Astro$2 = createAstro("https://willcarkner.com");
const $$SpriteProvider = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$2, $$props, $$slots);
  Astro2.self = $$SpriteProvider;
  const content = await Astro2.slots.render("default");
  return renderTemplate`${renderComponent($$result, "Fragment", Fragment, {}, { "default": async ($$result2) => renderTemplate`${unescapeHTML(content)}` })}${renderComponent($$result, "Spritesheet", $$Spritesheet, {})}`;
}, "/Users/williamcarkner/coding/will-carkner-com/node_modules/.pnpm/astro-icon@0.8.2/node_modules/astro-icon/lib/SpriteProvider.astro", void 0);

const $$Astro$1 = createAstro("https://willcarkner.com");
const $$Sprite = createComponent(($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
  Astro2.self = $$Sprite;
  let { name, pack, title, class: className, x, y, ...inputProps } = Astro2.props;
  const props = normalizeProps(inputProps);
  if (pack) {
    name = `${pack}:${name}`;
  }
  const href = `#${SPRITESHEET_NAMESPACE}:${name}`;
  trackSprite(Astro2.request, name);
  return renderTemplate`${maybeRenderHead()}<svg${spreadAttributes(props)}${addAttribute(className, "class")}${addAttribute(name, "astro-icon")}> ${title ? renderTemplate`<title>${title}</title>` : ""} <use${spreadAttributes({ "xlink:href": href, width: props.width, height: props.height, x, y })}></use> </svg>`;
}, "/Users/williamcarkner/coding/will-carkner-com/node_modules/.pnpm/astro-icon@0.8.2/node_modules/astro-icon/lib/Sprite.astro", void 0);

Object.assign($$Sprite, { Provider: $$SpriteProvider });

const $$Astro = createAstro("https://willcarkner.com");
const prerender = false;
const $$Index = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Index;
  const posts = (await getPosts()).slice(0, 3);
  return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": "Will Carkner" }, { "default": async ($$result2) => renderTemplate`  ${renderComponent($$result2, "Section", $$Section, {}, { "default": async ($$result3) => renderTemplate` ${maybeRenderHead()}<div class="grid w-full grid-cols-1 gap-8 md:flex-row md:flex"> <!-- ABOUT ME --> <div class="md:flex-1 space-y-8"> <div class="rounded-xl bg-gradient-to-r animate-gradient-x from-blue-600 via-purple-600 to-violet-600 p-0.5"> ${renderComponent($$result3, "Card", $$Card, { "class": "items-left !shadow-none" }, { "default": async ($$result4) => renderTemplate` <div class="flex-col text-left space-y-4 flex"> <div class="flex flex-row space-x-4"> <img alt="Will Carkner" src="will-c.jpg" class="w-24 h-auto rounded-lg"> <div class="flex flex-col justify-end text-left"> <h2>Will</h2> <h2>Carkner</h2> </div> </div> <p class="text-gray-400 font-mono bold-slate-p text-justify">
I'm a 19 year old <b> engineering</b> student, based in Dublin. I
<b>love</b> to build stuff!
</p><p class="text-gray-400 font-mono bold-slate-p text-justify">
I am currently teaching myself <b>RF electronics</b> and am fascinated
                by power systems + energy abundance.
</p> </div> ` })} </div> <!-- Writing --> ${renderComponent($$result3, "ArticleDisplay", $$ArticleDisplay, { "home": true, "title": "Writing", "posts": posts })} <!-- Music --> ${renderComponent($$result3, "Card", $$Card, {}, { "default": async ($$result4) => renderTemplate` <div class="flex flex-row items-center space-x-4 justify-center"> <img class="w-20 h-20 hover:scale-110 duration-300 hover:cursor-pointer border border-gray-600 rounded-md" src="dyer-maker.jpg" alt="dyer maker album cover"> <div class="flex flex-col text-left justify-center"> <h4 class="mb-1">Music</h4> <p class="text-gray-400 font-mono bold-slate-p"> <b>D'yer Mak'er</b> by
<a class="hover:cursor-pointer" href="https://www.youtube.com/watch?app=desktop&v=xje-1sw3T0s&t=0s">Led Zepplin</a> </p> </div> </div> ` })} <!-- Contact --> <div class="rounded-xl bg-gradient-to-r animate-gradient-x from-blue-600 via-purple-600 to-violet-600 p-0.5"> ${renderComponent($$result3, "Card", $$Card, { "class": "space-y-2 !shadow-none" }, { "default": async ($$result4) => renderTemplate` <h4>Contact</h4> <p class="font-mono text-gray-400 bold-slate-p">
If any of what you see here seems interesting, I'd <b>love</b> to hear
              from you!
</p> <div class="flex flex-row space-x-2"> ${[
    {
      icon: "mdi:github",
      href: "https://github.com/will-carkner"
    },
    {
      icon: "mdi:email",
      href: "mailto:will@willcarkner.com"
    },
    {
      icon: "mdi:instagram",
      href: "https://www.instagram.com/_willcarkner/"
    }
  ].map((item) => renderTemplate`<a${addAttribute(item.href, "href")} target="_blank" class="hover:duration-300 hover:scale-110"> ${renderComponent($$result4, "Icon", $$Icon, { "class": "w-8 h-8 text-gray-300 hover:text-sky-400", "name": item.icon })} </a>`)} </div> <a class="text-white font-mono font-bold no-underline hover:text-sky-400 text-base hover:underline" href="/blog/contact">
Learn More
</a> ` })} </div> <!-- Reading --> ${renderComponent($$result3, "Card", $$Card, { "class": "space-y-4" }, { "default": async ($$result4) => renderTemplate` <h4>Reading</h4> <ul class="text-left font-mono list-disc text-gray-400 bold-slate-p pl-2"> <li>
RF Electronics Handbook | <b>American Radio Relay League</b> </li> <li>The Big Score | <b>Michael S. Malone</b></li> <li>Storm of Steel | <b>Ernst JÃ¼nger</b></li> </ul> <a class="text-white font-mono font-bold no-underline hover:text-sky-400 text-base hover:underline" href="/blog/reading">
My Notes
</a> ` })} </div> <div class="md:flex-1 space-y-8"> <!-- Projects --> ${renderComponent($$result3, "Card", $$Card, { "class": "space-y-4" }, { "default": async ($$result4) => renderTemplate` <h4>Work</h4> <div class="flex flex-col space-y-4 justify-end"> ${[
    {
      title: "Lumindt",
      tags: ["Hardware", "Energy", "EE"],
      image: "lumindt.png",
      url: "https://lumindt.com",
      class: "aspect-[3/2]"
    },
    {
      title: "Founders Site",
      tags: ["Astro", "Tailwind", "Client"],
      image: "founders.jpg",
      url: "https://joinfounders.co",
      class: "aspect-[3/2]"
    },
    {
      title: "BloodBox",
      tags: ["Hardware", "ML", "MedTech"],
      image: "bloodbox.jpg",
      url: "https://bloodbox.info"
    },
    {
      title: "Helio",
      tags: ["SaaS", "Client", "NextJS"],
      image: "helio.png",
      url: "https://helio-safety.com",
      class: "aspect-[3/2]"
    },
    {
      title: "Research",
      tags: ["Economics", "Genomics", "AI"],
      image: "research.jpeg",
      url: "https://willcarkner.com/blog/research",
      class: "aspect-[3/2]"
    },
    {
      title: "MLTCC Tennis",
      tags: ["Landing Page", "Client"],
      image: "mltcc.jpg",
      url: "https://mltcc.com",
      class: "aspect-[3/2]"
    },
    {
      title: "BattleBot",
      tags: ["Hardware", "Robotics"],
      image: "bot.jpeg",
      url: ""
    },
    {
      title: "TCD Hist Club",
      tags: ["Landing Page", "Client"],
      image: "hist-club.png",
      url: "https://tcdhistclub.com",
      class: "aspect-[3/2]"
    }
  ].map((item, i) => renderTemplate`<div${addAttribute(`project-${i}`, "id")}${addAttribute([i < 3 ? "visible" : "hidden"], "class:list")}> ${renderComponent($$result4, "Project", $$Project, { "title": item.title, "tags": item.tags, "image": "projects/" + item.image, "url": item.url, "class": item.class })} </div>`)} </div> <a class="text-white font-mono font-bold no-underline hover:text-sky-400 text-base hover:cursor-pointer hover:underline" id="more-projects">
View More
</a> ${renderScript($$result4, "/Users/williamcarkner/coding/will-carkner-com/src/pages/index.astro?astro&type=script&index=0&lang.ts")} <div class="flex flex-row space-x-4"> ${[
    {
      title: "Formal CV",
      href: "/cv.pdf"
    },
    {
      title: "Current Work",
      href: "/blog/current"
    },
    {
      title: "Hire Me",
      href: "/blog/hire"
    }
  ].map((item) => renderTemplate`<a class="no-underline border hover:scale-110 border-gray-600 px-2 py-1 rounded-lg font-mono"${addAttribute(item.href, "href")}> ${item.title} </a>`)} </div> ` })} <!-- CORE IDEAS --> ${renderComponent($$result3, "Card", $$Card, { "class": "space-y-2" }, { "default": async ($$result4) => renderTemplate` <h4>Principles</h4> <ul class="flex flex-row space-x-4"> ${[
    {
      idea: "Learn",
      href: "/blog/learn"
    },
    {
      idea: "Build",
      href: "/blog/current"
    },
    {
      idea: "Impact",
      href: "/blog/impact"
    }
  ].map((item) => renderTemplate`<li class="flex flex-row"> <a${addAttribute(item.href, "href")}> <div class="font-mono bold-slate-p">${item.idea}</div> </a> ${item.idea !== "Impact" ? renderTemplate`<p class="pl-3">|</p>` : ""} </li>`)} </ul> <div class="text-gray-400 font-mono bold-slate-p">
I aim to <b>constantly learn</b>, <b>build tangible things</b>, and <b>focus on impact</b>.
</div> ` })} <!--PHOTOS --> ${renderComponent($$result3, "Card", $$Card, {}, { "default": async ($$result4) => renderTemplate` <div class="space-y-4"> <h4>Photos</h4> <div class="flex flex-row space-x-2 md:space-x-4 items-center justify-center"> ${[
    {
      img: "cool-photos/beach.jpeg",
      alt: "Italian Beach"
    },
    {
      img: "cool-photos/city.jpeg",
      alt: "Matera"
    },
    {
      img: "cool-photos/town.jpeg",
      alt: "Italian town"
    }
  ].map((item) => renderTemplate`<img${addAttribute(item.alt, "alt")} class="w-20 h-30 sm:w-40 sm:h-32 border border-gray-600 rounded-lg"${addAttribute(item.img, "src")}>`)} </div> <div> <a class="text-white font-mono font-bold no-underline hover:text-sky-400 text-base hover:underline" href="/photos">
View More
</a> </div> </div> ` })} <!-- WORKOUTS --> <!-- <Card>
          <div class="space-y-2">
            <h4>Exercise</h4>
            <div class="flex flex-col space-y-2 items-left justify-left">
              {
                [
                  {
                    type: 'Upper Strength',
                    desc: ['Push press', 'Bench press', 'Pull up', 'T bar row'],
                  },
                  {
                    type: 'Lower Strength',
                    desc: [
                      'Hang snatch',
                      'Bulgarian split squat',
                      'Back squat',
                      'Calf raise',
                    ],
                  },
                  {
                    type: 'Impulse',
                    desc: [
                      'Power clean',
                      'Front squat',
                      'Nordic curl',
                      'Standing calf raise',
                    ],
                  },
                  {
                    type: 'Plyometrics',
                    desc: [
                      'Broad jump',
                      'Core work',
                      'Pogo jumps',
                      'Single leg box jump',
                    ],
                  },
                ].map((item) => (
                  <div class="flex flex-col">
                    <p class="font-bold text-center pb-1">{item.type}</p>
                    <ul class="p-1 px-2 border shadow-slate-900 rounded-xl text-left border-gray-600 grid grid-cols-2">
                      {item.desc.map((thing) => (
                        <li>&bullet; {thing}</li>
                      ))}
                    </ul>
                  </div>
                ))
              }
            </div>
          </div>
        </Card> --> ${renderComponent($$result3, "Card", $$Card, {}, { "default": async ($$result4) => renderTemplate` <div class="space-y-2"> <h4>Thought</h4> <p class="text-gray-400 font-mono bold-slate-p text-left">
Fall in love and <b>stay in love</b>. Explode. Don't
              intellectualize. Get passionate about ideas. Cram your head full
              of images. Stay in the library. Stay off the internet and all that
              crap. <b>Read all the great books</b>. Read all the great poetry.
              See all the great films. Fill your life with metaphors. <b>And then explode.</b> </p> <div class="flex flex-row space-x-2"> <p class="text-gray-400 font-mono">- Ray Bradbury</p> <p class="text-sm font-mono text-gray-500 translate-y-px">
(emphasis my own)
</p> </div> </div> ` })} </div> </div> ` })} ` })}`;
}, "/Users/williamcarkner/coding/will-carkner-com/src/pages/index.astro", void 0);

const $$file = "/Users/williamcarkner/coding/will-carkner-com/src/pages/index.astro";
const $$url = "";

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$Index,
  file: $$file,
  prerender,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
